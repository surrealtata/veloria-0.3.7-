<?xml version="1.0" encoding="ISO-8859-1"?>
<?xml-stylesheet href="file:///C|/Users/Korisnik/Desktop/gamemodes for edit/`veloria - 0.3.7 `/pawno/xml/pawndoc.xsl" type="text/xsl"?>
<doc source="C:\Users\Korisnik\Desktop\gamemodes for edit\`veloria - 0.3.7 `\gamemodes\`main`.pwn">
	<assembly>
		<name>`main`.pwn</name>
	</assembly>

	<!-- general -->
	<general>
		<library name="y_ini">  <section>  Description  </section>  Reads the INI and also exports a number of functions to other "classes" for  easy reading of data files there.  <section>  Version  </section>  1.5  <section>  Functions  </section>  <subsection>  Stock  </subsection><ul>  <symbol name="INI_Load">Loads an INI file using standard features.</symbol>  <symbol name="INI_ParseFile">Loads a file as an ini and distributes data.</symbol>  <symbol name="INI_GetEntryName">Gets the name of an INI item.</symbol>  <symbol name="INI_GetEntryText">Gets the value of an INI item.</symbol>  <symbol name="INI_Open">Opens an INI for writing.</symbol>  <symbol name="INI_Close">Closes an INI being written to.</symbol>  <symbol name="INI_SetTag">Sets a subheading in an INI fo subsequent writes.</symbol>  <symbol name="INI_WriteString">Writes a string to an INI.</symbol>  <symbol name="INI_WriteInt">Writes an int to an INI.</symbol>  <symbol name="INI_WriteFloat">Writes a float to an INI.</symbol>  <symbol name="INI_WriteHex">Writes a hex to an INI.</symbol>  <symbol name="INI_WriteBin">Writes a binary to an INI.</symbol>  <symbol name="INI_WriteBool">Writes a boolean to an INI.</symbol>  <symbol name="INI_RemoveEntry">Remove an entry from a file.</symbol>  </ul><subsection>  Static  </subsection><ul>  <symbol name="INI_WriteBuffer">Writes an INI's buffer to the file.</symbol>  <symbol name="INI_AddToBuffer">Adds a string to an INI buffer.</symbol>  </ul><subsection>  Inline  </subsection><ul>  <symbol name="INI_Int">Parse an integer INI entry.</symbol>  <symbol name="INI_Float">Parse a float INI entry.</symbol>  <symbol name="INI_Hex">Parse a hex INI entry.</symbol>  <symbol name="INI_Bin">Parse a binary INI entry.</symbol>  <symbol name="INI_Bool">Parse a binary INI entry.</symbol>  <symbol name="INI_String">Parse a string INI entry.</symbol>  </ul><section>  Definitions  </section><ul>  <symbol name="MAX_INI_TAG">Maximum length of an INI tagname.</symbol>  <symbol name="MAX_INI_ENTRY_NAME">Maximum length of an INI entry name.</symbol>  <symbol name="MAX_INI_ENTRY_TEXT">Maximum length of an INI's entries' value.</symbol>  <symbol name="MAX_INI_LINE">Maximum length of a line in a file.</symbol>  <symbol name="INI_NEW_LINE">String for new lines.</symbol>  <symbol name="INI_MAX_WRITES">Maximum concurrent files open for writing.</symbol>  <symbol name="MAX_INI_TAGS">Number of tags the buffer can hold data for at once.</symbol>  </ul><section>  Enums  </section><ul>  <symbol name="E_INI_WRITE">Storage for entries to be written.</symbol>  <symbol name="E_INI_TAGS">Data for tags with data.</symbol>  </ul><section>  Macros  </section><ul>  <symbol name="INI_Parse">Header for ini parsing functions.</symbol>  </ul><section>  Tags  </section><ul>  <symbol name="INI">Handle to an INI file being written to.</symbol>  </ul><section>  Variables  </section>  <subsection>  Static  </subsection><ul>  <symbol name="YSI_g_sINIWriteBuffer">Basic data to be written.</symbol>  <symbol name="YSI_g_sINIWritePos">Next slot to write to.</symbol>  <symbol name="YSI_g_sINITagPos">Next slot to add a tag to.</symbol>  <symbol name="YSI_g_sINICurrentTag">Pointer to the tag been writen to.</symbol>  <symbol name="YSI_g_sINIWriteTag">Data for tags,</symbol>  <symbol name="YSI_g_sINIWriteFile">Current files been written to.</symbol>  </ul>  </library> <p/> <!--  <transition target[^/]+/>  :::::::: README ::::::::  To read the generated XML output, copy `pawndoc.xsl` to `pawno/xml/`.  This information goes very close to the top of the generated XML documentation  (because of include dependency orders), but doesn't appear in the visual output.  There is a bug in the compiler related to outputting documentation on state  transitions (<a href="https://github.com/Zeex/pawn/issues/184" />).  So after  generation of the XML file, you should clean it up with the following RegEx  replacement:  Search: <transition target[^/]+/>  Replace: (nothing)  This works 99% of the time, though you may get one where the corrupted target  includes the character `/`, in which case you should manually delete them.  Note  that YSI now includes manual documentation for transitions, but these all  include the parameter `keep="true"`, which exists simply to not match that  RegEx.  I also put the search at the top of this block so it is easier to find  in the output code.  --> <p/> <library name="y_scriptinit">  <section>  Description  </section>  This file provides "OnScriptInit" and "OnScriptExit" which are called at the  start and end of the current script, regardless of what the type of the  script is (note: doesn't support NPC modes).  It also provides  "YSI_FILTERSCRIPT" as a (partial) replacement for "FILTERSCRIPT" which  detects what the mode is at runtime for a more reliable system (but it is a  run-time variable, not a compile-time constant).  <section>  Version  </section>  1.0  </library> <p/> <library name="y_utils">  <section>  Description  </section>  Misc functions used throughout.  <section>  Version  </section>  0.1.3  <section>  Functions  </section>  <subsection>Stock</subsection>  <ul>  <symbol name="StrToLower">Convert a whole string to lower-case.</symbol>  <symbol name="StrToUpper">Convert a whole string to upper-case.</symbol>  <symbol name="Random">Generate a random number, optionally takes lower and upper bounds.</symbol>  <symbol name="RandomFloat">Same as <symbolref name="Random" />, but for floats.</symbol>  <symbol name="StripNL">Strips the newline characters from the end of a string.</symbol>  <symbol name="StripL">Remove whitespace from the start of a string.</symbol>  <symbol name="Strip">Remove whitespace from both ends of a string.</symbol>  <symbol name="endofline">Check if the given position is the end of a string (ignoring whitespace).</symbol>  <symbol name="chrfind">Return the first position (after <symbolref name="start" />) of the given character.</symbol>  <symbol name="chrfindp">Like <symbolref name="chrfind" />, but without the upper-bounds check.</symbol>  <symbol name="bernstein">Generate the Bernstein hash of the given string.</symbol>  <symbol name="ishex">Is the given string hexadecimal?</symbol>  <symbol name="unpack">Version of <symbolref name="strunpack" /> that returns the result.</symbol>  <symbol name="returnstringarg">Get the string passed as a variable argument from the given index.</symbol>  <symbol name="va_return">Like <symbolref name="sprintf" />, formats a string and returns the result.</symbol>  <symbol name="isnumeric">Is the given string a number?</symbol>  <symbol name="hexstr">Return the value of the given hexadecimal string.</symbol>  <symbol name="boolstr">Return the value of the given boolean string.</symbol>  <symbol name="binstr">Return the value of the given binary string.</symbol>  <symbol name="rawMemcpy">Copy memory between two address, instead of two arrays.</symbol>  <symbol name="memset">Set all of an array to a value.</symbol>  <symbol name="rawMemset">Set all of a given memory region to a value.</symbol>  <symbol name="ReturnPlayerName">Return a player's name.</symbol>  <symbol name="ftouch">Ensures that a file exists, but nothing more.</symbol>  <symbol name="InterpolateColour">Get the colour (in 3D RGB space) between two other colours.</symbol>  <symbol name="SkipWhitespace">Return the first position in a string of a non-whitespace character.</symbol>  <symbol name="Trim">Get the first and last positions of non-whitespace characters in the string.  Like  <symbolref name="Strip" />, but doesn't modify the string.</symbol>  <symbol name="Sum">Get the total (sum) of an array.</symbol>  <symbol name="Mean">Get the mathematical mean of an array.</symbol>  <symbol name="Mode">Get the mathematical mode of an array.</symbol>  <symbol name="Median">Get the mathematical median of an array.</symbol>  <symbol name="Range">Get the mathematical range of an array.</symbol>  </ul>  <subsection>Inline</subsection>  <ul>  <symbol name="UCMP">Unsigned compare.</symbol>  <symbol name="VALID_PLAYERID">Check if a player ID is valid (in range).</symbol>  <symbol name="IS_IN_RANGE">Check if a number is in range.</symbol>  <symbol name="NOT_IN_RANGE">Check if a number is outside a range.</symbol>  <symbol name="ceildiv">Divide two numbers and round up.</symbol>  <symbol name="floordiv">Divide two numbers and round down.</symbol>  <symbol name="isnull">Checks if a string is NULL (<c>\1\0</c> or <c>\0</c>).</symbol>  <symbol name="isodd">Checks if a number is odd.</symbol>  <symbol name="iseven">Checks if a number is even.</symbol>  <symbol name="strcpy">Copy one string to another.</symbol>  <symbol name="GetIP">Return the encoded (32-bit) version of a player's IP.</symbol>  <synonym name="getstring" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="GetString" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="getstringarg" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="GetStringArg" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="ReturnStringArg" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="InterpolateColor" for="InterpolateColour" />  <synonym name="StripR" for="StripNL" />  </ul>  <section>  Variables  </section>  <subsection>Global</subsection>  <ul>  <symbol name="TRUE">True hack for infinate loops.</symbol>  <symbol name="FALSE">False hack for one-time loops.</symbol>  <symbol name="NULL">1 long string for passing via Call(Remote|Local)Function.</symbol>  </ul>  </library> <p/> <library name="y_debug">  <section>  Description  </section>  <p>Ensures debug levels are set and defines debug functions.</p>  <p>General debug levels:</p>  <ul>  <li>-1 - Run-time selected debug level.</li>  <li>0 - No debug information.</li>  <li>1 - Callbacks and timers.</li>  <li>2 - Remote functions.</li>  <li>3 - Stock functions.</li>  <li>4 - Static functions.</li>  <li>5 - Code.</li>  <li>6 - Loops.</li>  <li>7 - Extra loop code.</li>  </ul>  <p>If you use <c>P:0</c> you get an optional debug print controlled by the  global state <c>ysi_debug</c> - which is either on or off.</p>  <section>  Version  </section>  1.0  <section>  Functions  </section>  <subsection>  Inline  </subsection><ul>  <symbol name="Debug_Code">Runs defined code if a certain level is active.</symbol>  <symbol name="Debug_Print">Prints the formatted string provided at the given level.</symbol>  </ul><subsection>  Stock  </subsection><ul>  <symbol name="Debug_PrintArray">Print several items from an array for debugging purposes.</symbol>  <symbol name="Debug_Enable">Turn on level 0 prints.</symbol>  <symbol name="Debug_Disable">Turn off level 0 prints.</symbol>  <symbol name="Debug_Level">Set the debug level when the code is compiled with  <c>_DEBUG=-1</c>, which means full run-time selection.</symbol>  </ul><section>  Definitions  </section><ul>  <symbol name="P:&lt;0-6&gt;">Print a message.</symbol>  <symbol name="P:C">Run debug code.</symbol>  <symbol name="P:E">Print an error message.</symbol>  <symbol name="P:W">Print a warning message.</symbol>  </ul><section>Compile options</section><ul>  <symbol name="_DEBUG">Debugging level to use.</symbol>  </ul>  </library> <p/> <library name="y_amx">  <section>  Description  </section>  Allows a script access to information about itself, such as function names.  This can be used for a range of things, including automatic callback hooking  and testing.  <section>  Version  </section>  1.0  </library> <p/> <library name="y_va">  <section>  Description  </section>  This library currently provides two functions - va_printf and va_format  which perform printf and format using variable arguments passed to another  function.  This is bsed on the variable parameter passing method based on code by Zeex.  See page 15 of the code optimisations topic.  <section>  Version  </section>  1.0  </library> <p/> <library name="y_malloc">  <section>  Description  </section>  Functions for using malloc/calloc/free type functions in PAWN.  <section>  Version  </section>  0.1  <section>  Functions  </section>  <subsection>  Stock  </subsection><ul>  <symbol name="malloc">Allocate a block of memory (may be inline).</symbol>  <symbol name="calloc">Allocate a block of memory and blank.</symbol>  <symbol name="free">Free an allocated block of memory (may be inline).</symbol>  <symbol name="Malloc_Set">Set a value in an allocated array (may be inline).</symbol>  <symbol name="Malloc_Get">Get a value in an allocated array (may be inline).</symbol>  <symbol name="Malloc_SetS">Set a string in an allocated array.</symbol>  <symbol name="Malloc_GetS">Get a string in an allocated array.</symbol>  <symbol name="Malloc_Allocate">Do the memory allocation (may be static).</symbol>  <symbol name="Malloc_Free">Do the memory freeing (may be static).</symbol>  <symbol name="Malloc_SlotSize">Get the size of an allocated block (may be inline).</symbol>  <symbol name="Malloc_NewS">Allocate for and store a given string.</symbol>  </ul><subsection>  Static  </subsection><ul>  <symbol name="Malloc_Allocate">Do the memory allocation (may be stock).</symbol>  <symbol name="Malloc_Free">Do the memory freeing (may be stock).</symbol>  </ul><subsection>  Inline  </subsection><ul>  <symbol name="mget">Get data from an allocation unit.</symbol>  <symbol name="mset">Set data in an allocation unit.</symbol>  <symbol name="mgets">Get a string from an allocation unit.</symbol>  <symbol name="msets">Set a string in an allocation unit.</symbol>  <symbol name="malloc">Allocate a block of memory (may be stock).</symbol>  <symbol name="free">Free an allocated block of memory (may be stock).</symbol>  <symbol name="Malloc_Set">Set a value in an allocated array (may be stock).</symbol>  <symbol name="Malloc_Get">Get a value in an allocated array (may be stock).</symbol>  <symbol name="Malloc_NextSlot">Get the next free data block.</symbol>  <symbol name="Malloc_GetSlotSize">Get the size of a slot.</symbol>  <symbol name="Malloc_SetSlotSize">Set the size of a block.</symbol>  <symbol name="Malloc_GetData">Direct data access getter.</symbol>  <symbol name="Malloc_SetData">Direct data access setter.</symbol>  <symbol name="Malloc_SlotSize">Get the size of an allocated block (may be stock).</symbol>  </ul><section>  Definitions  </section><ul>  <symbol name="MALLOC_KB_TO_CELL">Multiplication value to convert kb to cells.</symbol>  <symbol name="NO_ALLOC">A failed allocation (NULL, but YSI already has NULL).</symbol>  </ul><section>  Tags  </section><ul>  <symbol name="Alloc">An allocated block handle variable.</symbol>  </ul><section>  Variables  </section>  <subsection>  Global  </subsection><ul>  <symbol name="YSI_gMallocMemory">Stores the data (may be static).</symbol>  </ul><subsection>  Static  </subsection><ul>  <symbol name="YSI_gMallocMemory">Stores the data (may be global).</symbol>  <symbol name="_YSI_g_sUnusedStart">Start of free memory.</symbol>  </ul><section>Compile options</section><ul>  <symbol name="MALLOC_MEMORY">Number of cells to reserve.</symbol>  <symbol name="MALLOC_MEMORY_KB">Number of killobytes to reserve.</symbol>  <symbol name="MALLOC_MEMORY_B">Number of bytes to reserve.</symbol>  <symbol name="MALLOC_MEMORY_MB">Number of megabytes to reserve.</symbol>  <symbol name="YSI_MALLOC_SECURE">Use enhanced bounds checking.</symbol>  <symbol name="YSI_MALLOC_NO_SHORT">Avoid conflicts with mget/mset.</symbol>  </ul>  </library> <p/> <library name="y_bit">  <section>  Description  </section>  Provides functions for bit manipulation and bit arrays greater than 32bits.  The arrays are usually bigger than required due to cell boundaries but this  shouldn't cause a major problem (bit tests on the 101st bit of a 100 bit  array won't return 0 for out of bounds, but the 129th will).  Note that y_commands has a few optimisations which bypass the code in here  so any modifications to bit array layouts will need to be reflected there.  <section>  Version  </section>  0.2  <section>  Functions  </section>  <subsection>  Stock  </subsection><ul>  <symbol name="Bit_Set">Sets a slot to the given value.</symbol>  <symbol name="Bit_Get">Gets a slot state.</symbol>  <symbol name="Bit_SetAll">Sets all the slots in an array to the same thing.</symbol>  <symbol name="Bit_GetCount">Gets the number of 1s in a bit array.</symbol>  </ul><subsection>  Inline  </subsection><ul>  <symbol name="Bit_Bits">Gets the number of cells required for a bit array.</symbol>  <symbol name="Bit_Let">Sets a slot to 1.</symbol>  <symbol name="Bit_Vet">Sets a slot to 0.</symbol>  <symbol name="Bit_GetBits">Gets the bit at a slot unsafely.</symbol>  </ul><section>  Definitions  </section><ul>  <symbol name="CELLSHIFT">Number of bits that can hold "cellbits"</symbol>  </ul><section>  Tags  </section><ul>  <symbol name="Bit">Bit array type.</symbol>  </ul>  </library> <p/> <library name="y_cell">  <section>  Description  </section>  Provides a few functions for manipulating the bits in single cells.  Note  that this is distinct from the y_bit library.  <section>  Version  </section>  0.2  </library> <p/> <library name="y_als">  <section>  Description  </section>  Provides a number of macros for making ALS (Advanced Library System)  callback hooking simpler.  <section>  Version  </section>  1.0  </library> <p/> <library name="y_inline">  <section>  Description  </section>  This library allows a user to write inline functions in their script.  It  first detects all inline functions and generates data on them, such as  parameter counts and addresses.  When an inline function is passed in code  its current context data is stored.  Finally, when an inline function is  found to be called at some point its current local stack is stored in global  memory.  When the function actually is called, the stack is restored, and  additional parameters which are the inline function parameters, are passed.  <section>  Version  </section>  1.0  </library> <p/> <param name="func">The function to call on a delay.</param>  <param name="delay">how long before the first call?</param>  <param name="interval">How long between subsequent calls?</param>  <param name="repeat">How many times to call the function.</param>  <param name="format">The additional parameters' types.</param>  <param name="">The additional parameters.</param>  <remarks>  Calls a function, which may be an inline function, after a given delay, and  with the given regularity after that.  The parameters are slightly different  to those in SetTimer - that takes only an interval and a repeat boolean.  This instead takes two times - the first is the delay before the first call,  the second is the delay between all subsequent calls (mainly to offset  different timers within a given period).  The "repeat" parameter is also  different - instead of being a boolean, it is a count.  "0" no longer means  "don't repeat", but "repeat forever".  "1" no longer means "repeat forever",  but "call once".  All other numbers (beside 0) specify an exact number of  times to call the function before calling it no more.  This is in line with  the "SetTimer_" and "SetTimerEx_" functions in the fixes2 plugin.  </remarks> <p/> <library name="y_stringhash">  <section>  Description  </section>  Allows you to hash strings at compile time to use them in a switch.  <section>  Version  </section>  2.0  <section>  Functions  </section>  <subsection>  Stock  </subsection><ul>  <symbol name="YHash">Generate a string hash at run time.</symbol>  </ul><section>  Definitions  </section><ul>  <symbol name="_H">Generate a string hash at compile time.</symbol>  <symbol name="_I">Generate a case insensitive string hash at compile time.</symbol>  </ul>  </library> <p/> <library name="y_hooks">  <section>  Description  </section>  Automatically hooks any callbacks with a very simple syntax.  <section>  Version  </section>  2.0  </library> <p/> <library name="y_commands">  <section>  Description  </section>  Runs commands registered with the system and calls the required functions.  Also handles alternate names and prefixes.  Based very loosely on dcmd.  <section>  Version  </section>  0.1.4  <section>  Functions  </section>  <subsection>  Public  </subsection><ul>  <symbol name="Command_Add">Adds a command to the array for processing.</symbol>  <symbol name="Command_Remove">Removes a command.</symbol>  <symbol name="Command_Name">Gets the name of a command in a property.</symbol>  </ul><subsection>  Core  </subsection><ul>  <symbol name="Command_Process">Called from OnPlayerCommandText to process entered commands.</symbol>  <symbol name="Command_Parse">Sorts added commands into a binary tree.</symbol>  <symbol name="Command_Hash">Hashes a word for command hashing.</symbol>  <symbol name="Command_ProcRem">Processes a help command in the master script.</symbol>  </ul><subsection>  Stock  </subsection><ul>  <symbol name="Command_SetDisconnectReturn">Sets the return value for unconnected players.</symbol>  <symbol name="Command_UseShortCuts">Toggles use of per-player command shortcuts.</symbol>  <symbol name="Command_SetDeniedReturn">Sets the return value for denied use commands.</symbol>  <symbol name="Command_UseDeniedMessage">Toggles the use of an error message for denied.</symbol>  <symbol name="Command_SetIllegalReturn">Sets the return value for illegal characters.</symbol>  <symbol name="Command_UseAltNames">Toggles the use of ini defined alternate names.</symbol>  <symbol name="Command_UsePrefix">Toggles the use of a global prefix.</symbol>  <symbol name="Command_UseSpace">Toggles the use of a space between prefix and command.</symbol>  <symbol name="Command_SetAltName">Sets the alternate name of a function.</symbol>  <symbol name="Command_SetPrefix">Sets the pfexix to be typed.</symbol>  <symbol name="Comamnd_SetPlayerUse">Sets wether or not a player can use a command.</symbol>  <symbol name="Comamnd_SetPlayerUseByID">Sets wether or not a player can use a command.</symbol>  <symbol name="Command_FindByName">Finds a command in a possibly sorted list.</symbol>  </ul><section>  Definitions  </section><ul>  <symbol name="MAX_COMMAND_LENGTH">The maximum length of a command string.</symbol>  <symbol name="COMMAND_NOT_FOUND">Indicates that a searched for string is not a function.</symbol>  </ul><section>  Enums  </section><ul>  <symbol name="e_COMM_FLAG">Bit mappings for command options.</symbol>  <symbol name="E_COMMANDS">Structure of the array holding the string data.</symbol>  </ul><section>  Macros  </section><ul>  <symbol name="Command_(%1)">Forwards and declares a standard command for calling.</symbol>  <symbol name="ycmd(%1)">Adds a command to the array (wrapper for Command_Add).</symbol>  </ul><section>  Tags  </section><ul>  <symbol name="e_COMM_FLAG">Flag type.</symbol>  </ul><section>  Variables  </section>  <subsection>  Static  </subsection><ul>  <symbol name="YSI_g_sCommands">Holds all the textual data of the commands.</symbol>  <symbol name="YSI_g_sSearchTree">Tree of hashes for function names.</symbol>  <symbol name="YSI_g_sAltTree">Tree of hashes for alternate names.</symbol>  <symbol name="YSI_g_sPrefix">The command prefix.</symbol>  <symbol name="YSI_g_sPrefixLength">Length of the prefix.</symbol>  <symbol name="YSI_g_sCommandIndex">Pointer to the next free index in the function array.</symbol>  <symbol name="YSI_g_sAltCount">The number of commands with altnames.</symbol>  <symbol name="YSI_g_sCommandFlags">Bit array of command options.</symbol>  </ul><section>  Commands  </section><ul>  <symbol name="commands">Lists all commands available to you.</symbol>  </ul><section>Compile options</section><ul>  <symbol name="COMMAND_SENSITIVE">Make commands case sensitive.</symbol>  <symbol name="COMMAND_ACCURATE">Can use '@' in command names.</symbol>  <symbol name="MAX_COMMANDS">The maximum number of commands which can be used.</symbol>  </ul>  </library> <p/> <library name="y_master">  <section>  Description  </section>  Handles distribution of control of code segments across all running scripts  with YSI to avoid conflicts of checkpoint streamers etc and allow features  like "/commands" displaying all commands on the server.  Now fully autonomous - to use the master system simply define which one you  want and include the script:  <c>  #define MASTER 14  #include "Master"  </c>  That will make the current script attempt to make itself the main master -  you don't need ANY other code for initialisation anywhere (which took a  while to figure out)...  This is now over 2000 lines of repetitive and complex macros!  <section>  Version  </section>  0.2  <section>  Macros  </section><ul>  <symbol name="RF">Declare a function which may be remote.</symbol>  <symbol name="RV">Declare a void function which may be remote.</symbol>  <symbol name="RS">Declare an optional callback.</symbol>  <symbol name="RFN">Declare an optional callback with no parameters.</symbol>  <symbol name="RFC">Declare a slower but shorter function.</symbol>  <symbol name="RFP">Declare a function with tags and give recall hints.</symbol>  <symbol name="RFPC">Combination of P and C.</symbol>  <symbol name="RFCP">Combination of P and C.</symbol>  </ul><section>  Variables  </section>  <subsection>  Global  </subsection><ul>  <symbol name="_@">ID of this script.</symbol>  </ul><section>Compile options</section><ul>  <symbol name="YSI_NO_MASTER">Don't use the master system.</symbol>  <symbol name="YSI_IS_CLIENT">Script is a client only script.</symbol>  <symbol name="YSI_IS_SERVER">Script is a server only script.</symbol>  </ul>  </library> <p/> <library name="y_hashmap">  <section>  Description  </section>  Maps string indexes to integer indexes.  Uses a fast hash to get an array  slot, then a linked list to resolve collisions.  <section>  Version  </section>  2.0  <section>  Functions  </section>  <subsection>  Stock  </subsection><ul>  <symbol name="HashMap_Init">Associate a hash map with an array.</symbol>  <symbol name="HashMap_Add">Add a value under a given string.</symbol>  <symbol name="HashMap_Get">Get a value from a string.</symbol>  <symbol name="HashMap_RemoveKey">Remove a string and its value from a hash map.</symbol>  <symbol name="HashMap_Set">Change the value associated with a key.</symbol>  </ul><section>  Definitions  </section><ul>  <symbol name="HASH_MAP_DATA">What should be added to enums to be hash map referenced.</symbol>  <symbol name="HashMap">Declare a new hash map.</symbol>  </ul>  </library> <p/> <library name="y_iterate">  <section>  Description  </section>  Provides efficient looping through sparse data sets, such as connected  players.  Significantly improved from the original version to be a generic  loop system, rather then purely a player loop system.  When used for  players this has constant time O(n) for number of connected players (n),  unlike standard player loops which are O(MAX_PLAYERS), regardless of the  actual number of connected players.  Even when n is MAX_PLAYERS this is  still faster.  For extensive documentation on writing and using iterators, see this topic:  <a href="http://forum.sa-mp.com/showthread.php?t=481877" />  <section>  Version  </section>  0.4  <section>  Functions  </section>  <subsection>  Public  </subsection><ul>  <symbol name="OnPlayerDisconnect">Called when a player leaves to remove them.</symbol>  <symbol name="OnPlayerConnect">Called when a player connects to add them.</symbol>  </ul><subsection>  Stock  </subsection><ul>  <symbol name="Iter_ShowArray">Displays the contents of the array.</symbol>  <symbol name="Iter_AddInternal">Add a value to an iterator.</symbol>  <symbol name="Iter_RemoveInternal">Remove a value from an iterator.</symbol>  <symbol name="Iter_RandomInternal">Get a random item from an iterator.</symbol>  <symbol name="Iter_FreeInternal">Gets the first free slot in the iterator.</symbol>  <symbol name="Iter_InitInternal">Initialises a multi-dimensional iterator.</symbol>  </ul><subsection>  Inline  </subsection><ul>  <symbol name="Iter_Create">Create a new iterator value set.</symbol>  <symbol name="Iter_Add">Wraps Iter_AddInternal.</symbol>  <symbol name="Iter_Remove">Wraps Iter_RemoveInternal.</symbol>  <symbol name="Iter_Random">Wraps Iter_RandomInternal.</symbol>  <symbol name="Iter_Count">Gets the number of items in an iterator.</symbol>  <symbol name="Iter_Debug">Wraps around Iter_ShowArray.</symbol>  <symbol name="Iter_Free">Wraps around Iter_FreeInternal.</symbol>  <symbol name="Iter_Create2">Create a new iterator array value set.</symbol>  <symbol name="Iter_Add2">Wraps Iter_AddInternal for arrays.</symbol>  <symbol name="Iter_Remove2">Wraps Iter_RemoveInternal for arrays.</symbol>  <symbol name="Iter_Random2">Wraps Iter_RandomInternal for arrays.</symbol>  <symbol name="Iter_Count2">Gets the number of items in an iterator array.</symbol>  <symbol name="Iter_Debug2">Wraps around Iter_ShowArray for arrays.</symbol>  <symbol name="Iter_Free2">Wraps around Iter_FreeInternal for arrays.</symbol>  </ul><section>  Hooks  </section><ul>  <symbol name="Iter_OnPlayerConnect">Hook for the OnPlayerConnect callback.</symbol>  <symbol name="Iter_OnPlayerDisconnect">Hook for the OnPlayerDisconnect callback.</symbol>  <symbol name="Iter_OnGameModeInit">Only exists to make the code compile correctly...</symbol>  </ul><section>  Keywords  </section><ul>  <symbol name="foreach">Command to loop an iterator.</symbol>  <symbol name="foreachex">Like foreach but without a new variable.</symbol>  <symbol name="foreach2">Command to loop through an iterator array.</symbol>  <symbol name="foreachex">Like foreach2 but without a new variable.</symbol>  </ul><section>  Tags  </section><ul>  <symbol name="Iterator">Declare an iterator.</symbol>  </ul><section>  Variables  </section>  <subsection>  Static  </subsection><ul>  <symbol name="YSI_g_OPC">Records wether Iter_OnPlayerConnect exists for speed.</symbol>  <symbol name="YSI_g_OPDC">Records wether Iter_OnPlayerDisconnect exists for speed.</symbol>  </ul><section>Compile options</section><ul>  <symbol name="YSI_ITTER_NO_SORT">Removed.</symbol>  <symbol name="FOREACH_NO_BOTS">Remove the bot iterators for smaller code.</symbol>  <symbol name="FOREACH_NO_PLAYERS">Remove all default code for player itteration.</symbol>  </ul><section>  Iterators  </section><ul>  <symbol name="Player">List of all players connected.</symbol>  <symbol name="Bot">List of all bots (npcs) connected.</symbol>  <symbol name="NPC">Alias of Bot.</symbol>  <symbol name="Character">All players and bots.</symbol>  </ul><section>  Examples  </section>  <subsection>Basic Iterators</subsection>  <p>  Basic iterators are simply collections of numbers - little more than an array.  A number is either in the array, or not in the array, <em>y_iterate</em> loops  through only the <em>in</em> numbers.</p>  <p><em>Players</em><br /><br />  This code will loop through every player connected to the server.  <code>  foreach (new i : Player)																				<br />  {																				<br /><indent />  printf("player %d is connected", i);																				<br />  }  </code>  </p>  <p><em>Vehicles</em><br /><br />  This code will loop through all the created vehicles on the server (including  those made in other running scripts).  <code>  foreach (new vid : Vehicle)																				<br />  {																				<br /><indent />  printf("vehicleid %d has been created", vid);																				<br />  }  </code>  </p>  <p><em>Create An Iterator</em><br /><br />  To create your own iterator, first declare it, then add things to it, then loop  over it:  <code>  new																				<br /><indent />  Iterator:MyIter&lt;100&gt;; // First declare it (this has room for 100 items numbered 0-99).									 											<br />  // Then add things to it.																				<br />  Iter_Add(MyIter, 0);  // Fine.																				<br />  Iter_Add(MyIter, 55); // Fine.																				<br />  Iter_Add(MyIter, 100); // Will fail.																				<br />  // Then loop over it.																				<br />  foreach (new i : MyIter)																				<br />  {																				<br /><indent />  printf("%d", i); // Will print "0" then "55".																				<br />  }  </code>  </p>  <subsection>Special Iterators</subsection>  </library> <p/> <param name="expr"><code>var : Iterator</code></param>  <remarks>  </remarks> <p/> <library name="y_remote">  <section>  Description  </section>  Wrapper for "__CallRemoteFunction".  Enforces some features like no returns  and arrays being followed by their length.  <section>  Version  </section>  1.0  <section>  Macros  </section><ul>  <symbol name="remotefunc">Define a function to be called remotely (use like "stock").</symbol>  <symbol name="broadcastfunc">Call the function, but in all scripts.</symbol>  <symbol name="localfunc">Call the function by name, not address, in the current script.</symbol>  </ul><section>Compile options</section><ul>  <symbol name="YSI_NO_MASTER">Disable all knowledge of other scripts.</symbol>  </ul>  </library> <p/> <library name="y_playerarray">  <section>  Description  </section>  This code provides arrays of players who can do things.  This is for support  of the text system which can take arrays of player ids, bit arrays or just a  single ID.  <section>  Version  </section>  1.0  </library> <p/> <library name="y_punycode">  <section>  Description  </section>  Functions for converting unicode strings to and from punycode, to be  represented in just ASCII characters.  Based on several public  implementations and the RFC, adapted for PAWN.  For more information see:  <a href="https://en.wikipedia.org/wiki/Punycode" />  Also includes a function that hooks the "HTTP" function to allow for  internationalised domain names with that function.  <section>  Version  </section>  0.1  <section>  Functions  </section>  <subsection>  Stock  </subsection><ul>  <symbol name="Puny_Encode">Convert a Unicode string to Punycode.</symbol>  <symbol name="Puny_Decode">Convert a Punycode string to Unicode.</symbol>  <symbol name="Puny_HTTP">Wrapper for "HTTP" to encode domain names.</symbol>  </ul>  </library> <p/> <param name="index">The HTTP reference index.</param>  <param name="type">How the request should be sent.</param>  <param name="url">The (internationalised) URL address.</param>  <param name="data">The GET/POST data.</param>  <param name="callback">Which function to return the data to.</param>  <remarks>  Hooks the "HTTP" function.  </remarks> <p/> <param name="error">Which error to show.</param>  <param name="playerid">Player who typed the command.</param>  <param name="cmdtext">What they typed.</param>  <remarks>  Call OnPlayerCommandReceived once the system knows how the player can use  this command (if they can).  The order of the parameters is such that the  error comes first.  This is because it is compile-time concatenated to make  the error enum value, and putting that parameter first means that we don't  need to ommit the space after any comma.  </remarks> <p/> <param name="command">Command to get for.</param>  <returns>  Is this command ID valid?  </returns>  <remarks>  Internal direct-access check.  </remarks> <p/> <param name="idx">Command to test.</param>  <remarks>  Checks to see if a character is a possible prefix character.  May use an  unsigned comparison.  </remarks> <p/> <param name="c">Command to get.</param>  <returns>  The prefix for this command ('/' by default).  </returns> <p/> <param name="prefix">Possible prefix character.</param>  <returns>  Is this a valid character for a prefix?  </returns>  <remarks>  This is the ONLY place the list of valid prefixes is defined!  They are  symbols, not an alphanumerics, and under 128.  </remarks> <p/> <param name="prefix">Possible prefix character.</param>  <returns>  Is this a prefix used for any command?  </returns> <p/> <param name="prefix">Prefix to maybe remove.</param>  <remarks>  If one command uses a prefix, then STOPS using said prefix, the global list  of valid prefixes will need to be updated.  </remarks> <p/> <param name="c">Command to set.</param>  <param name="prefix">First character of the command.</param>  <remarks>  Change what command to type "/x" vs "#x" for example.  </remarks> <p/> <param name="c">Named command to set.</param>  <param name="prefix">First character of the command.</param>  <remarks>  Change what command to type "/x" vs "#x" for example.  </remarks> <p/> <library name="y_timers">  <section>  Description  </section>  Sets up repeating timers without requiring any SetTimers and arranges them  so that they will be very unlikely to meet (at least for a long time) using  scheduling algorithms to get timers with the same period to be offset.  Also  fixes arrays and strings in timers so they can be passed properly.  <section>  Version  </section>  2.0  </library> <p/> <library  name="sscanf"  summary="Extracts structured information from strings."  license="Copyright (c) 2022 Alex &quot;Y_Less&quot; Cole.  Licensed under MPL 1.1"  >  <summary pawndoc="true">  This library uses the enhanced <em>pawndoc.xsl</em> from  <a href="https://github.com/pawn-lang/pawndoc">pawn-lang/pawndoc</a>.  This XSL has features such as library and markdown support, and will not  render this message when used.  </summary>  <remarks>  This is the <em>sscanf</em> plugin, which provides the <c>sscanf</c>  function to extract basic structured data from strings.  This is slightly  different to regular expressions, but both have their place.  A regular  expression gives you total control over the exact structure of data down  to the character level; however, extracting structured data like numbers  using it is tricky.  Conversely this gives slightly higher-level  <em>specifiers</em> which can easily extract data types, at the expense  of fine-grained control.  To convert a string in to two numbers would  look like:  <code>  new num1, num2;                                                          <br />  sscanf("45 100", "ii", num1, num2);  </code>  <c>ii</c> is the specifier string, which here means "integer integer";  stating that the input string should be two whole numbers in a row (which  is - <c>"45 100"</c>).  <c>num1</c> and <c>num2</c> are the destination  variables to store the found numbers in (after conversion from strings).  You can check if the conversion failed by looking for a non-naught return  value:  <code>  new num1, num2;                                                          <br />  if (sscanf("hello 100", "ii", num1, num2))                               <br />  {                                                                        <br /><indent />  printf("The input was not two numbers.");                            <br />  }  </code>  This will fail because <c>"hello"</c> is not a whole number (or indeed  any type of number at all).  For more information on using the function  refer to the tutorials or the reference documentation in  <a href="https://github.com/Y-Less/sscanf/blob/master/README.md">the  attached readme</a>.  </remarks>  </library> <p/> <p/>
	</general>

	<members>

		<!-- enumerations -->
		<member name="T:AMX_FUNCSTUBNT" value="2">
			<tagname value="AMX_FUNCSTUBNT"/>
			<member name="C:AMX_FUNCSTUBNT_ADDRESS" value="0">
			</member>
			<member name="C:AMX_FUNCSTUBNT_NAMEOFS" value="1">
			</member>
			<referrer name="GetPublicAddressFromIndex"/>
			<referrer name="GetPublicNameFromIndex"/>
			<referrer name="GetNativeAddressFromIndex"/>
			<referrer name="GetNativeNameFromIndex"/>
			<referrer name="GetPubVarAddressFromIndex"/>
			<referrer name="GetPubVarNameFromIndex"/>
			<referrer name="GetTagIDFromIndex"/>
			<referrer name="GetTagNameFromIndex"/>
			<referrer name="IsTagIndexStrong"/>
			<referrer name="IsTagIndexWeak"/>
		</member>
		<member name="T:AMX_HDR" value="17">
			<tagname value="AMX_HDR"/>
			<member name="C:AMX_HDR_SIZE" value="0">
			</member>
			<member name="C:AMX_HDR_MAGIC" value="1">
			</member>
			<member name="C:AMX_HDR_FILE_VERSION" value="2">
			</member>
			<member name="C:AMX_HDR_AMX_VERSION" value="3">
			</member>
			<member name="C:AMX_HDR_FLAGS" value="4">
			</member>
			<member name="C:AMX_HDR_DEFSIZE" value="5">
			</member>
			<member name="C:AMX_HDR_COD" value="6">
			</member>
			<member name="C:AMX_HDR_DAT" value="7">
			</member>
			<member name="C:AMX_HDR_HEA" value="8">
			</member>
			<member name="C:AMX_HDR_STP" value="9">
			</member>
			<member name="C:AMX_HDR_CIP" value="10">
			</member>
			<member name="C:AMX_HDR_PUBLICS" value="11">
			</member>
			<member name="C:AMX_HDR_NATIVES" value="12">
			</member>
			<member name="C:AMX_HDR_LIBRARIES" value="13">
			</member>
			<member name="C:AMX_HDR_PUBVARS" value="14">
			</member>
			<member name="C:AMX_HDR_TAGS" value="15">
			</member>
			<member name="C:AMX_HDR_NAMETABLE" value="16">
			</member>
			<referrer name="AsmGetJumpAddressFromOffset"/>
			<referrer name="AsmGetCode"/>
			<referrer name="AsmEmitCallAbs"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="DisasmInit"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DisasmWriteData"/>
			<referrer name="ProfilerInit"/>
		</member>
		<member name="T:AsmContext" value="21">
			<tagname value="AsmContext"/>
			<member name="C:AsmContext_buffer" value="0">
			</member>
			<member name="C:AsmContext_buffer_size" value="1">
			</member>
			<member name="C:AsmContext_buffer_offset" value="2">
			</member>
			<member name="C:AsmContext_error" value="3">
			</member>
			<member name="C:AsmContext_error_handler" value="4">
			</member>
			<member name="C:AsmContext_label_names" value="5">
				<size value="8"/>
			</member>
			<member name="C:AsmContext_labels" value="13">
				<size value="8"/>
			</member>
			<referrer name="AMX_Read"/>
			<referrer name="bernstein"/>
			<referrer name="rawMemset"/>
			<referrer name="CallStoredFunction"/>
			<referrer name="Callback_Call"/>
			<referrer name="Callback_Array"/>
			<referrer name="I@E"/>
			<referrer name="I@L"/>
			<referrer name="StoredF_WritePublicCode"/>
			<referrer name="Remote_WriteStubCode"/>
			<referrer name="Remote_WriteSpecAndFunc"/>
			<referrer name="Hooks_WriteFunction"/>
		</member>
		<member name="T:CodeScanMatcher" value="171">
			<tagname value="CodeScanMatcher"/>
			<member name="C:CodeScanMatcher_func" value="0">
			</member>
			<member name="C:CodeScanMatcher_user_data" value="1">
			</member>
			<member name="C:CodeScanMatcher_code" value="2">
				<size value="128"/>
			</member>
			<member name="C:CodeScanMatcher_len" value="130">
			</member>
			<member name="C:CodeScanMatcher_offset" value="131">
				<size value="2"/>
			</member>
			<member name="C:CodeScanMatcher_start" value="133">
				<size value="2"/>
			</member>
			<member name="C:CodeScanMatcher_holeidx" value="135">
				<size value="2"/>
			</member>
			<member name="C:CodeScanMatcher_holes" value="137">
				<size value="32"/>
			</member>
			<member name="C:CodeScanMatcher_next" value="169">
			</member>
			<member name="C:CodeScanMatcher_flags" value="170">
			</member>
			<referrer name="CodeScanDeref"/>
			<referrer name="YVA2_Initalise"/>
		</member>
		<member name="T:CodeScanner" value="163">
			<tagname value="CodeScanner"/>
			<member name="C:CodeScanMatch_func" value="0">
			</member>
			<member name="C:CodeScanMatch_size" value="1">
			</member>
			<member name="C:CodeScanMatch_type" value="2">
			</member>
			<member name="C:CodeScanMatch_heap" value="3">
			</member>
			<member name="C:CodeScanMatch_stack" value="4">
			</member>
			<member name="C:CodeScanMatch_params" value="5">
			</member>
			<member name="C:CodeScanMatch_cip" value="6">
			</member>
			<member name="C:CodeScanMatch_holes" value="7">
				<size value="16"/>
			</member>
			<member name="C:CodeScanMatch_name" value="23">
				<size value="8"/>
			</member>
			<member name="C:CodeScanner_first" value="31">
			</member>
			<member name="C:CodeScanner_minn" value="32">
			</member>
			<member name="C:CodeScanner_jump_switch" value="33">
				<size value="32"/>
			</member>
			<member name="C:CodeScanner_jump_target" value="65">
				<size value="32"/>
			</member>
			<member name="C:CodeScanner_jump_stack" value="97">
				<size value="32"/>
			</member>
			<member name="C:CodeScanner_jump_heap" value="129">
				<size value="32"/>
			</member>
			<member name="C:CodeScanner_state" value="161">
			</member>
			<member name="C:CodeScanner_param" value="162">
			</member>
			<referrer name="YVA2_Initalise"/>
		</member>
		<member name="T:DisasmContext" value="22">
			<tagname value="DisasmContext"/>
			<member name="C:DisasmContext_start_ip" value="0">
			</member>
			<member name="C:DisasmContext_end_ip" value="1">
			</member>
			<member name="C:DisasmContext_nip" value="2">
			</member>
			<member name="C:DisasmContext_cip" value="3">
			</member>
			<member name="C:DisasmContext_opcode" value="4">
				<tagname value="Opcode"/>
			</member>
			<member name="C:DisasmContext_insn" value="5">
				<size value="17"/>
			</member>
			<referrer name="DisasmWriteCode"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanRun"/>
			<referrer name="AMX_Read"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<referrer name="I@E"/>
			<referrer name="I@F"/>
			<referrer name="I@L"/>
			<referrer name="Hooks_GetStubEntry"/>
		</member>
		<member name="T:E_CALLBACK_DATA" value="5">
			<tagname value="E_CALLBACK_DATA"/>
			<member name="C:E_CALLBACK_DATA_ALLOC" value="0">
				<tagname value="ResolvedAlloc"/>
			</member>
			<member name="C:E_CALLBACK_DATA_POINTER" value="1">
				<tagname value="Function"/>
			</member>
			<member name="C:E_CALLBACK_DATA_OFFSET" value="2">
			</member>
			<member name="C:E_CALLBACK_DATA_FORMAT" value="3">
				<size value="2"/>
			</member>
			<referrer name="Callback_Get"/>
			<referrer name="INI_ParseFile"/>
		</member>
		<member name="T:E_COMMAND" value="45">
			<tagname value="E_COMMAND"/>
			<member name="C:E_COMMAND_NAME" value="0">
				<size value="8"/>
			</member>
			<member name="C:E_COMMAND_HASH_MAP" value="8">
				<size value="3"/>
			</member>
			<member name="C:E_COMMAND_USERS" value="11">
				<tagname value="Bit"/>
				<size value="33"/>
			</member>
			<member name="C:E_COMMAND_POINTER" value="44">
			</member>
			<referrer name="YSI_g_sCommands_Dist"/>
			<referrer name="YSI_g_sCommands@Dist"/>
		</member>
		<member name="T:E_HOOK_NAME_REPLACEMENT_DATA" value="34">
			<tagname value="E_HOOK_NAME_REPLACEMENT_DATA"/>
			<member name="C:E_HOOK_NAME_REPLACEMENT_SHORT" value="0">
				<size value="16"/>
			</member>
			<member name="C:E_HOOK_NAME_REPLACEMENT_LONG" value="16">
				<size value="16"/>
			</member>
			<member name="C:E_HOOK_NAME_REPLACEMENT_MIN" value="32">
			</member>
			<member name="C:E_HOOK_NAME_REPLACEMENT_MAX" value="33">
			</member>
		</member>
		<member name="T:E_INI_KV_ENTRY" value="163">
			<tagname value="E_INI_KV_ENTRY"/>
			<member name="C:E_INI_KV_ENTRY_NAME" value="0">
				<size value="32"/>
			</member>
			<member name="C:E_INI_KV_ENTRY_TEXT" value="32">
				<size value="130"/>
			</member>
			<member name="C:E_INI_KV_ENTRY_NEXT" value="162">
			</member>
		</member>
		<member name="T:E_INI_TAGS" value="10">
			<tagname value="E_INI_TAGS"/>
			<member name="C:E_INI_TAGS_NAME" value="0">
				<size value="8"/>
			</member>
			<member name="C:E_INI_TAGS_START" value="8">
			</member>
			<member name="C:E_INI_TAGS_NEXT" value="9">
			</member>
		</member>
		<member name="T:E_ITER_YIELD" value="11">
			<tagname value="E_ITER_YIELD"/>
			<member name="C:E_ITER_YIELD_STACK_START" value="0">
			</member>
			<member name="C:E_ITER_YIELD_STACK_END" value="1">
			</member>
			<member name="C:E_ITER_YIELD_STACK_SIZE" value="2">
			</member>
			<member name="C:E_ITER_YIELD_HEAP_START" value="3">
			</member>
			<member name="C:E_ITER_YIELD_HEAP_END" value="4">
			</member>
			<member name="C:E_ITER_YIELD_HEAP_SIZE" value="5">
			</member>
			<member name="C:E_ITER_YIELD_FIRST" value="6">
			</member>
			<member name="C:E_ITER_YIELD_FRM" value="7">
			</member>
			<member name="C:E_ITER_YIELD_CIP" value="8">
			</member>
			<member name="C:E_ITER_YIELD_FRAME" value="9">
			</member>
			<member name="C:E_ITER_YIELD_RETURN" value="10">
			</member>
		</member>
		<member name="T:E_PRE_HOOK" value="17">
			<tagname value="E_PRE_HOOK"/>
			<member name="C:E_PRE_HOOK_NAME" value="0">
				<size value="16"/>
			</member>
			<member name="C:E_PRE_HOOK_VALUE" value="16">
			</member>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_DoAllHooks"/>
		</member>
		<member name="T:IG_ZONE_MAIN" value="36">
			<tagname value="IG_ZONE_MAIN"/>
			<member name="C:IG_ZONE_IMENA" value="0">
				<size value="30"/>
			</member>
			<member name="C:SAZONE_AREA" value="30">
				<tagname value="Float"/>
				<size value="6"/>
			</member>
		</member>
		<member name="T:OpcodeInsnInfo" value="17">
			<tagname value="OpcodeInsnInfo"/>
			<member name="C:OpcodeInsnInfo_name" value="0">
				<size value="15"/>
			</member>
			<member name="C:OpcodeInsnInfo_num_opers" value="15">
			</member>
			<member name="C:OpcodeInsnInfo_needs_reloc" value="16">
				<tagname value="bool"/>
			</member>
		</member>
		<member name="T:ProfCallInfo" value="2">
			<tagname value="ProfCallInfo"/>
			<member name="C:pci_index" value="0">
			</member>
			<member name="C:pci_start_time" value="1">
			</member>
			<referrer name="enter_public"/>
		</member>
		<member name="T:ProfEntryCode" value="8">
			<tagname value="ProfEntryCode"/>
			<member name="C:pec_push_c0" value="0">
				<tagname value="Opcode"/>
			</member>
			<member name="C:pec_push_address" value="1">
			</member>
			<member name="C:pec_push_c1" value="2">
				<tagname value="Opcode"/>
			</member>
			<member name="C:pec_push_index" value="3">
			</member>
			<member name="C:pec_push_c2" value="4">
				<tagname value="Opcode"/>
			</member>
			<member name="C:pec_push_8" value="5">
			</member>
			<member name="C:pec_call" value="6">
				<tagname value="Opcode"/>
			</member>
			<member name="C:pec_call_enter" value="7">
			</member>
			<referrer name="new_pec"/>
		</member>
		<member name="T:ProfPublicInfo" value="3">
			<tagname value="ProfPublicInfo"/>
			<member name="C:ppi_child_time" value="0">
			</member>
			<member name="C:ppi_total_time" value="1">
			</member>
			<member name="C:ppi_num_calls" value="2">
			</member>
		</member>
		<member name="T:e_COMMAND_ERRORS" value="11">
			<tagname value="e_COMMAND_ERRORS"/>
			<member name="C:COMMAND_ZERO_RET" value="0">
			</member>
			<member name="C:COMMAND_OK" value="1">
			</member>
			<member name="C:COMMAND_UNDEFINED" value="2">
			</member>
			<member name="C:COMMAND_DENIED" value="3">
			</member>
			<member name="C:COMMAND_HIDDEN" value="4">
			</member>
			<member name="C:COMMAND_NO_PLAYER" value="6">
			</member>
			<member name="C:COMMAND_DISABLED" value="7">
			</member>
			<member name="C:COMMAND_BAD_PREFIX" value="8">
			</member>
			<member name="C:COMMAND_INVALID_INPUT" value="10">
			</member>
			<referrer name="YSI_g_sErrorMessages_Dist"/>
			<referrer name="YSI_g_sErrorMessages@Dist"/>
		</member>
		<member name="T:pInfo" value="7">
			<tagname value="pInfo"/>
			<member name="C:player_password" value="0">
			</member>
			<member name="C:player_money" value="1">
			</member>
			<member name="C:player_staff" value="2">
			</member>
			<member name="C:player_level" value="3">
			</member>
			<member name="C:player_skin" value="4">
			</member>
			<member name="C:player_accountbank" value="5">
			</member>
			<member name="C:player_bankmoney" value="6">
			</member>
		</member>

		<!-- constants -->
		<member name="C:AMX_HDR_OFFSET_AMX_VERSION" value="7">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_CIP" value="28">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_COD" value="12">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_DAT" value="16">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_DEFSIZE" value="10">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_FILE_VERSION" value="6">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_FLAGS" value="8">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_HEA" value="20">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_LIBRARIES" value="40">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_MAGIC" value="4">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_NAMETABLE" value="52">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_NATIVES" value="36">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_PUBLICS" value="32">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_PUBVARS" value="44">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_SIZE" value="0">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_STP" value="24">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_TAGS" value="48">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:NUM_OPCODES" value="138">
			<referrer name="IsOpcodeValid"/>
			<referrer name="InitOpcodeTable"/>
			<referrer name="UnrelocateOpcode"/>
			<referrer name="GetOpcodeInstructionInformation"/>
			<referrer name="GetOpcodeInstructionName"/>
			<referrer name="GetOpcodeInstructionParameters"/>
			<referrer name="GetOpcodeInstructionRelocatable"/>
			<referrer name="AsmEmitOpcode"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="DisasmNext"/>
		</member>
		<member name="C:SSCANF_VERSION" value="135944">
			<library>sscanf</library>  <remarks>  The sscanf version in BCD as a proper constant.  Example:  <code>  2.10.3  <br />  => 02 10 03 <br />  => 0x021003  </code>  </remarks> 
		</member>
		<member name="C:__Pawn" value="778">
		</member>
		<member name="C:__PawnBuild" value="4">
		</member>
		<member name="C:__line" value="356">
			<referrer name="@_yCdo"/>
			<referrer name="@_yCb"/>
			<referrer name="@_yCme"/>
			<referrer name="@_yCmakestaff"/>
			<referrer name="@_yCxgoto"/>
			<referrer name="@_yCdajnovac"/>
		</member>
		<member name="C:cellbits" value="32">
			<referrer name="CodeScanCheckJumpTarget"/>
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="YVA2_CodeGenDeepCleanup"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<referrer name="Bit_Set"/>
			<referrer name="Iter_Func@Bits"/>
			<referrer name="Iter_Func@Blanks"/>
			<referrer name="AMX_OnScriptInit"/>
			<referrer name="Malloc_TrySetup"/>
			<referrer name="PA_Set"/>
			<referrer name="Iter_Func@PA"/>
			<referrer name="Group_SetCommand"/>
			<referrer name="Group_GetCommand"/>
			<referrer name="Group_SetCommandDefault"/>
			<referrer name="Group_ExclusiveCommand"/>
			<referrer name="Group_Handoff"/>
			<referrer name="_yGICommand"/>
			<referrer name="_yGACommand"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="Command_GetPlayerDisabled"/>
			<referrer name="Command_GetPlayer"/>
			<referrer name="Command_GetPlayerCommandCount"/>
			<referrer name="Command_GetNext"/>
			<referrer name="Iter_Func@PlayerCommand"/>
			<referrer name="_Command_GetDisplay"/>
		</member>
		<member name="C:cellmax" value="2147483647">
			<referrer name="operator!(Float:)"/>
			<referrer name="CodeScanGetFunctionAsm"/>
			<referrer name="CodeScanGetMatchAsm"/>
			<referrer name="exit_public"/>
			<referrer name="Range"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="Malloc_SetS"/>
			<referrer name="Inline_OnAsmError"/>
			<referrer name="I@L"/>
			<referrer name="INI_DeleteTag"/>
			<referrer name="INI_AddToBuffer"/>
			<referrer name="INI_WriteBuffer"/>
			<referrer name="Puny_Decode"/>
			<referrer name="Puny_Encode"/>
			<referrer name="Puny_EncodeHash"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_Add"/>
		</member>
		<member name="C:cellmin" value="-2147483648">
			<referrer name="operator-(Float:)"/>
			<referrer name="CallN"/>
			<referrer name="SysreqC"/>
			<referrer name="SysreqD"/>
			<referrer name="SysreqCN"/>
			<referrer name="SysreqDN"/>
			<referrer name="CallNative"/>
			<referrer name="CallNativeByAddress"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanInit"/>
			<referrer name="exit_public"/>
			<referrer name="Random"/>
			<referrer name="endofline"/>
			<referrer name="ishex"/>
			<referrer name="isnumeric"/>
			<referrer name="SkipWhitespace"/>
			<referrer name="Trim"/>
			<referrer name="Range"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<referrer name="INI_WriteInt"/>
			<referrer name="Iter_Random_Internal"/>
			<referrer name="Iter_RandomFree_InternalC"/>
			<referrer name="Iter_Alloc_InternalC"/>
			<referrer name="Iter_Alloc_InternalD"/>
			<referrer name="Iter_Free_Internal"/>
			<referrer name="Iter_FreeMulti_Internal"/>
			<referrer name="Iter_Add_InternalC"/>
			<referrer name="Iter_Add_InternalD"/>
			<referrer name="Iter_Index_Internal"/>
			<referrer name="Iter_SafeRemove_InternalC"/>
			<referrer name="Iter_SafeRemove_InternalD"/>
			<referrer name="Iter_GetMulti_Internal"/>
			<referrer name="Iter_Func@Range"/>
			<referrer name="Iter_Func@Random"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="Command_GetPlayer"/>
			<referrer name="Command_SetPlayer"/>
			<referrer name="Command_Touch"/>
			<referrer name="Command_IsValid"/>
			<referrer name="Command_GetName"/>
			<referrer name="@yH_OnMasterSystemClose@005"/>
			<referrer name="_Command_GetDisplay"/>
			<referrer name="SSCANF_GetSimilarString"/>
			<referrer name="SSCANF_GetSimilarValue"/>
			<referrer name="SSCANF_GetClosestString"/>
			<referrer name="SSCANF_GetClosestValue"/>
		</member>
		<member name="C:d_balancenovac" value="7">
			<referrer name="@yH_OnDialogResponse@029"/>
		</member>
		<member name="C:d_login" value="0">
			<referrer name="SSCANF_OnPlayerConnect"/>
			<referrer name="OnDialogResponse"/>
		</member>
		<member name="C:d_ostavljanjenovac" value="3">
			<referrer name="@yH_OnDialogResponse@029"/>
		</member>
		<member name="C:d_podizanjenovac" value="4">
			<referrer name="@yH_OnDialogResponse@029"/>
		</member>
		<member name="C:d_pravljenjeadmina" value="2">
			<referrer name="@_yCmakestaff"/>
		</member>
		<member name="C:d_register" value="1">
			<referrer name="SSCANF_OnPlayerConnect"/>
			<referrer name="OnDialogResponse"/>
		</member>
		<member name="C:d_spremnoslanje" value="6">
			<referrer name="@yH_OnDialogResponse@029"/>
		</member>
		<member name="C:d_transfernovac" value="5">
			<referrer name="@yH_OnDialogResponse@029"/>
		</member>
		<member name="C:debug" value="2">
			<referrer name="RelocateOpcodeNow"/>
		</member>
		<member name="C:dialog_banka" value="8">
			<referrer name="@_yCbanka"/>
			<referrer name="@yH_OnDialogResponse@029"/>
		</member>
		<member name="C:false" value="0">
			<tagname value="bool"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicNameFromIndex"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeNameFromIndex"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarNameFromIndex"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagNameFromIndex"/>
			<referrer name="GetOpcodeInstructionRelocatable"/>
			<referrer name="Push"/>
			<referrer name="Pop"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="DisasmWrite"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanCheckJumpTarget"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="CodeScanGetFuncName"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="ProfilerWriteData"/>
			<referrer name="YVers_Callback"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="Utils_PreSort"/>
			<referrer name="Malloc_NewS"/>
			<referrer name="Callback_Get"/>
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="Hooks_IsolateName"/>
			<referrer name="INI_ParseFile"/>
			<referrer name="INI_SetupCallbackName"/>
			<referrer name="INI_DoParentTag"/>
			<referrer name="INI_Flush"/>
			<referrer name="INI_WriteBuffer"/>
			<referrer name="_Master_Get"/>
			<referrer name="Master_GetCurrentMaster"/>
			<referrer name="HashMap_Add"/>
			<referrer name="HashMap_RemoveKeyWithHash"/>
			<referrer name="HashMap_RemoveValue"/>
			<referrer name="Iter_YieldEnter"/>
			<referrer name="Iter_YieldLoop"/>
			<referrer name="@yH_OnPlayerDisconnect@004"/>
			<referrer name="Iter_DestroyActor"/>
			<referrer name="Iter_DestroyVehicle"/>
			<referrer name="Puny_EncodeHash"/>
			<referrer name="Command_InitialiseFromGroups"/>
			<referrer name="Group_FullPlayerUpdate"/>
			<referrer name="_Group_IncludeAll_1"/>
			<referrer name="Command_GetPlayer"/>
			<referrer name="Master_GetCurrentMaster"/>
			<referrer name="@yH_OnPlayerKeyStateChange@016"/>
			<referrer name="@_yCstaffon"/>
			<referrer name="@yH_OnPlayerSpawn@024"/>
			<referrer name="EnterijerBrojac"/>
		</member>
		<member name="C:true" value="1">
			<tagname value="bool"/>
			<referrer name="ResetStaticAmxHeader"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagNameFromIndex"/>
			<referrer name="GetTagNameFromID"/>
			<referrer name="InitOpcodeTable"/>
			<referrer name="Push"/>
			<referrer name="Pop"/>
			<referrer name="AsmEmitJrelLabelStringize"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="DisasmWrite"/>
			<referrer name="CodeScanCheckJumpTarget"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="CodeScanGetFuncName"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanRun"/>
			<referrer name="ProfilerWriteData"/>
			<referrer name="OnFilterScriptInit"/>
			<referrer name="boolstr"/>
			<referrer name="Utils_PreSort"/>
			<referrer name="Callback_Get"/>
			<referrer name="Hooks_GetPreHooks"/>
			<referrer name="Hooks_GetFunctionWritePoint"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<referrer name="INI_ParseFile"/>
			<referrer name="INI_Load"/>
			<referrer name="INI_DoParentTag"/>
			<referrer name="INI_GetTag"/>
			<referrer name="INI_AddToBuffer"/>
			<referrer name="INI_Flush"/>
			<referrer name="INI_WriteBuffer"/>
			<referrer name="_Master_Get"/>
			<referrer name="HashMap_Add"/>
			<referrer name="HashMap_RemoveKeyWithHash"/>
			<referrer name="Iter_YieldEnter"/>
			<referrer name="Iter_YieldLoop"/>
			<referrer name="Iter_CreateActor"/>
			<referrer name="Iter_CreateVehicle"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<referrer name="Puny_EncodeHash"/>
			<referrer name="Group_FullPlayerUpdate"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_Add"/>
			<referrer name="_Timer_D"/>
			<referrer name="SacuvajKorisnike"/>
			<referrer name="LoadUser_data"/>
			<referrer name="@_yCstaffon"/>
			<referrer name="freezethaw"/>
			<referrer name="ZonaIgraca"/>
			<referrer name="@_yCotvoriracun"/>
			<referrer name="SSCANF_OnPlayerConnect"/>
			<referrer name="OnDialogResponse"/>
		</member>

		<!-- variables -->
		<member name="F:@Ix">
			<attribute name="public"/>
		</member>
		<member name="F:AMX_BASE_ADDRESS">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetEntry"/>
			<referrer name="AMX_GetEntryPrefix"/>
			<referrer name="AMX_GetEntrySuffix"/>
			<referrer name="AMX_GetName"/>
			<referrer name="AMX_GetNamePrefix"/>
			<referrer name="AMX_GetNameSuffix"/>
			<referrer name="AMX_GetStringFromEntry"/>
			<referrer name="I@E"/>
			<referrer name="Inline_OnAsmError"/>
			<referrer name="I@L"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_InvalidateName"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_ComparePublics"/>
			<referrer name="Hooks_SortPublics"/>
			<referrer name="@yH_OnScriptInit@005"/>
			<referrer name="@yH_OnScriptInit@006"/>
		</member>
		<member name="F:AMX_HEADER_AMX_VERSION">
			<referrer name="Debug_OnScriptInit"/>
		</member>
		<member name="F:AMX_HEADER_CIP">
			<referrer name="Debug_OnScriptInit"/>
		</member>
		<member name="F:AMX_HEADER_COD">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetGlobal"/>
			<referrer name="AMX_TraceCode"/>
			<referrer name="AMX_Read"/>
			<referrer name="bernstein"/>
			<referrer name="rawMemset"/>
			<referrer name="AMX_OnScriptInit"/>
			<referrer name="CGen_GetAddr"/>
			<referrer name="GetRemoteFunction"/>
			<referrer name="CallStoredFunction"/>
			<referrer name="Callback_Call"/>
			<referrer name="Callback_Array"/>
			<referrer name="I@E"/>
			<referrer name="Inline_OnAsmError"/>
			<referrer name="I@L"/>
			<referrer name="StoredF_IsHooked"/>
			<referrer name="StoredF_WritePublicCode"/>
			<referrer name="Remote_WriteStubCode"/>
			<referrer name="Remote_WriteSpecAndFunc"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GenerateCode"/>
			<referrer name="Hooks_WriteFunction"/>
		</member>
		<member name="F:AMX_HEADER_DAT">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_TraceCode"/>
			<referrer name="AMX_TraceMemory"/>
			<referrer name="AMX_OnScriptInit"/>
		</member>
		<member name="F:AMX_HEADER_DEFSIZE">
			<referrer name="Debug_OnScriptInit"/>
		</member>
		<member name="F:AMX_HEADER_FILE_VERSION">
			<referrer name="Debug_OnScriptInit"/>
		</member>
		<member name="F:AMX_HEADER_FLAGS">
			<referrer name="Debug_OnScriptInit"/>
		</member>
		<member name="F:AMX_HEADER_HEA">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_TraceMemory"/>
			<referrer name="Malloc_TrySetup"/>
		</member>
		<member name="F:AMX_HEADER_LIBRARIES">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetBaseCount"/>
		</member>
		<member name="F:AMX_HEADER_MAGIC">
			<referrer name="Debug_OnScriptInit"/>
		</member>
		<member name="F:AMX_HEADER_NAMETABLE">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetBaseCount"/>
		</member>
		<member name="F:AMX_HEADER_NATIVES">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetBaseCount"/>
			<referrer name="AMX_GetEntryFromNativeIndex"/>
			<referrer name="AMX_GetNativeIndexFromEntry"/>
			<referrer name="Hooks_SortPublics"/>
		</member>
		<member name="F:AMX_HEADER_PUBLICS">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetBaseCount"/>
			<referrer name="AMX_GetEntryFromPublicIndex"/>
			<referrer name="AMX_GetPublicIndexFromEntry"/>
			<referrer name="CGen_GetAddr"/>
			<referrer name="StoredF_WritePublicCode"/>
			<referrer name="Hooks_ComparePublics"/>
			<referrer name="Hooks_SortPublics"/>
			<referrer name="@yH_OnScriptInit@005"/>
			<referrer name="@yH_OnMasterSystemClose@005"/>
		</member>
		<member name="F:AMX_HEADER_PUBVARS">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetBaseCount"/>
		</member>
		<member name="F:AMX_HEADER_SIZE">
			<referrer name="Debug_OnScriptInit"/>
		</member>
		<member name="F:AMX_HEADER_STP">
			<referrer name="Debug_OnScriptInit"/>
		</member>
		<member name="F:AMX_HEADER_TAGS">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetBaseCount"/>
		</member>
		<member name="F:AMX_REAL_ADDRESS">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="I@E"/>
			<referrer name="Inline_OnAsmError"/>
			<referrer name="I@L"/>
			<referrer name="Hooks_WriteFunction"/>
		</member>
		<member name="F:AMX_REAL_DATA">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetGlobalAddress"/>
			<referrer name="Callback_Array"/>
			<referrer name="StoredF_WritePublicCode"/>
			<referrer name="Remote_WriteStubCode"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GenerateCode"/>
		</member>
		<member name="F:ASM_ARGUMENTS_OFFSET">
			<referrer name="AsmGetArgOffset"/>
		</member>
		<member name="F:ASM_CALLER_FRAME_OFFSET">
		</member>
		<member name="F:ASM_CTRL_CIP">
		</member>
		<member name="F:ASM_CTRL_COD">
		</member>
		<member name="F:ASM_CTRL_DAT">
		</member>
		<member name="F:ASM_CTRL_FRM">
		</member>
		<member name="F:ASM_CTRL_HEA">
		</member>
		<member name="F:ASM_CTRL_JIT">
		</member>
		<member name="F:ASM_CTRL_JMP">
		</member>
		<member name="F:ASM_CTRL_STK">
		</member>
		<member name="F:ASM_CTRL_STP">
		</member>
		<member name="F:ASM_LOCALS_OFFSET">
		</member>
		<member name="F:ASM_RETURN_ADDR_OFFSET">
		</member>
		<member name="F:BunnyHop">
			<referrer name="@yH_OnPlayerConnect@016"/>
			<referrer name="@yH_OnPlayerKeyStateChange@016"/>
			<referrer name="Dzampo"/>
			<referrer name="NijeDzampo"/>
		</member>
		<member name="F:CELLMIN_ON_MATCHES">
			<library>sscanf</library>  <remarks>  The <c>CELLMIN_ON_MATCHES</c> option as a constant string so you can get  compile-time spell checking on the name.  Whatever the value of  <c>MATCH_NAME_PARTIAL</c>, the first found player will always be returned,  so if you do a search for <c>_</c> on an RP server, you could get almost  anyone.  To detect this case, if more than one player will match the  specified string then <em>sscanf</em> will return an ID of <c>cellmin</c>  instead.  This can be combined with <c>U</c> for a lot more power:  <code>  sscanf(params, "?&lt;CELLMIN_ON_MATCHES=1&gt;U(-1)", id);                <br />  if (id == -1)                                                            <br />  {                                                                        <br /><indent />  // No player was entered.                                            <br />  }                                                                        <br />  else if (id == cellmin)                                                  <br />  {                                                                        <br /><indent />  // Multiple matches found                                            <br />  }                                                                        <br />  else if (id == INVALID_PLAYER_ID)                                        <br />  {                                                                        <br /><indent />  // Entered player is not connected.                                  <br />  }                                                                        <br />  else                                                                     <br />  {                                                                        <br /><indent />  // Found just one player.                                            <br />  }  </code>  </remarks> 
		</member>
		<member name="F:F@o">
		</member>
		<member name="F:FALSE">
			<tagname value="bool"/>
		</member>
		<member name="F:I@">
			<referrer name="Iter_YieldReturn"/>
			<referrer name="Iter_ActorDo_"/>
			<referrer name="Iter_CreateActor"/>
			<referrer name="Iter_DestroyActor"/>
			<referrer name="Iter_VehicleDo_"/>
			<referrer name="Iter_CreateVehicle"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<referrer name="Iter_DestroyVehicle"/>
			<referrer name="Command_Add"/>
			<referrer name="_Timer_C"/>
		</member>
		<member name="F:IG_Zone">
			<referrer name="GetPlayer2DZone"/>
		</member>
		<member name="F:INI_NO_TAG">
			<referrer name="INI_AddToBuffer"/>
		</member>
		<member name="F:IgracKojimSaljes">
			<referrer name="@yH_OnDialogResponse@029"/>
			<referrer name="SSCANF_OnPlayerConnect"/>
		</member>
		<member name="F:Ingame_PTD">
			<tagname value="PlayerText"/>
			<referrer name="CreatePTextDraws"/>
			<referrer name="@yH_OnPlayerSpawn@019"/>
			<referrer name="GlobalTimer"/>
		</member>
		<member name="F:Iter_Single@Actor">
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="Iter_ActorDo"/>
		</member>
		<member name="F:Iter_Single@Bot">
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="@yH_OnPlayerConnect@004"/>
			<referrer name="Iter_OPDCInternal"/>
		</member>
		<member name="F:Iter_Single@Character">
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="@yH_OnPlayerConnect@004"/>
			<referrer name="Iter_OPDCInternal"/>
		</member>
		<member name="F:Iter_Single@LocalActor">
			<referrer name="Iter_CreateActor"/>
			<referrer name="Iter_DestroyActor"/>
		</member>
		<member name="F:Iter_Single@LocalVehicle">
			<referrer name="Iter_CreateVehicle"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<referrer name="Iter_DestroyVehicle"/>
		</member>
		<member name="F:Iter_Single@Player">
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="@yH_OnPlayerConnect@004"/>
			<referrer name="Iter_OPDCInternal"/>
		</member>
		<member name="F:Iter_Single@Vehicle">
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="Iter_VehicleDo"/>
		</member>
		<member name="F:Iterator@Actor">
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="Iter_ActorDo"/>
		</member>
		<member name="F:Iterator@Bot">
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="@yH_OnPlayerConnect@004"/>
			<referrer name="Iter_OPDCInternal"/>
		</member>
		<member name="F:Iterator@Character">
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="@yH_OnPlayerConnect@004"/>
			<referrer name="Iter_OPDCInternal"/>
		</member>
		<member name="F:Iterator@Fib">
			<tagname value="F@z"/>
		</member>
		<member name="F:Iterator@Filter">
			<tagname value="F@z"/>
		</member>
		<member name="F:Iterator@LocalActor">
			<referrer name="Iter_CreateActor"/>
			<referrer name="Iter_DestroyActor"/>
		</member>
		<member name="F:Iterator@LocalVehicle">
			<referrer name="Iter_CreateVehicle"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<referrer name="Iter_DestroyVehicle"/>
		</member>
		<member name="F:Iterator@NonNull">
			<tagname value="F@z"/>
		</member>
		<member name="F:Iterator@Null">
			<tagname value="F@z"/>
		</member>
		<member name="F:Iterator@Player">
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="@yH_OnPlayerConnect@004"/>
			<referrer name="Iter_OPDCInternal"/>
			<referrer name="Group_SetCommand"/>
			<referrer name="Group_SetCommandDefault"/>
			<referrer name="_Timer_D"/>
			<referrer name="Proxara"/>
			<referrer name="GlobalTimer"/>
			Create the internal iterators. 
		</member>
		<member name="F:Iterator@Powers">
			<tagname value="F@z"/>
		</member>
		<member name="F:Iterator@Random">
			<tagname value="F@z"/>
		</member>
		<member name="F:Iterator@Range">
			<tagname value="F@z"/>
		</member>
		<member name="F:Iterator@Until">
			<tagname value="F@z"/>
		</member>
		<member name="F:Iterator@Vehicle">
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="Iter_VehicleDo"/>
		</member>
		<member name="F:J@">
			<referrer name="Iter_ActorDo_"/>
			<referrer name="Iter_CreateActor"/>
			<referrer name="Iter_DestroyActor"/>
			<referrer name="Iter_VehicleDo_"/>
			<referrer name="Iter_CreateVehicle"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<referrer name="Iter_DestroyVehicle"/>
			<referrer name="_yGICommand"/>
			<referrer name="_yGACommand"/>
			<referrer name="_yGUCommand"/>
		</member>
		<member name="F:Koristi_JetPack">
			<referrer name="@yH_OnPlayerConnect@023"/>
			<referrer name="@yH_OnPlayerDeath@023"/>
			<referrer name="@_yCjetpack"/>
		</member>
		<member name="F:LabelStaffVehicle">
			<tagname value="Text3D"/>
			<referrer name="@_yCstaffvehicle"/>
		</member>
		<member name="F:MATCH_NAME_FIRST">
			<library>sscanf</library>  <remarks>  The <c>MATCH_NAME_FIRST</c> option as a constant string so you can get compile-  time spell checking on the name.  Specify whether <c>u</c> etc keep searching  for better matching player names after finding one:  <code>  SSCANF_Option(MATCH_NAME_FIRST, 0); // Enable scanning for the best name match not the first (default).  <br />  SSCANF_Option(MATCH_NAME_FIRST, 1); // Enable scanning for the first name match not the best (old behaviour).  </code>  </remarks> 
		</member>
		<member name="F:MATCH_NAME_PARTIAL">
			<library>sscanf</library>  <remarks>  The <c>MATCH_NAME_PARTIAL</c> option as a constant string so you can get  compile-time spell checking on the name.  Currently sscanf will search for  players by name, and will <em>always</em> search for player whose name  <em>starts</em> with the specified string.  If someone types <c>Y_Less</c>,  sscanf will not find say <c>[CLAN]Y_Less</c> because there name doesn't start  with the specified text.  This option, when set to <c>1</c>, will search  <em>anywhere</em> in the player's name for the given string.  </remarks> 
		</member>
		<member name="F:MATCH_NAME_SIMILARITY">
			<library>sscanf</library>  <remarks>  The <c>MATCH_NAME_SIMILARITY</c> option as a constant string so you can get  compile-time spell checking on the name.  Specify whether <c>u</c> etc should  use the ngrams-based similarity algorithm when searching for players matching  a given name.  I.e. enable or disable fuzzy name matching.  It will return  the best match found, but depending on the threshold that may still be very  different to what was typed.  <code>  SSCANF_Option(MATCH_NAME_SIMILARITY, 0.0); // Will find all names, regardless of input. <br />  SSCANF_Option(MATCH_NAME_SIMILARITY, 1.0); // Will find exact matches only. <br />  SSCANF_Option(MATCH_NAME_SIMILARITY, 0.5); // Will find names somewhat similar to the input. <br />  SSCANF_Option(MATCH_NAME_SIMILARITY, -1.0); // Disable fuzzy name matching.  </code>  </remarks> 
		</member>
		<member name="F:NULL">
			<referrer name="_@_y_inline_@_"/>
			<referrer name="Remote_WriteSpecAndFunc"/>
			<referrer name="INI_RemoveEntry"/>
			<referrer name="INI_WriteBuffer"/>
			<referrer name="Command_ReProcess"/>
		</member>
		<member name="F:O@V_">
			<referrer name="O@A_"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<referrer name="YVA2_Initalise"/>
		</member>
		<member name="F:OLD_DEFAULT_CUSTOM">
			<library>sscanf</library>  <remarks>  The <c>OLD_DEFAULT_CUSTOM</c> option as a constant string so you can get  compile-time spell checking on the name.  This is the same as  <c>OLD_DEFAULT_KUSTOM</c>, but with an alternate spelling.  </remarks> 
		</member>
		<member name="F:OLD_DEFAULT_KUSTOM">
			<library>sscanf</library>  <remarks>  The <c>OLD_DEFAULT_KUSTOM</c> option as a constant string so you can get  compile-time spell checking on the name.  As with <c>U</c>, <c>K</c> used to  require a valid identifier as the default and would parse it using the  specified callback, so this would <em>not</em> work:  <code>  K&lt;vehicle&gt;(Veyron)  </code>  Because that is not a valid vehicle name in GTA.  The new version now just  takes a number and returns that regardless:  <code>  K&lt;vehicle&gt;(999)  </code>  This setting reverts to the old behaviour.  </remarks> 
		</member>
		<member name="F:OLD_DEFAULT_NAME">
			<library>sscanf</library>  <remarks>  The <c>OLD_DEFAULT_NAME</c> option as a constant string so you can get  compile-time spell checking on the name.  The behaviour of <c>U</c>, <c>Q</c>  and <c>R</c> have been changed to take any number as a default, instead of a  connected player.  Setting <c>OLD_DEFAULT_NAME</c> to <c>1</c> will revert to  the old version.  </remarks> 
		</member>
		<member name="F:PUNY_BIAS">
			<referrer name="Puny_Decode"/>
			<referrer name="Puny_Encode"/>
			<referrer name="Puny_EncodeHash"/>
		</member>
		<member name="F:PUNY_DAMP">
			<referrer name="Puny_Adapt"/>
		</member>
		<member name="F:PUNY_INIT">
			<referrer name="Puny_Decode"/>
			<referrer name="Puny_Encode"/>
			<referrer name="Puny_EncodeHash"/>
		</member>
		<member name="F:PUNY_SKEW">
			<referrer name="Puny_Adapt"/>
		</member>
		<member name="F:PUNY_TMAX">
			<referrer name="Puny_Decode"/>
			<referrer name="Puny_EncodeVarHash"/>
			<referrer name="Puny_EncodeVar"/>
			<referrer name="Puny_Adapt"/>
		</member>
		<member name="F:PUNY_TMIN">
			<referrer name="Puny_Decode"/>
			<referrer name="Puny_EncodeVarHash"/>
			<referrer name="Puny_EncodeVar"/>
			<referrer name="Puny_Adapt"/>
		</member>
		<member name="F:PlayerInfo">
			<referrer name="DajIgracuNovac"/>
			<referrer name="SacuvajKorisnike"/>
			<referrer name="LoadUser_data"/>
			<referrer name="@_yCmakestaff"/>
			<referrer name="@_yCstaffon"/>
			<referrer name="@_yCclearchat"/>
			<referrer name="@_yCjetpack"/>
			<referrer name="@_yCstaffvehicle"/>
			<referrer name="@_yCxgoto"/>
			<referrer name="@_yCdajnovac"/>
			<referrer name="@_yCotvoriracun"/>
			<referrer name="@_yCbanka"/>
			<referrer name="@yH_OnDialogResponse@029"/>
			<referrer name="OnPlayerSpawn"/>
			<referrer name="OnDialogResponse"/>
		</member>
		<member name="F:Q@">
			<referrer name="S@"/>
			<referrer name="G@"/>
			<referrer name="F@"/>
			<referrer name="Command_GetName"/>
			<referrer name="Command_GetDisplay"/>
			<referrer name="Command_GetDisplayNamed"/>
			<referrer name="Command_GetNext"/>
		</member>
		<member name="F:REF">
		</member>
		<member name="F:SSCANF_ALPHA">
			<library>sscanf</library>  <remarks>  The <c>SSCANF_ALPHA</c> option as a constant string so you can get compile-  time spell checking on the name.  Specify the default alpha value for colours  (<c>m</c>) which don't manually specify an alpha channel.  The alpha values  are specified as a <em>decimal</em> number, <em>not</em> a <em>hex</em>  number, so setting an alpha of <c>0x80</c> would be:  <code>  SSCANF_Option(SSCANF_ALPHA, 128);  </code>  </remarks> 
		</member>
		<member name="F:SSCANF_ARGB">
			<library>sscanf</library>  <remarks>  The <c>SSCANF_ARGB</c> option as a constant string so you can get compile-  time spell checking on the name.  Specify whether the returned colour is  <c>ARGB</c> or <c>RGBA</c>:  <code>  SSCANF_Option(SSCANF_ARGB, 1); // Set 3- and 6-digit colour outputs to `AARRGGBB`. <br />  SSCANF_Option(SSCANF_ARGB, 0); // Set 3- and 6-digit colour outputs to `RRGGBBAA` (default).  </code>  </remarks> 
		</member>
		<member name="F:SSCANF_COLOUR_FORMS">
			<library>sscanf</library>  <remarks>  The <c>SSCANF_COLOUR_FORMS</c> option as a constant string so you can get  compile-time spell checking on the name.  There are multiple valid colour  input formats, which you can enable or disable here.  The parameter is a  bit map (flags) for all the following values:  <ul>  <li><c>1</c> - <c>#RGB</c></li>  <li><c>2</c> - <c>#RRGGBB</c></li>  <li><c>4</c> - <c>0xRRGGBB</c></li>  <li><c>8</c> - <c>RRGGBB</c></li>  <li><c>16</c> - <c>{RRGGBB}</c></li>  <li><c>32</c> - <c>0xRRGGBBAA</c></li>  <li><c>64</c> - <c>RRGGBBAA</c></li>  </ul>  So to ONLY accept SA:MP `SendClientMessage` colours use:  <code>  SSCANF_Option(SSCANF_COLOUR_FORMS, 16);  </code>  To only accept 8-digit values use:  <code>  SSCANF_Option(SSCANF_COLOUR_FORMS, 96);  </code>  Default values (those specified between <c>()</c>s for <c>M</c>) ignore this  setting - they can always use any form.  </remarks> 
		</member>
		<member name="F:SSCANF_EXT_">
			<library>sscanf</library>  <remarks>  The fallback for the filename in <c>extract</c> on the old compiler, which  doesn't have the inbuilt <c>__file</c> macro.  This is the "feature" enabled  by <c>SSCANF_NO_NICE_FEATURES</c>.  Appends <c>"unknown file"</c> in the  plugin when line number <c>&lt; 0</c>.  </remarks> 
		</member>
		<member name="F:SSCANF_FOM_">
			<library>sscanf</library>  <remarks>  The fallback for the filename in <c>unformat</c> on the old compiler, which  doesn't have the inbuilt <c>__file</c> macro.  This is the "feature" enabled  by <c>SSCANF_NO_NICE_FEATURES</c>.  Appends <c>"unknown file"</c> in the  plugin when line number <c>&lt; 0</c>.  </remarks> 
		</member>
		<member name="F:SSCANF_NPC">
			<library>sscanf</library>  <remarks>  Was sscanf built for an NPC mode or a normal mode?  </remarks> 
		</member>
		<member name="F:SSCANF_QUIET">
			<library>sscanf</library>  <remarks>  The <c>SSCANF_QUIET</c> option as a constant string so you can get compile-  time spell checking on the name.  Don't print any errors to the console.  <em>Really</em> not recommended unless you <em>know</em> your code is stable  and in production.  </remarks> 
		</member>
		<member name="F:SSCANF_UNK_">
			<library>sscanf</library>  <remarks>  The fallback for the filename in <c>sscanf</c> on the old compiler, which  doesn't have the inbuilt <c>__file</c> macro.  This is the "feature" enabled  by <c>SSCANF_NO_NICE_FEATURES</c>.  Appends <c>"unknown file"</c> in the  plugin when line number <c>&lt; 0</c>.  </remarks> 
		</member>
		<member name="F:SSCANF_VERSION_BCD">
			<referrer name="SSCANF_Version"/>
			<library>sscanf</library>  <remarks>  The sscanf version in BCD.  Example:  <code>  2.10.3  <br />  => 02 10 03 <br />  => 0x021003  </code>  </remarks> 
		</member>
		<member name="F:SSCANF_VERSION_BUILD">
			<library>sscanf</library>  <remarks>  The sscanf build number.  </remarks> 
		</member>
		<member name="F:SSCANF_VERSION_MAJOR">
			<library>sscanf</library>  <remarks>  The sscanf major version number.  </remarks> 
		</member>
		<member name="F:SSCANF_VERSION_MINOR">
			<library>sscanf</library>  <remarks>  The sscanf minor version number.  </remarks> 
		</member>
		<member name="F:SSCANF_VERSION_STRING">
			<library>sscanf</library>  <remarks>  The sscanf version as a string.  E.g. <c>"2.8.1"</c>.  </remarks> 
		</member>
		<member name="F:SSCANF_gInit">
			<referrer name="SSCANF_RunInit"/>
			<referrer name="Master_OnScriptInit"/>
			<referrer name="ScriptInit_OnFilterScriptInit"/>
			<referrer name="ScriptInit_OnGameModeInit"/>
			<referrer name="_y_utils_OnPlayerConnect"/>
			<referrer name="_y_utils_OnPlayerDisconnect"/>
			<library>sscanf</library>  <remarks>  Has sscanf been initialised at least once already in this script?  Avoids the  need to define <c>FILTERSCRIPT</c> by including <c>OnFilterScriptInit</c>  and <c>OnGameModeInit</c> (plus <c>OnNPCModeInit</c>) and seeing which one  gets called first.  </remarks> 
		</member>
		<member name="F:Streamer_IncludeFileVersion">
			<attribute name="public"/>
		</member>
		<member name="F:THE_CURRENT_MASTER_IS_CLOUD">
		</member>
		<member name="F:THE_CURRENT_MASTER_IS_CLOUD">
		</member>
		<member name="F:TRUE">
			<tagname value="bool"/>
			<referrer name="YVA2_DummyPush"/>
		</member>
		<member name="F:UNIQUE_SYMBOL_DOESNT_EXIST">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:Ulogovan">
			<referrer name="SacuvajKorisnike"/>
			<referrer name="@yH_OnPlayerText@013"/>
			<referrer name="Proxara"/>
			<referrer name="@_yCmakestaff"/>
			<referrer name="@_yCstaffon"/>
			<referrer name="@_yCclearchat"/>
			<referrer name="@_yCotvoriracun"/>
			<referrer name="@_yCbanka"/>
			<referrer name="SSCANF_OnPlayerConnect"/>
			<referrer name="OnPlayerSpawn"/>
		</member>
		<member name="F:YSI_FILTERSCRIPT">
			<tagname value="bool"/>
			<referrer name="OnFilterScriptInit"/>
			<referrer name="OnGameModeInit"/>
			<referrer name="OnFilterScriptExit"/>
			<referrer name="OnGameModeExit"/>
			<referrer name="YVers_OnScriptInit"/>
		</member>
		<member name="F:YSI_gDebugLevel">
			<referrer name="Debug_Level"/>
		</member>
		<member name="F:YSI_gGroupPlayers">
			<tagname value="Bit"/>
			<referrer name="Group_SetCommand"/>
			<referrer name="Group_SetCommandDefault"/>
		</member>
		<member name="F:YSI_gInlineRet">
			<tagname value="InlineRet"/>
		</member>
		<member name="F:YSI_gIteratorDepth">
			<referrer name="Iter_YieldEnter"/>
			<referrer name="Iter_YieldLoop"/>
			<referrer name="Iter_YieldReturn"/>
		</member>
		<member name="F:YSI_gMallocMemory">
			<referrer name="Malloc_TrySetup"/>
			<referrer name="Malloc_NewS"/>
			<referrer name="Malloc_GetS"/>
			<referrer name="Malloc_SetS"/>
			<referrer name="Malloc_SetVAS"/>
			<referrer name="Malloc_GetA"/>
			<referrer name="Malloc_SetA"/>
			<referrer name="Malloc_SetVAA"/>
			<referrer name="calloc"/>
			<referrer name="Malloc_Allocate"/>
			<referrer name="Malloc_Free"/>
			<referrer name="Malloc_Resolve"/>
			<referrer name="Malloc_Reconcile"/>
			<referrer name="Callback_Get"/>
			<referrer name="Callback_Release"/>
			<referrer name="Remote_RawStrpack"/>
			<referrer name="Timer_GetSingleSlot"/>
			<referrer name="_Timer_C"/>
			<referrer name="_Timer_F"/>
		</member>
		<member name="F:YSI_gPlayerIP">
			<referrer name="OnPlayerConnect"/>
			<referrer name="OnPlayerDisconnect"/>
		</member>
		<member name="F:YSI_gTempGroups">
			<tagname value="Bit"/>
			<referrer name="Group_SetCommand"/>
			<referrer name="Group_ExclusiveCommand"/>
		</member>
		<member name="F:YSI_g_cEmptyGroups">
			<tagname value="Bit"/>
			<referrer name="Group_ExclusiveCommand"/>
			<referrer name="_yGICommand"/>
		</member>
		<member name="F:YSI_g_sCodeEnd">
			<referrer name="CGen_SetupCodeSpace"/>
			<referrer name="CGen_UseCodeSpace"/>
		</member>
		<member name="F:YSI_g_sCodeSpace">
			<referrer name="CGen_SetupCodeSpace"/>
			<referrer name="CGen_UseCodeSpace"/>
			<referrer name="CGen_GetCodeSpace"/>
			<referrer name="CGen_AddCodeSpace"/>
		</member>
		<member name="F:YSI_g_sCommandFlags">
			<tagname value="e_COMMAND_FLAGS"/>
			<referrer name="YSI_g_sCommandFlags_Dist"/>
			<referrer name="YSI_g_sCommandFlags@Dist"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="Command_SetDeniedReturn"/>
			<referrer name="Command_GetDeniedReturn"/>
			<referrer name="Command_SetIllegalReturn"/>
			<referrer name="Command_GetIllegalReturn"/>
			<referrer name="Command_SetUnknownReturn"/>
			<referrer name="Command_GetUnknownReturn"/>
			<referrer name="Command_SetDisconnectReturn"/>
			<referrer name="Command_GetDisconnectReturn"/>
			<referrer name="@yH_OnScriptInit@005"/>
			<referrer name="Command_IncOPCR"/>
			<referrer name="Command_DecOPCR"/>
			<referrer name="Command_IncOPCP"/>
			<referrer name="Command_DecOPCP"/>
		</member>
		<member name="F:YSI_g_sCommandMap">
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="Command_Find"/>
			<referrer name="Command_Remove"/>
			<referrer name="@yH_OnScriptInit@005"/>
			<referrer name="_Command_Rebuild"/>
			<referrer name="Command_Add"/>
		</member>
		<member name="F:YSI_g_sCommands">
			<referrer name="YSI_g_sCommands_Dist"/>
			<referrer name="YSI_g_sCommands@Dist"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="Command_GetPlayer"/>
			<referrer name="Command_SetPlayer"/>
			<referrer name="Command_Touch"/>
			<referrer name="Command_Remove"/>
			<referrer name="Command_IsValid"/>
			<referrer name="Command_GetPlayerCommandCount"/>
			<referrer name="Command_GetName"/>
			<referrer name="Command_GetNext"/>
			<referrer name="Iter_Func@Command"/>
			<referrer name="Iter_Func@PlayerCommand"/>
			<referrer name="@yH_OnScriptInit@005"/>
			<referrer name="@yH_OnMasterSystemClose@005"/>
			<referrer name="_Command_Rebuild"/>
			<referrer name="Command_GetEmptySlot"/>
			<referrer name="Command_Add"/>
			<referrer name="_Command_GetDisplay"/>
		</member>
		<member name="F:YSI_g_sContexts">
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_sCurInlineCode">
			<referrer name="I@F"/>
			<referrer name="Inline_OnAsmError"/>
			<referrer name="I@L"/>
		</member>
		<member name="F:YSI_g_sCurInlineEntry">
			<referrer name="I@E"/>
			<referrer name="I@L"/>
		</member>
		<member name="F:YSI_g_sCurInlineLocals">
			<referrer name="I@E"/>
			<referrer name="I@L"/>
		</member>
		<member name="F:YSI_g_sCurInlineLoop">
			<referrer name="I@F"/>
			<referrer name="I@L"/>
		</member>
		<member name="F:YSI_g_sCurInlineParams">
			<referrer name="I@E"/>
			<referrer name="I@L"/>
		</member>
		<member name="F:YSI_g_sCurInlinePointer">
			<referrer name="I@E"/>
			<referrer name="I@L"/>
		</member>
		<member name="F:YSI_g_sCurLine">
			<referrer name="INI_ParseFile"/>
			<referrer name="INI_DoParentTag"/>
		</member>
		<member name="F:YSI_g_sCurrentID">
			<referrer name="Command_ReProcess"/>
			<referrer name="Command_GetCurrent"/>
		</member>
		<member name="F:YSI_g_sDefaultMembership">
			<tagname value="Bit"/>
			<referrer name="Group_SetCommandDefault"/>
			<referrer name="Group_SetCommandNew"/>
			<referrer name="Group_ExclusiveCommand"/>
			<referrer name="Group_Handoff"/>
			<referrer name="HANDOFF_SOURCE@_Group"/>
			<referrer name="_yGICommand"/>
			<referrer name="_yGACommand"/>
			<referrer name="_Group_IncludeAll_1"/>
		</member>
		<member name="F:YSI_g_sDisabledPlayers">
			<tagname value="Bit"/>
			<referrer name="YSI_g_sDisabledPlayers_Dist"/>
			<referrer name="YSI_g_sDisabledPlayers@Dist"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="Command_SetPlayerDisabled"/>
			<referrer name="Command_GetPlayerDisabled"/>
		</member>
		<member name="F:YSI_g_sElementMembership">
			<tagname value="Bit"/>
			<referrer name="Group_SetCommand"/>
			<referrer name="Group_GetCommand"/>
			<referrer name="Group_SetCommandDefault"/>
			<referrer name="Group_Handoff"/>
			<referrer name="HANDOFF_SOURCE@_Group"/>
			<referrer name="_yGACommand"/>
			<referrer name="_yGUCommand"/>
			<referrer name="_Group_IncludeAll_1"/>
		</member>
		<member name="F:YSI_g_sEmpty">
			<tagname value="Bit"/>
			<referrer name="Group_ExclusiveCommand"/>
			<referrer name="_yGICommand"/>
			<referrer name="_Group_IncludeAll_1"/>
		</member>
		<member name="F:YSI_g_sErrorMessages">
			<referrer name="YSI_g_sErrorMessages_Dist"/>
			<referrer name="YSI_g_sErrorMessages@Dist"/>
		</member>
		<member name="F:YSI_g_sFirstSlot">
			<tagname value="Alloc"/>
			<referrer name="Timer_GetSingleSlot"/>
			<referrer name="_Timer_C"/>
		</member>
		<member name="F:YSI_g_sHeapSetup">
			<referrer name="Malloc_SolidifyHeap"/>
			<referrer name="Malloc_DoPlayerConnect"/>
		</member>
		<member name="F:YSI_g_sHighestID">
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_GetPlayerCommandCount"/>
			<referrer name="Command_GetNext"/>
			<referrer name="Iter_Func@Command"/>
			<referrer name="Iter_Func@PlayerCommand"/>
			<referrer name="_Command_Rebuild"/>
			<referrer name="Command_Add"/>
			<referrer name="_Command_GetDisplay"/>
		</member>
		<member name="F:YSI_g_sINICurrentTag">
			<referrer name="INI_Open"/>
			<referrer name="INI_SetTag"/>
			<referrer name="INI_DeleteTag"/>
			<referrer name="INI_AddToBuffer"/>
			<referrer name="INI_Flush"/>
		</member>
		<member name="F:YSI_g_sINIStartTag">
			<referrer name="INI_Open"/>
			<referrer name="INI_SetTag"/>
			<referrer name="INI_GetTag"/>
			<referrer name="INI_FreeTag"/>
			<referrer name="INI_WriteBuffer"/>
		</member>
		<member name="F:YSI_g_sINITagBuffer">
			<referrer name="INI_SetTag"/>
			<referrer name="INI_DeleteTag"/>
			<referrer name="@yH_OnScriptInit@001"/>
			<referrer name="INI_GetTag"/>
			<referrer name="INI_DumpTag"/>
			<referrer name="INI_AddToBuffer"/>
			<referrer name="INI_FreeTag"/>
			<referrer name="INI_Flush"/>
			<referrer name="INI_WriteBuffer"/>
		</member>
		<member name="F:YSI_g_sINITagPos">
			<referrer name="INI_SetTag"/>
			<referrer name="@yH_OnScriptInit@001"/>
			<referrer name="INI_FreeTag"/>
		</member>
		<member name="F:YSI_g_sINITmpBuffer">
			<referrer name="INI_WriteInt"/>
			<referrer name="INI_WriteHex"/>
			<referrer name="INI_WriteBin"/>
			<referrer name="INI_WriteFloat"/>
		</member>
		<member name="F:YSI_g_sINIWriteBuffer">
			<referrer name="@yH_OnScriptInit@001"/>
			<referrer name="INI_FreeEntry"/>
			<referrer name="INI_DumpTag"/>
			<referrer name="INI_AddToBuffer"/>
			<referrer name="INI_WriteBuffer"/>
		</member>
		<member name="F:YSI_g_sINIWriteFile">
			<referrer name="INI_Open"/>
			<referrer name="INI_Close"/>
			<referrer name="INI_SetTag"/>
			<referrer name="INI_DeleteTag"/>
			<referrer name="INI_AddToBuffer"/>
			<referrer name="INI_Flush"/>
			<referrer name="INI_WriteBuffer"/>
		</member>
		<member name="F:YSI_g_sINIWritePos">
			<referrer name="@yH_OnScriptInit@001"/>
			<referrer name="INI_FreeEntry"/>
			<referrer name="INI_AddToBuffer"/>
			<referrer name="INI_WriteBuffer"/>
		</member>
		<member name="F:YSI_g_sInitialised">
			<referrer name="YVA2_DummyPush"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_sIteratorStack">
			<referrer name="Iter_YieldEnter"/>
			<referrer name="Iter_YieldLoop"/>
			<referrer name="Iter_YieldReturn"/>
		</member>
		<member name="F:YSI_g_sJumpAddress">
			<referrer name="Inline_OnAsmError"/>
			<referrer name="I@L"/>
			<returns>  0  </returns>  <remarks>  AKA. Inline_Main.  The code before the start of the function is split in to three parts:  The first part comes before the start of the loop condition, and is where  all the variables are initialised in the compiled code.  As we don't want to  initialise any variables, this can be repurposed for function entry code.  The address of this is stored in "entry", and it ends at "loop".  The second part is where the function loops back to.  This MUST start with a  "RETN" instruction to end the function in all cases, so any startup code in  the first segment must jump over that "RETN".  The remainder of this section  can be used for any more entry or exit code that is required.  Note that  it can also start with a "STACK" opcode when required.  This section starts  at "loop" and ends at "code".  The final segment is not technically BEFORE the main function code but  AFTER.  That's normally where the stack is restored, but we now have full  control of that (so don't forget to write it in to the process exit code).  "Inline_Allocator" currently marks the end of the first segment, and  "Inline_Main" marks the end of the second segment.  </remarks> 
		</member>
		<member name="F:YSI_g_sLastSlot">
			<tagname value="Alloc"/>
			<referrer name="Timer_GetSingleSlot"/>
			<referrer name="_Timer_C"/>
		</member>
		<member name="F:YSI_g_sLength">
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_sMasterCount">
			<referrer name="ScriptInit_OnScriptExit"/>
			<referrer name="Master_Reassert"/>
			<referrer name="_Master_Relinquish"/>
			<referrer name="_Master_Get"/>
		</member>
		<member name="F:YSI_g_sMasterData">
			<tagname value="Bit"/>
			<referrer name="YSI_g_sCommands_Dist"/>
			<referrer name="YSI_g_sCommands@Dist"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="@yH_OnMasterSystemClose@005"/>
			<referrer name="Command_Add"/>
		</member>
		<member name="F:YSI_g_sMasterData">
			<referrer name="ScriptInit_OnScriptExit"/>
			<referrer name="Master_Reassert"/>
			<referrer name="_Master_Relinquish"/>
			<referrer name="_Master_Get"/>
		</member>
		<member name="F:YSI_g_sMaxEncountered">
			<referrer name="Group_SetCommandDefault"/>
			<referrer name="_yGUCommand"/>
			<referrer name="_Group_IncludeAll_1"/>
		</member>
		<member name="F:YSI_g_sMaxNesting">
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_sPassthroughNestings">
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_sPlayerTimers">
			<referrer name="@yH_OnPlayerConnect@006"/>
			<referrer name="@yH_OnPlayerDisconnect@006"/>
			<referrer name="_Timer_D"/>
		</member>
		<member name="F:YSI_g_sPrefixes">
			<tagname value="Bit"/>
		</member>
		<member name="F:YSI_g_sPrevInlineFunc">
			<referrer name="Callback_Get"/>
			<referrer name="I@E"/>
		</member>
		<member name="F:YSI_g_sPrevJumpOver">
			<referrer name="I@E"/>
		</member>
		<member name="F:YSI_g_sPtr">
			<referrer name="Iter_YieldLoop"/>
			<referrer name="Iter_YieldReturn"/>
		</member>
		<member name="F:YSI_g_sRemoteFunctions">
			<referrer name="GetRemoteFunction"/>
		</member>
		<member name="F:YSI_g_sRemoteSpecifiers">
			<referrer name="GetRemoteFunction"/>
		</member>
		<member name="F:YSI_g_sRemoteStringsEnd">
		</member>
		<member name="F:YSI_g_sRemoteStringsStart">
		</member>
		<member name="F:YSI_g_sRemoteStub">
			<referrer name="GetRemoteFunction"/>
			<referrer name="Remote_WriteSpecAndFunc"/>
		</member>
		<member name="F:YSI_g_sReplacePtr">
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="Hooks_SortReplacements"/>
		</member>
		<member name="F:YSI_g_sReplacements">
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="Hooks_SortReplacements"/>
		</member>
		<member name="F:YSI_g_sReplacementsLongOrder">
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="Hooks_SortReplacements"/>
		</member>
		<member name="F:YSI_g_sReplacementsShortOrder">
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="Hooks_SortReplacements"/>
		</member>
		<member name="F:YSI_g_sRequiredSpace">
			<referrer name="Inline_OnAsmError"/>
			<referrer name="I@L"/>
		</member>
		<member name="F:YSI_g_sReturnBuffer">
			<referrer name="Command_GetName"/>
			<referrer name="Command_GetDisplay"/>
			<referrer name="Command_GetDisplayNamed"/>
			<referrer name="Command_GetNext"/>
			<referrer name="_Command_GetDisplay"/>
		</member>
		<member name="F:YSI_g_sSkips">
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_sStack">
			<referrer name="@yH_OnScriptInit@003"/>
		</member>
		<member name="F:YSI_g_sStackPtr">
			<referrer name="@yH_OnScriptInit@003"/>
			<referrer name="Iter_YieldLoop"/>
			<referrer name="Iter_YieldReturn"/>
		</member>
		<member name="F:YSI_g_sStacks">
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_scError">
			<referrer name="I@E"/>
			<referrer name="I@F"/>
			<referrer name="I@L"/>
		</member>
		<member name="F:YSI_g_scErrorMessage1">
			<referrer name="OnRuntimeError"/>
		</member>
		<member name="F:YSI_g_scErrorMessage2">
			<referrer name="OnRuntimeError"/>
		</member>
		<member name="F:YSI_g_scErrorMessage3">
			<referrer name="OnRuntimeError"/>
		</member>
		<member name="F:YSI_gscDecoder">
			<referrer name="Puny_Decode"/>
		</member>
		<member name="F:YSI_gscISI">
			<referrer name="Command_ReProcess"/>
		</member>
		<member name="F:YSI_gscISII">
			<referrer name="Command_ReProcess"/>
		</member>
		<member name="F:YSI_gscOPCP">
			<referrer name="Command_ReProcess"/>
			<referrer name="@yH_OnScriptInit@005"/>
			<referrer name="@yH_OnScriptExit@005"/>
		</member>
		<member name="F:YSI_gscOPCR">
			<referrer name="Command_ReProcess"/>
			<referrer name="@yH_OnScriptInit@005"/>
			<referrer name="@yH_OnScriptExit@005"/>
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:ZalediOdlediTimer">
			<referrer name="freezethaw"/>
			<referrer name="@yH_OnPlayerSpawn@024"/>
		</member>
		<member name="F:_@">
			<attribute name="public"/>
			<referrer name="Y@"/>
			<referrer name="HookChain_OnScriptInit"/>
			<referrer name="ScriptInit_OnScriptExit"/>
			<referrer name="Master_Reassert"/>
			<referrer name="_Master_Get"/>
			<referrer name="@_"/>
			<referrer name="Iter_ActorDo@"/>
			<referrer name="Iter_VehicleDo@"/>
			<referrer name="Distribute_So"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="@yH_OnMasterSystemClose@005"/>
			<referrer name="Command_Add"/>
			<referrer name="@a"/>
			<referrer name="@yC_do"/>
			<referrer name="@yC_b"/>
			<referrer name="@yC_me"/>
			<referrer name="@yC_makestaff"/>
			<referrer name="@yC_staffon"/>
			<referrer name="@yC_clearchat"/>
			<referrer name="@yC_jetpack"/>
			<referrer name="@yC_staffvehicle"/>
			<referrer name="@yC_xgoto"/>
			<referrer name="@yC_dajnovac"/>
			<referrer name="@yC_otvoriracun"/>
			<referrer name="@yC_banka"/>
		</member>
		<member name="F:_YCM_g@_">
			<tagname value="_E_YCM"/>
			<referrer name="Master_GetCurrentMaster"/>
			<referrer name="@_"/>
		</member>
		<member name="F:_YCM_g@a">
			<tagname value="_E_YCM"/>
			<referrer name="Master_GetCurrentMaster"/>
			<referrer name="@a"/>
		</member>
		<member name="F:__YSI_g_sHeapStart">
			<referrer name="Malloc_TrySetup"/>
			<referrer name="Malloc_Allocate"/>
			<referrer name="Malloc_Free"/>
		</member>
		<member name="F:__YSI_g_sUnusedStart">
			<referrer name="Malloc_TrySetup"/>
			<referrer name="Malloc_Allocate"/>
			<referrer name="Malloc_Free"/>
		</member>
		<member name="F:__date">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
			<referrer name="@_yCmakestaff"/>
			<referrer name="@_yCxgoto"/>
			<referrer name="@_yCdajnovac"/>
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
			<referrer name="@_yCdo"/>
			<referrer name="@_yCb"/>
			<referrer name="@_yCme"/>
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__time">
		</member>
		<member name="F:_yGA">
			<referrer name="_yGICommand"/>
			<referrer name="_yGACommand"/>
			<referrer name="_Group_IncludeAll_1"/>
		</member>
		<member name="F:_yGI">
			<referrer name="_yGICommand"/>
			<referrer name="_Group_IncludeAll_1"/>
		</member>
		<member name="F:_yGU">
			<referrer name="_yGICommand"/>
			<referrer name="_yGUCommand"/>
			<referrer name="_Group_IncludeAll_1"/>
		</member>
		<member name="F:admin_duty">
			<referrer name="@yH_OnPlayerConnect@023"/>
			<referrer name="@_yCstaffon"/>
			<referrer name="@_yCclearchat"/>
			<referrer name="@_yCjetpack"/>
			<referrer name="@_yCstaffvehicle"/>
			<referrer name="@_yCxgoto"/>
			<referrer name="@_yCdajnovac"/>
		</member>
		<member name="F:admin_vehicle">
			<referrer name="@yH_OnPlayerDisconnect@023"/>
			<referrer name="@_yCstaffvehicle"/>
		</member>
		<member name="F:fortz_ptd">
			<tagname value="Text"/>
			<referrer name="CreateGTextDraws"/>
			<referrer name="ShowTextDrawsForPlayer"/>
			<referrer name="VremeDatum"/>
			<referrer name="@yH_OnPlayerConnect@019"/>
		</member>
		<member name="F:gBase">
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanInit"/>
		</member>
		<member name="F:gCodBase">
			<referrer name="DisasmInit"/>
			<referrer name="DisasmReloc"/>
			<referrer name="DisasmWriteCode"/>
		</member>
		<member name="F:gCodeScanCallback_match">
			<referrer name="YVA2_Initalise"/>
		</member>
		<member name="F:gDat">
			<referrer name="CodeScanInit"/>
			<referrer name="CodeScanGetMatchFunc"/>
			<referrer name="CodeScanGetMatchAddress"/>
		</member>
		<member name="F:gHdr">
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanInit"/>
		</member>
		<member name="F:gHdr">
			<referrer name="ResetStaticAmxHeader"/>
			<referrer name="GetAmxHeader"/>
			<referrer name="GetAmxHeaderComponent"/>
			<referrer name="PrintAmxHeader"/>
			<referrer name="GetPublicIndexFromAddress"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="HookPublic"/>
			<referrer name="GetNativeIndexFromAddress"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="HookNative"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetPubVarIndexFromAddress"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagIndexFromName"/>
			<referrer name="GetTagIndexFromID"/>
		</member>
		<member name="F:gInitialized">
			<tagname value="bool"/>
			<referrer name="ResetStaticAmxHeader"/>
			<referrer name="GetAmxHeader"/>
			<referrer name="GetAmxHeaderComponent"/>
			<referrer name="PrintAmxHeader"/>
			<referrer name="GetPublicIndexFromAddress"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="HookPublic"/>
			<referrer name="GetNativeIndexFromAddress"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="HookNative"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetPubVarIndexFromAddress"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagIndexFromName"/>
			<referrer name="GetTagIndexFromID"/>
		</member>
		<member name="F:gPreviousWriteOffset">
			<referrer name="AsmEmitInstruction"/>
			<referrer name="AsmEmitJumpLabelInstruction"/>
			<referrer name="AsmGetPreviousWriteOffset"/>
		</member>
		<member name="F:g_args">
			<referrer name="Push"/>
			<referrer name="Pop"/>
			<referrer name="Call"/>
			<referrer name="CallN"/>
			<referrer name="SysreqC"/>
			<referrer name="SysreqD"/>
			<referrer name="SysreqCN"/>
			<referrer name="SysreqDN"/>
		</member>
		<member name="F:g_call_depth">
			<referrer name="exit_public"/>
			<referrer name="enter_public"/>
		</member>
		<member name="F:g_call_stack">
			<referrer name="exit_public"/>
			<referrer name="enter_public"/>
		</member>
		<member name="F:g_nargs">
			<referrer name="Push"/>
			<referrer name="Pop"/>
			<referrer name="Call"/>
			<referrer name="CallN"/>
			<referrer name="SysreqC"/>
			<referrer name="SysreqD"/>
			<referrer name="SysreqCN"/>
			<referrer name="SysreqDN"/>
		</member>
		<member name="F:g_num_pecs">
			<referrer name="new_pec"/>
		</member>
		<member name="F:g_num_publics">
			<referrer name="exit_public"/>
			<referrer name="ProfilerInit"/>
			<referrer name="ProfilerWriteData"/>
		</member>
		<member name="F:g_pecs">
			<referrer name="new_pec"/>
			<referrer name="ProfilerInit"/>
		</member>
		<member name="F:g_publics">
			<referrer name="exit_public"/>
			<referrer name="ProfilerInit"/>
			<referrer name="ProfilerWriteData"/>
		</member>
		<member name="F:insn_table">
			<referrer name="GetOpcodeInstructionInformation"/>
			<referrer name="GetOpcodeInstructionName"/>
			<referrer name="GetOpcodeInstructionParameters"/>
			<referrer name="GetOpcodeInstructionRelocatable"/>
		</member>
		<member name="F:iterstart@Fib">
		</member>
		<member name="F:iterstart@Filter">
		</member>
		<member name="F:iterstart@NonNull">
		</member>
		<member name="F:iterstart@Null">
		</member>
		<member name="F:iterstart@Powers">
		</member>
		<member name="F:iterstart@Random">
		</member>
		<member name="F:iterstart@Range">
		</member>
		<member name="F:iterstart@Until">
		</member>
		<member name="F:object_int">
			<referrer name="KreirajObjekte"/>
		</member>
		<member name="F:object_world">
			<referrer name="KreirajObjekte"/>
		</member>
		<member name="F:opcode_table">
			<tagname value="Opcode"/>
			<referrer name="InitOpcodeTable"/>
			<referrer name="RelocateOpcode"/>
			<referrer name="UnrelocateOpcode"/>
		</member>
		<member name="F:opcode_table_is_ready">
			<tagname value="bool"/>
			<referrer name="InitOpcodeTable"/>
			<referrer name="RelocateOpcode"/>
			<referrer name="UnrelocateOpcode"/>
		</member>
		<member name="F:size_l">
			<remarks>  <p>Because of the strange way we manipulate the stack, this function actually  gets called twice as often as you would expect.  Essentially, for this  (psudo-)loop:</p>  <code>  for (new i = iter_func(); Iter_YieldLoop(); )                              <br />  {                                                                          <br />  }  </code>  <p>The loop is entered and <c>iter_func()</c> is called.  This indirectly  calls <c>yield</c>, which returns to the call point of that function.  The  loop check is then entered and <c>Iter_YieldLoop()</c> is called.  Depending  on if <c>yield</c> was actually used, the main loop body is entered.  At the  end of that iteration, the loop check is run again and so  <c>Iter_YieldLoop()</c> is called again.</p>  <p>This is where it gets wierd!</p>  <p><c>Iter_YieldLoop()</c> does a stack copy and a jump in to the earlier  call to <c>iter_func</c>, whose return address is earlier in the code.  When  a <c>yield</c> is done again, that return is to the first part of the  <c>for</c> loop, which then instantly enters the loop check section and calls  <c>Iter_YieldLoop()</c> again (as a side-effect, saving the iterator value in  the loop variable).</p>  <p>So for <c>N</c> iterations of the loop, <c>Iter_YieldLoop()</c> is called  <c>2N + 1</c> times, and should be made aware of which phase of its calls it  is in.</p>  <p>This is, of course, made more complicated by nested loops, but that just  means we need to store the state on our own stack.</p>  </remarks> 
		</member>
		<member name="F:src_l">
		</member>
		<member name="F:tmpobjid">
			<referrer name="KreirajObjekte"/>
		</member>
		<member name="F:using_deprecated_foreach_syntax">
			<tagname value="bool"/>
			The workings of these macros are very extensively documented at:  <a href="http://forum.sa-mp.com/showpost.php?p=2823668" /> 
		</member>

		<!-- functions -->
		<member name="M:operator!(Float:)" syntax="operator!(Float:)(oper)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="cellmax"/>
			<param name="oper">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator+(InlineRet:,bool:)" syntax="operator+(InlineRet:,bool:)(a, b)">
			<tagname value="InlineRet"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>InlineRet </paraminfo>
			</param>
			<param name="b">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:operator+(InlineRet:,Float:)" syntax="operator+(InlineRet:,Float:)(a, b)">
			<tagname value="InlineRet"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>InlineRet </paraminfo>
			</param>
			<param name="b">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator+(InlineRet:,_:)" syntax="operator+(InlineRet:,_:)(a, b)">
			<tagname value="InlineRet"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>InlineRet </paraminfo>
				Dummy variable.
			</param>
			<param name="b">
				Return value.
			</param>
			<summary>operator+</summary>      <remarks>  This is a prefix function that takes some value and returns it to the  caller's caller.  This makes "@return" in inline functions work.  </remarks> 
		</member>
		<member name="M:operator%(_:,Float:)" syntax="operator%(_:,Float:)(oper1, oper2)">
			<stacksize value="1"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator%(Float:,_:)" syntax="operator%(Float:,_:)(oper1, oper2)">
			<stacksize value="1"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator%(Float:,Float:)" syntax="operator%(Float:,Float:)(oper1, oper2)">
			<stacksize value="1"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator!=(Float:,_:)" syntax="operator!=(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator!=(Float:,Float:)" syntax="operator!=(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="RandomFloat"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(_:,Float:)" syntax="operator-(_:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatsub"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(Float:,_:)" syntax="operator-(Float:,_:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatsub"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator+(Float:,_:)" syntax="operator+(Float:,_:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatadd"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator/(_:,Float:)" syntax="operator/(_:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatdiv"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator/(Float:,_:)" syntax="operator/(Float:,_:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<referrer name="Proxara"/>
			<dependency name="float"/>
			<dependency name="floatdiv"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator*(Float:,_:)" syntax="operator*(Float:,_:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatmul"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator++(Float:)" syntax="operator++(Float:)(oper)">
			<tagname value="Float"/>
			<stacksize value="1"/>
			<dependency name="operator+(Float:,Float:)"/>
			<param name="oper">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(Float:)" syntax="operator-(Float:)(oper)">
			<tagname value="Float"/>
			<stacksize value="1"/>
			<referrer name="RandomFloat"/>
			<referrer name="Proxara"/>
			<dependency name="cellmin"/>
			<param name="oper">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator--(Float:)" syntax="operator--(Float:)(oper)">
			<tagname value="Float"/>
			<stacksize value="1"/>
			<dependency name="operator-(Float:,Float:)"/>
			<param name="oper">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(Float:,Float:)" syntax="operator-(Float:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator--(Float:)"/>
			<referrer name="RandomFloat"/>
			<referrer name="Ucitaj_Pickups"/>
			<referrer name="Proxara"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator+(Float:,Float:)" syntax="operator+(Float:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator++(Float:)"/>
			<referrer name="RandomFloat"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator/(Float:,Float:)" syntax="operator/(Float:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="__TU"/>
			<referrer name="RandomFloat"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator*(Float:,Float:)" syntax="operator*(Float:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="RandomFloat"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:Float:operator=(_:)" syntax="Float:operator=(_:)(oper)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="@yH_OnPlayerSpawn@022"/>
			<referrer name="HPdaj"/>
			<referrer name="@_yCstaffvehicle"/>
			<param name="oper">
			</param>
		</member>
		<member name="M:operator==(Float:,Float:)" syntax="operator==(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator==(Float:,_:)" syntax="operator==(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&gt;(Float:,Float:)" syntax="operator&gt;(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="Proxara"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&gt;(Float:,_:)" syntax="operator&gt;(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&gt;(_:,Float:)" syntax="operator&gt;(_:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&gt;=(Float:,Float:)" syntax="operator&gt;=(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="SSCANF_GetSimilarString"/>
			<referrer name="GetPlayer2DZone"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&gt;=(Float:,_:)" syntax="operator&gt;=(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&gt;=(_:,Float:)" syntax="operator&gt;=(_:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&lt;(Float:,Float:)" syntax="operator&lt;(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="RandomFloat"/>
			<referrer name="Proxara"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&lt;(Float:,_:)" syntax="operator&lt;(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&lt;(_:,Float:)" syntax="operator&lt;(_:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&lt;=(Float:,Float:)" syntax="operator&lt;=(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="GetPlayer2DZone"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&lt;=(Float:,_:)" syntax="operator&lt;=(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&lt;=(_:,Float:)" syntax="operator&lt;=(_:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:@CO_HookChain" syntax="@CO_HookChain()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<referrer name="@CO_Master"/>
			<dependency name="@CO_ScriptInit"/>
		</member>
		<member name="M:@CO_Master" syntax="@CO_Master()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<referrer name="@CO_SSCANF"/>
			<dependency name="@CO_HookChain"/>
		</member>
		<member name="M:@CO_SSCANF" syntax="@CO_SSCANF()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="@CO_Master"/>
		</member>
		<member name="M:@CO_ScriptInit" syntax="@CO_ScriptInit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<referrer name="@CO_HookChain"/>
		</member>
		<member name="M:@RETOnPlayerCommandText" syntax="@RETOnPlayerCommandText()">
			<attribute name="public"/>
			<stacksize value="1"/>
		</member>
		<member name="M:@RETOnRconCommand" syntax="@RETOnRconCommand()">
			<attribute name="public"/>
			<stacksize value="1"/>
		</member>
		<member name="M:@_" syntax="@_()">
			<attribute name="public"/>
			<stacksize value="7"/>
			<automaton name="@_"/>
			<dependency name="CallLocalFunction"/>
			<dependency name="CallRemoteFunction"/>
			<dependency name="Debug_Print0"/>
			<dependency name="Master_GetCurrentMaster"/>
			<dependency name="_@"/>
			<dependency name="_E_YCM@m"/>
			<dependency name="_E_YCM@n"/>
			<dependency name="_E_YCM@p"/>
			<dependency name="_E_YCM@y"/>
			<dependency name="_Master_Relinquish"/>
			<dependency name="_YCM_g@_"/>
			<dependency name="getproperty"/>
			<dependency name="setproperty"/>
			<transition keep="true" target="_YCM : m" source="_YCM : y" />  <transition keep="true" target="_YCM : p" source="_YCM : y" />  <transition keep="true" target="_YCM : n" source="_YCM : y" />  <transition keep="true" target="_YCM : y" source="_YCM : u" /> <p/> <transition target="y" source="_ALS_go"/>

		</member>
		<member name="M:@_OnScriptInit" syntax="@_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="Master_GetCurrentMaster"/>
		</member>
		<member name="M:@_yCb" syntax="@_yCb(playerid, params[], help)">
			<attribute name="public"/>
			<stacksize value="289"/>
			<referrer name="@yC_b"/>
			<dependency name="GetName"/>
			<dependency name="GetName"/>
			<dependency name="Proxara"/>
			<dependency name="SSCANF__"/>
			<dependency name="SendClientMessage"/>
			<dependency name="__file"/>
			<dependency name="__line"/>
			<dependency name="format"/>
			<param name="playerid">
			</param>
			<param name="params">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="help">
			</param>
		</member>
		<member name="M:@_yCbanka" syntax="@_yCbanka(playerid, params[], help)">
			<attribute name="public"/>
			<stacksize value="9"/>
			<referrer name="@yC_banka"/>
			<dependency name="IsPlayerInRangeOfPoint"/>
			<dependency name="PlayerInfo"/>
			<dependency name="SendClientMessage"/>
			<dependency name="ShowPlayerDialog"/>
			<dependency name="Ulogovan"/>
			<dependency name="dialog_banka"/>
			<dependency name="player_accountbank"/>
			<param name="playerid">
			</param>
			<param name="params">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="help">
			</param>
		</member>
		<member name="M:@_yCclearchat" syntax="@_yCclearchat(playerid, params[], help)">
			<attribute name="public"/>
			<stacksize value="6"/>
			<referrer name="@yC_clearchat"/>
			<dependency name="GetPlayerName"/>
			<dependency name="PlayerInfo"/>
			<dependency name="SacuvajKorisnike"/>
			<dependency name="SendClientMessage"/>
			<dependency name="SendClientMessageToAll"/>
			<dependency name="Ulogovan"/>
			<dependency name="admin_duty"/>
			<dependency name="format"/>
			<dependency name="player_staff"/>
			<param name="playerid">
			</param>
			<param name="params">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="help">
			</param>
		</member>
		<member name="M:@_yCdajnovac" syntax="@_yCdajnovac(playerid, params[], help)">
			<attribute name="public"/>
			<stacksize value="188"/>
			<referrer name="@yC_dajnovac"/>
			<dependency name="DajIgracuNovac"/>
			<dependency name="ImeIgraca"/>
			<dependency name="ImeIgraca"/>
			<dependency name="PlayerInfo"/>
			<dependency name="SSCANF__"/>
			<dependency name="SendClientMessage"/>
			<dependency name="SendClientMessageEx"/>
			<dependency name="__file"/>
			<dependency name="__line"/>
			<dependency name="admin_duty"/>
			<dependency name="format"/>
			<dependency name="player_staff"/>
			<param name="playerid">
			</param>
			<param name="params">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="help">
			</param>
		</member>
		<member name="M:@_yCdo" syntax="@_yCdo(playerid, params[], help)">
			<attribute name="public"/>
			<stacksize value="289"/>
			<referrer name="@yC_do"/>
			<dependency name="GetName"/>
			<dependency name="GetName"/>
			<dependency name="Proxara"/>
			<dependency name="SSCANF__"/>
			<dependency name="SendClientMessage"/>
			<dependency name="SetPlayerChatBubble"/>
			<dependency name="__file"/>
			<dependency name="__line"/>
			<dependency name="format"/>
			<param name="playerid">
			</param>
			<param name="params">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="help">
			</param>
		</member>
		<member name="M:@_yCjetpack" syntax="@_yCjetpack(playerid, params[], help)">
			<attribute name="public"/>
			<stacksize value="9"/>
			<referrer name="@yC_jetpack"/>
			<dependency name="GetPlayerPos"/>
			<dependency name="Koristi_JetPack"/>
			<dependency name="PlayerInfo"/>
			<dependency name="SendClientMessage"/>
			<dependency name="SetPlayerPos"/>
			<dependency name="SetPlayerSpecialAction"/>
			<dependency name="admin_duty"/>
			<dependency name="player_staff"/>
			<param name="playerid">
			</param>
			<param name="params">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="help">
			</param>
		</member>
		<member name="M:@_yCmakestaff" syntax="@_yCmakestaff(playerid, params[], help)">
			<attribute name="public"/>
			<stacksize value="790"/>
			<referrer name="@yC_makestaff"/>
			<dependency name="GetName"/>
			<dependency name="GetName"/>
			<dependency name="GetPlayerName"/>
			<dependency name="IsPlayerAdmin"/>
			<dependency name="IsPlayerConnected"/>
			<dependency name="PlayerInfo"/>
			<dependency name="PlayerInfo"/>
			<dependency name="SSCANF__"/>
			<dependency name="SacuvajKorisnike"/>
			<dependency name="SendClientMessage"/>
			<dependency name="ShowPlayerDialog"/>
			<dependency name="Ulogovan"/>
			<dependency name="__file"/>
			<dependency name="__line"/>
			<dependency name="d_pravljenjeadmina"/>
			<dependency name="format"/>
			<dependency name="player_staff"/>
			<param name="playerid">
			</param>
			<param name="params">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="help">
			</param>
		</member>
		<member name="M:@_yCme" syntax="@_yCme(playerid, params[], help)">
			<attribute name="public"/>
			<stacksize value="288"/>
			<referrer name="@yC_me"/>
			<dependency name="GetName"/>
			<dependency name="GetName"/>
			<dependency name="Proxara"/>
			<dependency name="SSCANF__"/>
			<dependency name="SendClientMessage"/>
			<dependency name="SetPlayerChatBubble"/>
			<dependency name="__file"/>
			<dependency name="__line"/>
			<dependency name="format"/>
			<param name="playerid">
			</param>
			<param name="params">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="help">
			</param>
		</member>
		<member name="M:@_yCotvoriracun" syntax="@_yCotvoriracun(playerid, params[], help)">
			<attribute name="public"/>
			<stacksize value="7"/>
			<referrer name="@yC_otvoriracun"/>
			<dependency name="IsPlayerInRangeOfPoint"/>
			<dependency name="PlayerInfo"/>
			<dependency name="PlayerInfo"/>
			<dependency name="SacuvajKorisnike"/>
			<dependency name="SendClientMessage"/>
			<dependency name="Ulogovan"/>
			<dependency name="player_accountbank"/>
			<dependency name="true"/>
			<param name="playerid">
			</param>
			<param name="params">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="help">
			</param>
		</member>
		<member name="M:@_yCstaffon" syntax="@_yCstaffon(playerid, params[], help)">
			<attribute name="public"/>
			<stacksize value="6"/>
			<referrer name="@yC_staffon"/>
			<dependency name="GetPlayerName"/>
			<dependency name="PlayerInfo"/>
			<dependency name="SacuvajKorisnike"/>
			<dependency name="SendClientMessage"/>
			<dependency name="SendClientMessageToAll"/>
			<dependency name="SetPlayerArmour"/>
			<dependency name="SetPlayerHealth"/>
			<dependency name="SetPlayerSkin"/>
			<dependency name="Ulogovan"/>
			<dependency name="admin_duty"/>
			<dependency name="false"/>
			<dependency name="format"/>
			<dependency name="player_staff"/>
			<dependency name="true"/>
			<param name="playerid">
			</param>
			<param name="params">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="help">
			</param>
		</member>
		<member name="M:@_yCstaffvehicle" syntax="@_yCstaffvehicle(playerid, params[], help)">
			<attribute name="public"/>
			<stacksize value="22"/>
			<referrer name="@yC_staffvehicle"/>
			<dependency name="Float:operator=(_:)"/>
			<dependency name="Attach3DTextLabelToVehicle"/>
			<dependency name="Create3DTextLabel"/>
			<dependency name="Delete3DTextLabel"/>
			<dependency name="GetPlayerPos"/>
			<dependency name="GetPlayerVehicleID"/>
			<dependency name="GetVehicleParamsEx"/>
			<dependency name="Iter_CreateVehicle"/>
			<dependency name="Iter_DestroyVehicle"/>
			<dependency name="LabelStaffVehicle"/>
			<dependency name="PlayerInfo"/>
			<dependency name="PutPlayerInVehicle"/>
			<dependency name="SendClientMessage"/>
			<dependency name="SetVehicleParamsEx"/>
			<dependency name="admin_duty"/>
			<dependency name="admin_vehicle"/>
			<dependency name="player_staff"/>
			<dependency name="random"/>
			<param name="playerid">
			</param>
			<param name="params">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="help">
			</param>
		</member>
		<member name="M:@_yCxgoto" syntax="@_yCxgoto(playerid, params[], help)">
			<attribute name="public"/>
			<stacksize value="112"/>
			<referrer name="@yC_xgoto"/>
			<dependency name="GetPlayerVehicleID"/>
			<dependency name="IsPlayerInAnyVehicle"/>
			<dependency name="PlayerInfo"/>
			<dependency name="SSCANF__"/>
			<dependency name="SendClientMessage"/>
			<dependency name="SetPlayerPos"/>
			<dependency name="SetVehiclePos"/>
			<dependency name="__file"/>
			<dependency name="__line"/>
			<dependency name="admin_duty"/>
			<dependency name="format"/>
			<dependency name="player_staff"/>
			<param name="playerid">
			</param>
			<param name="params">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="help">
			</param>
		</member>
		<member name="M:@_yHCheckpoint" syntax="@_yHCheckpoint()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHCommand" syntax="@_yHCommand()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHContainer" syntax="@_yHContainer()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHDynamic" syntax="@_yHDynamic()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHDynamicCP" syntax="@_yHDynamicCP()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHInventory" syntax="@_yHInventory()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHObject" syntax="@_yHObject()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHTextDraw" syntax="@_yHTextDraw()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHUpdate" syntax="@_yHUpdate()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@a" syntax="@a()">
			<attribute name="public"/>
			<stacksize value="7"/>
			<automaton name="@a"/>
			<dependency name="CallLocalFunction"/>
			<dependency name="CallRemoteFunction"/>
			<dependency name="Debug_Print0"/>
			<dependency name="Master_GetCurrentMaster"/>
			<dependency name="_@"/>
			<dependency name="_E_YCM@m"/>
			<dependency name="_E_YCM@n"/>
			<dependency name="_E_YCM@p"/>
			<dependency name="_E_YCM@y"/>
			<dependency name="_Master_Relinquish"/>
			<dependency name="_YCM_g@a"/>
			<dependency name="getproperty"/>
			<dependency name="setproperty"/>
			<transition keep="true" target="_YCM : m" source="_YCM : y" />  <transition keep="true" target="_YCM : p" source="_YCM : y" />  <transition keep="true" target="_YCM : n" source="_YCM : y" />  <transition keep="true" target="_YCM : y" source="_YCM : u" /> <p/> <transition target="y" source="_ALS_go"/>

		</member>
		<member name="M:@receivepacket" syntax="@receivepacket(packet[], size, source[])">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="packet">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:@receivestring" syntax="@receivestring(message[], source[])">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="message">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:@yC_b" syntax="@yC_b(a, b[], c, i)">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="@_yCb"/>
			<dependency name="U@"/>
			<dependency name="_@"/>
			<param name="a">
			</param>
			<param name="b">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="c">
			</param>
			<param name="i">
			</param>
		</member>
		<member name="M:@yC_banka" syntax="@yC_banka(a, b[], c, i)">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="@_yCbanka"/>
			<dependency name="U@"/>
			<dependency name="_@"/>
			<param name="a">
			</param>
			<param name="b">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="c">
			</param>
			<param name="i">
			</param>
		</member>
		<member name="M:@yC_clearchat" syntax="@yC_clearchat(a, b[], c, i)">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="@_yCclearchat"/>
			<dependency name="U@"/>
			<dependency name="_@"/>
			<param name="a">
			</param>
			<param name="b">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="c">
			</param>
			<param name="i">
			</param>
		</member>
		<member name="M:@yC_dajnovac" syntax="@yC_dajnovac(a, b[], c, i)">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="@_yCdajnovac"/>
			<dependency name="U@"/>
			<dependency name="_@"/>
			<param name="a">
			</param>
			<param name="b">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="c">
			</param>
			<param name="i">
			</param>
		</member>
		<member name="M:@yC_do" syntax="@yC_do(a, b[], c, i)">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="@_yCdo"/>
			<dependency name="U@"/>
			<dependency name="_@"/>
			<param name="a">
			</param>
			<param name="b">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="c">
			</param>
			<param name="i">
			</param>
		</member>
		<member name="M:@yC_jetpack" syntax="@yC_jetpack(a, b[], c, i)">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="@_yCjetpack"/>
			<dependency name="U@"/>
			<dependency name="_@"/>
			<param name="a">
			</param>
			<param name="b">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="c">
			</param>
			<param name="i">
			</param>
		</member>
		<member name="M:@yC_makestaff" syntax="@yC_makestaff(a, b[], c, i)">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="@_yCmakestaff"/>
			<dependency name="U@"/>
			<dependency name="_@"/>
			<param name="a">
			</param>
			<param name="b">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="c">
			</param>
			<param name="i">
			</param>
		</member>
		<member name="M:@yC_me" syntax="@yC_me(a, b[], c, i)">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="@_yCme"/>
			<dependency name="U@"/>
			<dependency name="_@"/>
			<param name="a">
			</param>
			<param name="b">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="c">
			</param>
			<param name="i">
			</param>
		</member>
		<member name="M:@yC_otvoriracun" syntax="@yC_otvoriracun(a, b[], c, i)">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="@_yCotvoriracun"/>
			<dependency name="U@"/>
			<dependency name="_@"/>
			<param name="a">
			</param>
			<param name="b">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="c">
			</param>
			<param name="i">
			</param>
		</member>
		<member name="M:@yC_staffon" syntax="@yC_staffon(a, b[], c, i)">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="@_yCstaffon"/>
			<dependency name="U@"/>
			<dependency name="_@"/>
			<param name="a">
			</param>
			<param name="b">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="c">
			</param>
			<param name="i">
			</param>
		</member>
		<member name="M:@yC_staffvehicle" syntax="@yC_staffvehicle(a, b[], c, i)">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="@_yCstaffvehicle"/>
			<dependency name="U@"/>
			<dependency name="_@"/>
			<param name="a">
			</param>
			<param name="b">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="c">
			</param>
			<param name="i">
			</param>
		</member>
		<member name="M:@yC_xgoto" syntax="@yC_xgoto(a, b[], c, i)">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="@_yCxgoto"/>
			<dependency name="U@"/>
			<dependency name="_@"/>
			<param name="a">
			</param>
			<param name="b">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="c">
			</param>
			<param name="i">
			</param>
		</member>
		<member name="M:@yH_OnDialogResponse@029" syntax="@yH_OnDialogResponse@029(playerid, dialogid, response, listitem, inputtext[])">
			<attribute name="public"/>
			<stacksize value="162"/>
			<dependency name="DajIgracuNovac"/>
			<dependency name="GetPlayerName"/>
			<dependency name="IgracKojimSaljes"/>
			<dependency name="IsPlayerConnected"/>
			<dependency name="PlayerInfo"/>
			<dependency name="PlayerInfo"/>
			<dependency name="SCMF"/>
			<dependency name="SendClientMessage"/>
			<dependency name="ShowPlayerDialog"/>
			<dependency name="d_balancenovac"/>
			<dependency name="d_ostavljanjenovac"/>
			<dependency name="d_podizanjenovac"/>
			<dependency name="d_spremnoslanje"/>
			<dependency name="d_transfernovac"/>
			<dependency name="dialog_banka"/>
			<dependency name="format"/>
			<dependency name="player_accountbank"/>
			<dependency name="player_bankmoney"/>
			<dependency name="player_money"/>
			<dependency name="strval"/>
			<param name="playerid">
			</param>
			<param name="dialogid">
			</param>
			<param name="response">
			</param>
			<param name="listitem">
			</param>
			<param name="inputtext">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:@yH_OnMasterSystemClose@005" syntax="@yH_OnMasterSystemClose@005(id)">
			<attribute name="public"/>
			<stacksize value="17"/>
			<automaton name="@_"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_Read"/>
			<dependency name="Command_Remove"/>
			<dependency name="Debug_Print0"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="E_COMMAND_POINTER"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sMasterData"/>
			<dependency name="_@"/>
			<dependency name="cellmin"/>
			<dependency name="funcidx"/>
			<dependency name="strpack"/>
			<param name="id">
			</param>
		</member>
		<member name="M:@yH_OnPlayerCommandText@005" syntax="@yH_OnPlayerCommandText@005(playerid, cmdtext[])">
			<attribute name="public"/>
			<stacksize value="6"/>
			<automaton name="@_"/>
			<dependency name="Command_ReProcess"/>
			<param name="playerid">
				Player who typed a command.
			</param>
			<param name="cmdtext">
				<paraminfo> [] </paraminfo>
				What they typed.
			</param>
			    <returns>  0 - Could not process the command.  1 - Called the command.  </returns>  <remarks>  The core of the command processor.  Now vsatly simplified.  This function first finds the command in our hash map.  If it exists, it  checks if the player can use it.  If they can, it checks if it is only in  the current script.  If it is it calls it directly, if it isn't it calls it  using "CallRemoteFunction", which takes in to account master states in  multiple scripts and the special master 23, which calls it in only one  other script.  </remarks> 
		</member>
		<member name="M:@yH_OnPlayerConnect@004" syntax="@yH_OnPlayerConnect@004(playerid)">
			<attribute name="public"/>
			<stacksize value="7"/>
			<dependency name="IsPlayerNPC"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_Single@Bot"/>
			<dependency name="Iter_Single@Character"/>
			<dependency name="Iter_Single@Player"/>
			<dependency name="Iterator@Bot"/>
			<dependency name="Iterator@Character"/>
			<dependency name="Iterator@Player"/>
			<param name="playerid">
				Player who joined.
			</param>
			  <remarks>  Adds a player to the loop data.  Now sorts the list too.  Note that I found  the most bizzare bug ever (I *think* it may be a compiler but, but it  requires further investigation), basically it seems that multiple variables  were being treated as the same variable (namely @YSII_EgotS and  @YSII_CgharacterS were the same and @YSII_EgotC and @YSII_CgharacterC were the  same).  Adding print statements which reference these variables seem to fix  the problem, and I've tried to make sure that the values will never actually  get printed.  </remarks> 
		</member>
		<member name="M:@yH_OnPlayerConnect@006" syntax="@yH_OnPlayerConnect@006(playerid)">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="YSI_g_sPlayerTimers"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:@yH_OnPlayerConnect@016" syntax="@yH_OnPlayerConnect@016(playerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<dependency name="BunnyHop"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:@yH_OnPlayerConnect@019" syntax="@yH_OnPlayerConnect@019(playerid)">
			<attribute name="public"/>
			<stacksize value="29"/>
			<dependency name="GetPlayerName"/>
			<dependency name="TextDrawSetString"/>
			<dependency name="fortz_ptd"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:@yH_OnPlayerConnect@023" syntax="@yH_OnPlayerConnect@023(playerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<dependency name="Koristi_JetPack"/>
			<dependency name="admin_duty"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:@yH_OnPlayerDeath@023" syntax="@yH_OnPlayerDeath@023(playerid, killerid, reason)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<dependency name="Koristi_JetPack"/>
			<param name="playerid">
			</param>
			<param name="killerid">
			</param>
			<param name="reason">
			</param>
		</member>
		<member name="M:@yH_OnPlayerDisconnect@004" syntax="@yH_OnPlayerDisconnect@004(playerid, reason)">
			<attribute name="public"/>
			<stacksize value="7"/>
			<dependency name="SetTimerEx"/>
			<dependency name="false"/>
			<param name="playerid">
				Player who left.
			</param>
			<param name="reason">
			</param>
			  <remarks>  Removes a player from the loop data.  No longer uses "hook" to ENSURE  that this is always last.  Previously I think that the order of  evaluation in y_hooks meant that this got called before the user  "OnPlayerDisconnect".  </remarks> 
		</member>
		<member name="M:@yH_OnPlayerDisconnect@006" syntax="@yH_OnPlayerDisconnect@006(playerid, reason)">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="YSI_g_sPlayerTimers"/>
			<param name="playerid">
			</param>
			<param name="reason">
			</param>
		</member>
		<member name="M:@yH_OnPlayerDisconnect@023" syntax="@yH_OnPlayerDisconnect@023(playerid, reason)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<dependency name="Iter_DestroyVehicle"/>
			<dependency name="admin_vehicle"/>
			<param name="playerid">
			</param>
			<param name="reason">
			</param>
		</member>
		<member name="M:@yH_OnPlayerKeyStateChange@015" syntax="@yH_OnPlayerKeyStateChange@015(playerid, newkeys, oldkeys)">
			<attribute name="public"/>
			<stacksize value="13"/>
			<dependency name="ApplyAnimation"/>
			<dependency name="GameTextForPlayer"/>
			<dependency name="GetPlayerWeapon"/>
			<dependency name="PlayerPlaySound"/>
			<param name="playerid">
			</param>
			<param name="newkeys">
			</param>
			<param name="oldkeys">
			</param>
		</member>
		<member name="M:@yH_OnPlayerKeyStateChange@016" syntax="@yH_OnPlayerKeyStateChange@016(playerid, newkeys, oldkeys)">
			<attribute name="public"/>
			<stacksize value="191"/>
			<dependency name="ApplyAnimation"/>
			<dependency name="BunnyHop"/>
			<dependency name="GameTextForPlayer"/>
			<dependency name="GetPlayerName"/>
			<dependency name="IsPlayerInAnyVehicle"/>
			<dependency name="PlayerPlaySound"/>
			<dependency name="SendClientMessage"/>
			<dependency name="SetTimerEx"/>
			<dependency name="false"/>
			<dependency name="format"/>
			<param name="playerid">
			</param>
			<param name="newkeys">
			</param>
			<param name="oldkeys">
			</param>
		</member>
		<member name="M:@yH_OnPlayerKeyStateChange@028" syntax="@yH_OnPlayerKeyStateChange@028(playerid, newkeys, oldkeys)">
			<attribute name="public"/>
			<stacksize value="7"/>
			<dependency name="EnterijerBrojac"/>
			<dependency name="IsPlayerInAnyVehicle"/>
			<dependency name="IsPlayerInRangeOfPoint"/>
			<dependency name="SetPlayerFacingAngle"/>
			<dependency name="SetPlayerInterior"/>
			<dependency name="SetPlayerPos"/>
			<dependency name="SetPlayerVirtualWorld"/>
			<param name="playerid">
			</param>
			<param name="newkeys">
			</param>
			<param name="oldkeys">
			</param>
		</member>
		<member name="M:@yH_OnPlayerRequestClass@014" syntax="@yH_OnPlayerRequestClass@014(playerid, classid)">
			<attribute name="public"/>
			<stacksize value="15"/>
			<dependency name="SetSpawnInfo"/>
			<dependency name="SpawnPlayer"/>
			<param name="playerid">
			</param>
			<param name="classid">
			</param>
		</member>
		<member name="M:@yH_OnPlayerSpawn@017" syntax="@yH_OnPlayerSpawn@017(playerid)">
			<attribute name="public"/>
			<stacksize value="6"/>
			<dependency name="SetPlayerPos"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:@yH_OnPlayerSpawn@019" syntax="@yH_OnPlayerSpawn@019(playerid)">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="CreatePTextDraws"/>
			<dependency name="Ingame_PTD"/>
			<dependency name="Ingame_PTD"/>
			<dependency name="PlayerTextDrawShow"/>
			<dependency name="ShowTextDrawsForPlayer"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:@yH_OnPlayerSpawn@022" syntax="@yH_OnPlayerSpawn@022(playerid)">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="Float:operator=(_:)"/>
			<dependency name="SendClientMessage"/>
			<dependency name="SetPlayerHealth"/>
			<dependency name="SetTimer"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:@yH_OnPlayerSpawn@024" syntax="@yH_OnPlayerSpawn@024(playerid)">
			<attribute name="public"/>
			<stacksize value="7"/>
			<dependency name="SetTimerEx"/>
			<dependency name="TogglePlayerControllable"/>
			<dependency name="ZalediOdlediTimer"/>
			<dependency name="false"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:@yH_OnPlayerText@005" syntax="@yH_OnPlayerText@005(playerid, text[])">
			<attribute name="public"/>
			<stacksize value="6"/>
			<automaton name="@_"/>
			<dependency name="Command_ReProcess"/>
			<param name="playerid">
				Player who typed something.
			</param>
			<param name="text">
				<paraminfo> [] </paraminfo>
				What they typed.
			</param>
			    <returns>  0 - Could not process the command.  1 - Called the command.  </returns>  <remarks>  Used to implement alternate command prefixes.  </remarks> 
		</member>
		<member name="M:@yH_OnPlayerText@013" syntax="@yH_OnPlayerText@013(playerid, text[])">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="SendClientMessage"/>
			<dependency name="Ulogovan"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:@yH_OnScriptExit@005" syntax="@yH_OnScriptExit@005()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="Command_DecOPCP"/>
			<dependency name="Command_DecOPCR"/>
			<dependency name="YSI_gscOPCP"/>
			<dependency name="YSI_gscOPCR"/>
			<dependency name="funcidx"/>
			<remarks>  When a script ends, update the status of any new callback hooks.  </remarks> 
		</member>
		<member name="M:@yH_OnScriptInit@001" syntax="@yH_OnScriptInit@001()">
			<attribute name="public"/>
			<stacksize value="2"/>
			<dependency name="E_INI_KV_ENTRY_NEXT"/>
			<dependency name="E_INI_TAGS_NEXT"/>
			<dependency name="YSI_g_sINITagBuffer"/>
			<dependency name="YSI_g_sINITagBuffer"/>
			<dependency name="YSI_g_sINITagPos"/>
			<dependency name="YSI_g_sINIWriteBuffer"/>
			<dependency name="YSI_g_sINIWriteBuffer"/>
			<dependency name="YSI_g_sINIWritePos"/>
		</member>
		<member name="M:@yH_OnScriptInit@003" syntax="@yH_OnScriptInit@003()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<dependency name="YSI_g_sStack"/>
			<dependency name="YSI_g_sStackPtr"/>
			<remarks>  </remarks> 
		</member>
		<member name="M:@yH_OnScriptInit@004" syntax="@yH_OnScriptInit@004()">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="GetVehicleModel"/>
			<dependency name="IsPlayerConnected"/>
			<dependency name="IsPlayerNPC"/>
			<dependency name="IsValidActor"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_Clear_InternalC"/>
			<dependency name="Iter_Single@Actor"/>
			<dependency name="Iter_Single@Bot"/>
			<dependency name="Iter_Single@Character"/>
			<dependency name="Iter_Single@Player"/>
			<dependency name="Iter_Single@Vehicle"/>
			<dependency name="Iterator@Actor"/>
			<dependency name="Iterator@Bot"/>
			<dependency name="Iterator@Character"/>
			<dependency name="Iterator@Player"/>
			<dependency name="Iterator@Vehicle"/>
			<remarks>  Sets up all existing iterators.  Does nothing for "XXLocal" ones, since they  are by definition empty when a script starts.  </remarks> 
		</member>
		<member name="M:@yH_OnScriptInit@005" syntax="@yH_OnScriptInit@005()">
			<attribute name="public"/>
			<stacksize value="18"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_ReadString"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="Command_Add"/>
			<dependency name="Command_IncOPCP"/>
			<dependency name="Command_IncOPCR"/>
			<dependency name="Debug_Print0"/>
			<dependency name="E_COMMAND_HASH_MAP"/>
			<dependency name="E_COMMAND_POINTER"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="YSI_g_sCommandMap"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_gscOPCP"/>
			<dependency name="YSI_gscOPCR"/>
			<dependency name="_HashMap_Init"/>
			<dependency name="e_COMMAND_FLAGS_OK"/>
			<dependency name="funcidx"/>
			<dependency name="tolower"/>
			<remarks>  Add all local commands in to the system.  </remarks> 
		</member>
		<member name="M:@yH_OnScriptInit@006" syntax="@yH_OnScriptInit@006()">
			<attribute name="public"/>
			<stacksize value="51"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<dependency name="AMX_GetPointerPrefix"/>
			<dependency name="AMX_ReadString"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="SetTimerEx"/>
		</member>
		<member name="M:@yT_GlobalTimer" syntax="@yT_GlobalTimer(g, p)">
			<attribute name="public"/>
			<stacksize value="7"/>
			<dependency name="_Timer_I"/>
			<param name="g">
			</param>
			<param name="p">
			</param>
		</member>
		<member name="M:@yT_VremeDatum" syntax="@yT_VremeDatum(g, p)">
			<attribute name="public"/>
			<stacksize value="7"/>
			<dependency name="_Timer_I"/>
			<param name="g">
			</param>
			<param name="p">
			</param>
		</member>
		<member name="M:AMX_DoNothing" syntax="AMX_DoNothing()">
			<stacksize value="1"/>
			<referrer name="AMX_GetGlobal"/>
		</member>
		<member name="M:AMX_GetBaseCount" syntax="AMX_GetBaseCount(table, &amp;base, &amp;count)">
			<stacksize value="1"/>
			<referrer name="AMX_GetEntry"/>
			<referrer name="AMX_GetEntryPrefix"/>
			<referrer name="AMX_GetEntrySuffix"/>
			<referrer name="AMX_GetName"/>
			<referrer name="AMX_GetNamePrefix"/>
			<referrer name="AMX_GetNameSuffix"/>
			<dependency name="AMX_HEADER_LIBRARIES"/>
			<dependency name="AMX_HEADER_NAMETABLE"/>
			<dependency name="AMX_HEADER_NATIVES"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_HEADER_PUBVARS"/>
			<dependency name="AMX_HEADER_TAGS"/>
			<dependency name="AMX_TABLE_LIBRARIES"/>
			<dependency name="AMX_TABLE_NATIVES"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="AMX_TABLE_PUBVARS"/>
			<dependency name="AMX_TABLE_TAGS"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="base">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:AMX_GetEntry" syntax="AMX_GetEntry(table, idx, &amp;buffer, pattern[], exact)">
			<stacksize value="42"/>
			<referrer name="AMX_GetPointer"/>
			<referrer name="Hooks_GetPreHooks"/>
			<referrer name="Hooks_GetFunctionWritePoint"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<dependency name="AMX_ReadString"/>
			<dependency name="strcmp"/>
			<dependency name="strfind"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="exact">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AMX_GetEntryFromNativeIndex" syntax="AMX_GetEntryFromNativeIndex(index)">
			<stacksize value="1"/>
			<dependency name="AMX_HEADER_NATIVES"/>
			<param name="index">
			</param>
		</member>
		<member name="M:AMX_GetEntryFromPublicIndex" syntax="AMX_GetEntryFromPublicIndex(index)">
			<stacksize value="1"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<param name="index">
			</param>
		</member>
		<member name="M:AMX_GetEntryPointer" syntax="AMX_GetEntryPointer(entry)">
			<stacksize value="1"/>
			<param name="entry">
			</param>
		</member>
		<member name="M:AMX_GetEntryPrefix" syntax="AMX_GetEntryPrefix(table, idx, &amp;buffer, pattern)">
			<stacksize value="9"/>
			<referrer name="AMX_GetPointerPrefix"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_CountInvalidPublics"/>
			<referrer name="Malloc_OnScriptInit"/>
			<referrer name="@yH_OnScriptInit@005"/>
			<referrer name="@yH_OnScriptInit@006"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetEntrySuffix" syntax="AMX_GetEntrySuffix(table, idx, &amp;buffer, pattern)">
			<stacksize value="10"/>
			<referrer name="AMX_GetPointerSuffix"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetGlobal" syntax="AMX_GetGlobal()">
			<stacksize value="4"/>
			<referrer name="Debug_OnScriptInit"/>
			<dependency name="AMX_DoNothing"/>
			<dependency name="AMX_HEADER_COD"/>
		</member>
		<member name="M:AMX_GetGlobalAddress" syntax="AMX_GetGlobalAddress(...)">
			<stacksize value="2"/>
			<dependency name="AMX_REAL_DATA"/>
			<param name="...">
			</param>
		</member>
		<member name="M:AMX_GetName" syntax="AMX_GetName(table, idx, buffer[], pattern[], exact)">
			<stacksize value="10"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<dependency name="AMX_ReadString"/>
			<dependency name="strcmp"/>
			<dependency name="strfind"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> [32] </paraminfo>
			</param>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="exact">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AMX_GetNamePrefix" syntax="AMX_GetNamePrefix(table, idx, buffer[], pattern)">
			<stacksize value="9"/>
			<referrer name="Hooks_DoAllHooks"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<dependency name="AMX_ReadString"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> [32] </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetNameSuffix" syntax="AMX_GetNameSuffix(table, idx, buffer[], pattern)">
			<stacksize value="10"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<dependency name="AMX_ReadString"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> [32] </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetNativeIndexFromEntry" syntax="AMX_GetNativeIndexFromEntry(entry)">
			<stacksize value="1"/>
			<dependency name="AMX_HEADER_NATIVES"/>
			<param name="entry">
			</param>
		</member>
		<member name="M:AMX_GetPointer" syntax="AMX_GetPointer(table, idx, &amp;buffer, pattern[], exact)">
			<stacksize value="9"/>
			<referrer name="AMX_GetValue"/>
			<dependency name="AMX_GetEntry"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="exact">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AMX_GetPointerPrefix" syntax="AMX_GetPointerPrefix(table, idx, &amp;buffer, pattern)">
			<stacksize value="8"/>
			<referrer name="AMX_GetValuePrefix"/>
			<referrer name="_yGICommand"/>
			<referrer name="@yH_OnScriptInit@006"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetPointerSuffix" syntax="AMX_GetPointerSuffix(table, idx, &amp;buffer, pattern)">
			<stacksize value="8"/>
			<referrer name="AMX_GetValueSuffix"/>
			<dependency name="AMX_GetEntrySuffix"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetPublicIndexFromEntry" syntax="AMX_GetPublicIndexFromEntry(entry)">
			<stacksize value="1"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<param name="entry">
			</param>
		</member>
		<member name="M:AMX_GetRelativeAddress" syntax="AMX_GetRelativeAddress(...)">
			<stacksize value="2"/>
			<param name="...">
			</param>
		</member>
		<member name="M:AMX_GetStringFromEntry" syntax="AMX_GetStringFromEntry(entry, str[], size)">
			<stacksize value="6"/>
			<referrer name="Hooks_GetAllHooks"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_ReadString"/>
			<param name="entry">
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:AMX_GetValue" syntax="AMX_GetValue(table, idx, &amp;buffer, pattern[], exact)">
			<stacksize value="9"/>
			<dependency name="AMX_GetPointer"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="exact">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AMX_GetValuePrefix" syntax="AMX_GetValuePrefix(table, idx, &amp;buffer, pattern)">
			<stacksize value="8"/>
			<dependency name="AMX_GetPointerPrefix"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetValueSuffix" syntax="AMX_GetValueSuffix(table, idx, &amp;buffer, pattern)">
			<stacksize value="8"/>
			<dependency name="AMX_GetPointerSuffix"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_OnScriptInit" syntax="AMX_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="9"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_HEADER_DAT"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="Debug_Print0"/>
			<dependency name="Malloc_TrySetup"/>
			<dependency name="OP_BOUNDS"/>
			<dependency name="OP_NOP"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="SetTimer"/>
			<dependency name="cellbits"/>
			<dependency name="heapspace"/>
			<remarks>  Finds all "BOUNDS 0" OpCodes in the AMX and rewrites them to "NOP NOP".  The  byte pattern for this code is "OP_BOUNDS 0", which (AFAIK) can not appear  anywhere else in the DAT segment.  You can have "OP_BOUNDS" as a parameter  to something, but it would then be followed by an OpCode of "0", which is  never valid (OP_NONE).  I've tried to make this as resiliant as possible to being called via  "CallLocalFunction" as not the first callback in the script but there may  still be a few problems - we won't see till people start testing I guess...  </remarks> 
		</member>
		<member name="M:AMX_RawRead" syntax="AMX_RawRead(addr)">
			<stacksize value="1"/>
			<referrer name="AMX_Read"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:AMX_RawWrite" syntax="AMX_RawWrite(addr, value)">
			<stacksize value="1"/>
			<param name="addr">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AMX_Read" syntax="AMX_Read(addr)">
			<stacksize value="50"/>
			<referrer name="AMX_OnScriptInit"/>
			<referrer name="CGen_GetAddr"/>
			<referrer name="GetRemoteFunction"/>
			<referrer name="Callback_Get"/>
			<referrer name="I@E"/>
			<referrer name="StoredF_IsHooked"/>
			<referrer name="StoredF_WritePublicCode"/>
			<referrer name="Remote_WriteJustSpec"/>
			<referrer name="Remote_WriteSpecAndFunc"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GenerateCode"/>
			<referrer name="Hooks_InvalidateName"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_CompareNextCell"/>
			<referrer name="Hooks_ComparePublics"/>
			<referrer name="Hooks_SortPublics"/>
			<referrer name="Malloc_OnScriptInit"/>
			<referrer name="HashMap_RemoveKeyWithHash"/>
			<referrer name="HashMap_GetBranchEnd"/>
			<referrer name="@yH_OnScriptInit@005"/>
			<referrer name="@yH_OnMasterSystemClose@005"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_RawRead"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmEmitLrefSPri"/>
			<dependency name="AsmEmitNop"/>
			<dependency name="AsmEmitPopAlt"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="Debug_Print0"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmDecodeInsn"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmInit"/>
			<dependency name="GetCurrentFrameReturn"/>
			<dependency name="OP_PUSH_C"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:AMX_ReadArray" syntax="AMX_ReadArray(addr, dest[], len)">
			<stacksize value="1"/>
			<param name="addr">
			</param>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:AMX_ReadString" syntax="AMX_ReadString(addr, str[], len)">
			<stacksize value="3"/>
			<referrer name="AMX_GetEntry"/>
			<referrer name="AMX_GetName"/>
			<referrer name="AMX_GetNamePrefix"/>
			<referrer name="AMX_GetNameSuffix"/>
			<referrer name="AMX_GetStringFromEntry"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="@yH_OnScriptInit@005"/>
			<referrer name="@yH_OnScriptInit@006"/>
			<param name="addr">
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:AMX_ReadUnpackedString" syntax="AMX_ReadUnpackedString(addr, str[], len)">
			<stacksize value="2"/>
			<param name="addr">
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:AMX_TraceCode" syntax="AMX_TraceCode(pattern[], &amp;addrRet, &amp;dataRet, size)">
			<stacksize value="4"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_HEADER_DAT"/>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="addrRet">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="dataRet">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:AMX_TraceMemory" syntax="AMX_TraceMemory(pattern[], &amp;addrRet, &amp;dataRet, size)">
			<stacksize value="4"/>
			<dependency name="AMX_HEADER_DAT"/>
			<dependency name="AMX_HEADER_HEA"/>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="addrRet">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="dataRet">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:AMX_Write" syntax="AMX_Write(addr, value)">
			<stacksize value="1"/>
			<referrer name="AMX_OnScriptInit"/>
			<referrer name="CGen_SetupCodeSpace"/>
			<referrer name="I@E"/>
			<referrer name="Inline_OnAsmError"/>
			<referrer name="I@L"/>
			<referrer name="StoredF_WritePublicCode"/>
			<referrer name="Remote_WriteJustSpec"/>
			<referrer name="Remote_WriteSpecAndFunc"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GenerateCode"/>
			<referrer name="Hooks_InvalidateName"/>
			<referrer name="Hooks_ComparePublics"/>
			<referrer name="Hooks_SortPublics"/>
			<referrer name="HashMap_Add"/>
			<referrer name="HashMap_RemoveKeyWithHash"/>
			<param name="addr">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AMX_WriteArray" syntax="AMX_WriteArray(addr, src[], len)">
			<stacksize value="1"/>
			<param name="addr">
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:AMX_WriteString" syntax="AMX_WriteString(addr, str[], len)">
			<stacksize value="4"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<param name="addr">
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:AbsToRel" syntax="AbsToRel(address)">
			<stacksize value="3"/>
			<referrer name="ReadPhysMemory"/>
			<referrer name="WritePhysMemory"/>
			<referrer name="ReadPhysMemoryCell"/>
			<referrer name="WritePhysMemoryCell"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetDat"/>
			<param name="address">
			</param>
		</member>
		<member name="M:AddStaticVehicle" syntax="AddStaticVehicle(modelid, spawn_x, spawn_y, spawn_z, z_angle, color1, color2)">
			<attribute name="native"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<param name="modelid">
			</param>
			<param name="spawn_x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z_angle">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="color1">
			</param>
			<param name="color2">
			</param>
		</member>
		<member name="M:AddStaticVehicleEx" syntax="AddStaticVehicleEx(modelid, spawn_x, spawn_y, spawn_z, z_angle, color1, color2, respawn_delay, addsiren)">
			<attribute name="native"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<param name="modelid">
			</param>
			<param name="spawn_x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z_angle">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="color1">
			</param>
			<param name="color2">
			</param>
			<param name="respawn_delay">
			</param>
			<param name="addsiren">
			</param>
		</member>
		<member name="M:AntiSpawnkill" syntax="AntiSpawnkill(playerid)">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="SendClientMessage"/>
			<dependency name="SetPlayerHealth"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:ApplyAnimation" syntax="ApplyAnimation(playerid, animlib[], animname[], fDelta, loop, lockx, locky, freeze, time, forcesync)">
			<attribute name="native"/>
			<referrer name="@yH_OnPlayerKeyStateChange@015"/>
			<referrer name="@yH_OnPlayerKeyStateChange@016"/>
			<param name="playerid">
			</param>
			<param name="animlib">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="animname">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="fDelta">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="loop">
			</param>
			<param name="lockx">
			</param>
			<param name="locky">
			</param>
			<param name="freeze">
			</param>
			<param name="time">
			</param>
			<param name="forcesync">
			</param>
		</member>
		<member name="M:AsmClearError" syntax="AsmClearError(ctx[])">
			<stacksize value="5"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmSetError"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitAdd" syntax="AsmEmitAdd(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ADD"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitAddC" syntax="AsmEmitAddC(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="bernstein"/>
			<referrer name="Callback_Call"/>
			<referrer name="Callback_Array"/>
			<referrer name="StoredF_WritePublicCode"/>
			<referrer name="Remote_WriteStubCode"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ADD_C"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitAddrAlt" syntax="AsmEmitAddrAlt(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="I@L"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ADDR_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitAddrPri" syntax="AsmEmitAddrPri(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<referrer name="I@L"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ADDR_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitAlignAlt" syntax="AsmEmitAlignAlt(ctx[], number)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ALIGN_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="number">
			</param>
		</member>
		<member name="M:AsmEmitAlignPri" syntax="AsmEmitAlignPri(ctx[], number)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ALIGN_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="number">
			</param>
		</member>
		<member name="M:AsmEmitAnd" syntax="AsmEmitAnd(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="rawMemset"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_AND"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitBounds" syntax="AsmEmitBounds(ctx[], bound)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_BOUNDS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="bound">
			</param>
		</member>
		<member name="M:AsmEmitBreak" syntax="AsmEmitBreak(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_BREAK"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitCall" syntax="AsmEmitCall(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Callback_Array"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_CALL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitCallAbs" syntax="AsmEmitCallAbs(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="24"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="OP_CALL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitCallLabelStringize" syntax="AsmEmitCallLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_CALL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitCell" syntax="AsmEmitCell(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="AsmEmitJumpStringize"/>
			<referrer name="AsmEmitOpcode"/>
			<referrer name="AsmEmitOperand"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="ASM_ERROR_SPACE"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_buffer_size"/>
			<dependency name="AsmRaiseError"/>
			<dependency name="WriteAmxMemory"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitCmps" syntax="AsmEmitCmps(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_CMPS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitConstAlt" syntax="AsmEmitConstAlt(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="bernstein"/>
			<referrer name="rawMemset"/>
			<referrer name="Remote_WriteSpecAndFunc"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_CONST_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitConstPri" syntax="AsmEmitConstPri(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Remote_WriteSpecAndFunc"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_CONST_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitDec" syntax="AsmEmitDec(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_DEC"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitDecAlt" syntax="AsmEmitDecAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_DEC_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitDecI" syntax="AsmEmitDecI(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_DEC_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitDecPri" syntax="AsmEmitDecPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_DEC_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitDecS" syntax="AsmEmitDecS(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_DEC_S"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitEq" syntax="AsmEmitEq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_EQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitEqCAlt" syntax="AsmEmitEqCAlt(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_EQ_C_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitEqCPri" syntax="AsmEmitEqCPri(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_EQ_C_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitFill" syntax="AsmEmitFill(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="rawMemset"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_FILL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitGeq" syntax="AsmEmitGeq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_GEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitGrtr" syntax="AsmEmitGrtr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_GRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitHalt" syntax="AsmEmitHalt(ctx[], code)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_HALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="code">
			</param>
		</member>
		<member name="M:AsmEmitHeap" syntax="AsmEmitHeap(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_HEAP"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitIdxaddr" syntax="AsmEmitIdxaddr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_IDXADDR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitIdxaddrB" syntax="AsmEmitIdxaddrB(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_IDXADDR_B"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitInc" syntax="AsmEmitInc(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INC"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitIncAlt" syntax="AsmEmitIncAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INC_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitIncI" syntax="AsmEmitIncI(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INC_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitIncPri" syntax="AsmEmitIncPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INC_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitIncS" syntax="AsmEmitIncS(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INC_S"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitInstruction" syntax="AsmEmitInstruction(ctx[], opcode, ...)">
			<tagname value="AsmError"/>
			<stacksize value="8"/>
			<referrer name="AsmEmitJumpInstruction"/>
			<referrer name="AsmEmitAdd"/>
			<referrer name="AsmEmitAddC"/>
			<referrer name="AsmEmitAddrAlt"/>
			<referrer name="AsmEmitAddrPri"/>
			<referrer name="AsmEmitAlignAlt"/>
			<referrer name="AsmEmitAlignPri"/>
			<referrer name="AsmEmitAnd"/>
			<referrer name="AsmEmitBounds"/>
			<referrer name="AsmEmitBreak"/>
			<referrer name="AsmEmitCall"/>
			<referrer name="AsmEmitCallAbs"/>
			<referrer name="AsmEmitCmps"/>
			<referrer name="AsmEmitConstAlt"/>
			<referrer name="AsmEmitConstPri"/>
			<referrer name="AsmEmitDec"/>
			<referrer name="AsmEmitDecAlt"/>
			<referrer name="AsmEmitDecI"/>
			<referrer name="AsmEmitDecPri"/>
			<referrer name="AsmEmitDecS"/>
			<referrer name="AsmEmitEq"/>
			<referrer name="AsmEmitEqCAlt"/>
			<referrer name="AsmEmitEqCPri"/>
			<referrer name="AsmEmitFill"/>
			<referrer name="AsmEmitGeq"/>
			<referrer name="AsmEmitGrtr"/>
			<referrer name="AsmEmitHalt"/>
			<referrer name="AsmEmitHeap"/>
			<referrer name="AsmEmitIdxaddr"/>
			<referrer name="AsmEmitIdxaddrB"/>
			<referrer name="AsmEmitInc"/>
			<referrer name="AsmEmitIncAlt"/>
			<referrer name="AsmEmitIncI"/>
			<referrer name="AsmEmitIncPri"/>
			<referrer name="AsmEmitIncS"/>
			<referrer name="AsmEmitInvert"/>
			<referrer name="AsmEmitJeq"/>
			<referrer name="AsmEmitJgeq"/>
			<referrer name="AsmEmitJgrtr"/>
			<referrer name="AsmEmitJleq"/>
			<referrer name="AsmEmitJless"/>
			<referrer name="AsmEmitJneq"/>
			<referrer name="AsmEmitJnz"/>
			<referrer name="AsmEmitJsgeq"/>
			<referrer name="AsmEmitJsgrtr"/>
			<referrer name="AsmEmitJsleq"/>
			<referrer name="AsmEmitJsless"/>
			<referrer name="AsmEmitJump"/>
			<referrer name="AsmEmitJzer"/>
			<referrer name="AsmEmitLctrl"/>
			<referrer name="AsmEmitLeq"/>
			<referrer name="AsmEmitLess"/>
			<referrer name="AsmEmitLidx"/>
			<referrer name="AsmEmitLidxB"/>
			<referrer name="AsmEmitLoadAlt"/>
			<referrer name="AsmEmitLoadPri"/>
			<referrer name="AsmEmitLoad"/>
			<referrer name="AsmEmitLoadI"/>
			<referrer name="AsmEmitLoadSAlt"/>
			<referrer name="AsmEmitLoadSPri"/>
			<referrer name="AsmEmitLodbI"/>
			<referrer name="AsmEmitLrefAlt"/>
			<referrer name="AsmEmitLrefPri"/>
			<referrer name="AsmEmitLrefSAlt"/>
			<referrer name="AsmEmitLrefSPri"/>
			<referrer name="AsmEmitMoveAlt"/>
			<referrer name="AsmEmitMovePri"/>
			<referrer name="AsmEmitMovs"/>
			<referrer name="AsmEmitNeg"/>
			<referrer name="AsmEmitNeq"/>
			<referrer name="AsmEmitNop"/>
			<referrer name="AsmEmitNot"/>
			<referrer name="AsmEmitOr"/>
			<referrer name="AsmEmitPopAlt"/>
			<referrer name="AsmEmitPopPri"/>
			<referrer name="AsmEmitProc"/>
			<referrer name="AsmEmitPushAdr"/>
			<referrer name="AsmEmitPushAlt"/>
			<referrer name="AsmEmitPushC"/>
			<referrer name="AsmEmitPushPri"/>
			<referrer name="AsmEmitPush"/>
			<referrer name="AsmEmitPushS"/>
			<referrer name="AsmEmitRet"/>
			<referrer name="AsmEmitRetn"/>
			<referrer name="AsmEmitSctrl"/>
			<referrer name="AsmEmitSdiv"/>
			<referrer name="AsmEmitSdivAlt"/>
			<referrer name="AsmEmitSgeq"/>
			<referrer name="AsmEmitSgrtr"/>
			<referrer name="AsmEmitShl"/>
			<referrer name="AsmEmitShlCAlt"/>
			<referrer name="AsmEmitShlCPri"/>
			<referrer name="AsmEmitShrCAlt"/>
			<referrer name="AsmEmitShrCPri"/>
			<referrer name="AsmEmitShr"/>
			<referrer name="AsmEmitSignAlt"/>
			<referrer name="AsmEmitSignPri"/>
			<referrer name="AsmEmitSleq"/>
			<referrer name="AsmEmitSless"/>
			<referrer name="AsmEmitSmul"/>
			<referrer name="AsmEmitSmulC"/>
			<referrer name="AsmEmitSshr"/>
			<referrer name="AsmEmitSrefAlt"/>
			<referrer name="AsmEmitSrefPri"/>
			<referrer name="AsmEmitSrefSAlt"/>
			<referrer name="AsmEmitSrefSPri"/>
			<referrer name="AsmEmitStack"/>
			<referrer name="AsmEmitStorAlt"/>
			<referrer name="AsmEmitStorPri"/>
			<referrer name="AsmEmitStorI"/>
			<referrer name="AsmEmitStorSAlt"/>
			<referrer name="AsmEmitStorSPri"/>
			<referrer name="AsmEmitStrbI"/>
			<referrer name="AsmEmitSub"/>
			<referrer name="AsmEmitSubAlt"/>
			<referrer name="AsmEmitSwapAlt"/>
			<referrer name="AsmEmitSwapPri"/>
			<referrer name="AsmEmitSysreqC"/>
			<referrer name="AsmEmitSysreqD"/>
			<referrer name="AsmEmitSysreqPri"/>
			<referrer name="AsmEmitUdiv"/>
			<referrer name="AsmEmitUdivAlt"/>
			<referrer name="AsmEmitUmul"/>
			<referrer name="AsmEmitXchg"/>
			<referrer name="AsmEmitXor"/>
			<referrer name="AsmEmitZero"/>
			<referrer name="AsmEmitZeroAlt"/>
			<referrer name="AsmEmitZeroPri"/>
			<referrer name="AsmEmitZeroS"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmEmitOpcode"/>
			<dependency name="AsmEmitOperand"/>
			<dependency name="gPreviousWriteOffset"/>
			<dependency name="getarg"/>
			<dependency name="numargs"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
			<param name="...">
			</param>
		</member>
		<member name="M:AsmEmitInvert" syntax="AsmEmitInvert(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INVERT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJeq" syntax="AsmEmitJeq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJeqLabelStringize" syntax="AsmEmitJeqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJeqRel" syntax="AsmEmitJeqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJgeq" syntax="AsmEmitJgeq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJgeqLabelStringize" syntax="AsmEmitJgeqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJgeqRel" syntax="AsmEmitJgeqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJgrtr" syntax="AsmEmitJgrtr(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJgrtrLabelStringize" syntax="AsmEmitJgrtrLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJgrtrRel" syntax="AsmEmitJgrtrRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJleq" syntax="AsmEmitJleq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJleqLabelStringize" syntax="AsmEmitJleqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJleqRel" syntax="AsmEmitJleqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJless" syntax="AsmEmitJless(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJlessLabelStringize" syntax="AsmEmitJlessLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJlessRel" syntax="AsmEmitJlessRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJneq" syntax="AsmEmitJneq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JNEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJneqLabelStringize" syntax="AsmEmitJneqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JNEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJneqRel" syntax="AsmEmitJneqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JNEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJnz" syntax="AsmEmitJnz(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JNZ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJnzLabelStringize" syntax="AsmEmitJnzLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JNZ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJnzRel" syntax="AsmEmitJnzRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="bernstein"/>
			<referrer name="Remote_WriteSpecAndFunc"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JNZ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJrel" syntax="AsmEmitJrel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JREL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJrelLabelStringize" syntax="AsmEmitJrelLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JREL"/>
			<dependency name="true"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJsgeq" syntax="AsmEmitJsgeq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JSGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJsgeqLabelStringize" syntax="AsmEmitJsgeqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JSGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJsgeqRel" syntax="AsmEmitJsgeqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JSGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJsgrtr" syntax="AsmEmitJsgrtr(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JSGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJsgrtrLabelStringize" syntax="AsmEmitJsgrtrLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JSGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJsgrtrRel" syntax="AsmEmitJsgrtrRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JSGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJsleq" syntax="AsmEmitJsleq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JSLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJsleqLabelStringize" syntax="AsmEmitJsleqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JSLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJsleqRel" syntax="AsmEmitJsleqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JSLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJsless" syntax="AsmEmitJsless(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JSLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJslessLabelStringize" syntax="AsmEmitJslessLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JSLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJslessRel" syntax="AsmEmitJslessRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JSLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJump" syntax="AsmEmitJump(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="I@E"/>
			<referrer name="Inline_OnAsmError"/>
			<referrer name="StoredF_WritePublicCode"/>
			<referrer name="Remote_WriteStubCode"/>
			<referrer name="Remote_WriteSpecAndFunc"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JUMP"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJumpInstruction" syntax="AsmEmitJumpInstruction(ctx[], opcode, offset)">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<referrer name="AsmEmitJeqRel"/>
			<referrer name="AsmEmitJgeqRel"/>
			<referrer name="AsmEmitJgrtrRel"/>
			<referrer name="AsmEmitJleqRel"/>
			<referrer name="AsmEmitJlessRel"/>
			<referrer name="AsmEmitJneqRel"/>
			<referrer name="AsmEmitJnzRel"/>
			<referrer name="AsmEmitJsgeqRel"/>
			<referrer name="AsmEmitJsgrtrRel"/>
			<referrer name="AsmEmitJsleqRel"/>
			<referrer name="AsmEmitJslessRel"/>
			<referrer name="AsmEmitJumpRel"/>
			<referrer name="AsmEmitJzerRel"/>
			<referrer name="AsmEmitJrel"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="AsmGetJumpAddressFromOffset"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJumpLabelInstruction" syntax="AsmEmitJumpLabelInstruction(ctx[], opcode, label[], relative)">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<referrer name="AsmEmitCallLabelStringize"/>
			<referrer name="AsmEmitJeqLabelStringize"/>
			<referrer name="AsmEmitJgeqLabelStringize"/>
			<referrer name="AsmEmitJgrtrLabelStringize"/>
			<referrer name="AsmEmitJleqLabelStringize"/>
			<referrer name="AsmEmitJlessLabelStringize"/>
			<referrer name="AsmEmitJneqLabelStringize"/>
			<referrer name="AsmEmitJnzLabelStringize"/>
			<referrer name="AsmEmitJsgeqLabelStringize"/>
			<referrer name="AsmEmitJsgrtrLabelStringize"/>
			<referrer name="AsmEmitJsleqLabelStringize"/>
			<referrer name="AsmEmitJslessLabelStringize"/>
			<referrer name="AsmEmitJumpLabelStringize"/>
			<referrer name="AsmEmitJzerLabelStringize"/>
			<referrer name="AsmEmitJrelLabelStringize"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmEmitJumpStringize"/>
			<dependency name="AsmEmitOpcode"/>
			<dependency name="gPreviousWriteOffset"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="relative">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJumpLabelStringize" syntax="AsmEmitJumpLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JUMP"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJumpRel" syntax="AsmEmitJumpRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JUMP"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJumpStringize" syntax="AsmEmitJumpStringize(ctx[], label[], relative)">
			<tagname value="AsmError"/>
			<stacksize value="10"/>
			<referrer name="AsmEmitJumpLabelInstruction"/>
			<dependency name="ASM_ERROR_LABEL_OVERFLOW"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_label_names"/>
			<dependency name="AsmContext_labels"/>
			<dependency name="AsmEmitCell"/>
			<dependency name="AsmFindLabelIndex"/>
			<dependency name="AsmHashLabel"/>
			<dependency name="AsmRaiseError"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="relative">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJzer" syntax="AsmEmitJzer(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JZER"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJzerLabelStringize" syntax="AsmEmitJzerLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JZER"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJzerRel" syntax="AsmEmitJzerRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="bernstein"/>
			<referrer name="CallStoredFunction"/>
			<referrer name="Callback_Call"/>
			<referrer name="Callback_Array"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JZER"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitLabelStringize" syntax="AsmEmitLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="11"/>
			<dependency name="ASM_ERROR_LABEL_DUPLICATE"/>
			<dependency name="ASM_ERROR_LABEL_OVERFLOW"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_label_names"/>
			<dependency name="AsmContext_labels"/>
			<dependency name="AsmFindLabelIndex"/>
			<dependency name="AsmGetJumpAddressFromOffset"/>
			<dependency name="AsmHashLabel"/>
			<dependency name="AsmRaiseError"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="WriteAmxMemory"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitLctrl" syntax="AsmEmitLctrl(ctx[], index)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LCTRL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:AsmEmitLeq" syntax="AsmEmitLeq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitLess" syntax="AsmEmitLess(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitLidx" syntax="AsmEmitLidx(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LIDX"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitLidxB" syntax="AsmEmitLidxB(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LIDX_B"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitLoad" syntax="AsmEmitLoad(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitLoadAlt" syntax="AsmEmitLoadAlt(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitLoadI" syntax="AsmEmitLoadI(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<referrer name="Callback_Call"/>
			<referrer name="Callback_Array"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitLoadPri" syntax="AsmEmitLoadPri(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="rawMemset"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitLoadSAlt" syntax="AsmEmitLoadSAlt(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="rawMemset"/>
			<referrer name="I@L"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_S_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitLoadSPri" syntax="AsmEmitLoadSPri(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="rawMemset"/>
			<referrer name="CallStoredFunction"/>
			<referrer name="Callback_Call"/>
			<referrer name="Callback_Array"/>
			<referrer name="I@L"/>
			<referrer name="Remote_WriteStubCode"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_S_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitLodbI" syntax="AsmEmitLodbI(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LODB_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitLrefAlt" syntax="AsmEmitLrefAlt(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LREF_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitLrefPri" syntax="AsmEmitLrefPri(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LREF_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitLrefSAlt" syntax="AsmEmitLrefSAlt(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="I@L"/>
			<referrer name="StoredF_WritePublicCode"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LREF_S_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitLrefSPri" syntax="AsmEmitLrefSPri(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AMX_Read"/>
			<referrer name="bernstein"/>
			<referrer name="I@L"/>
			<referrer name="Remote_WriteSpecAndFunc"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LREF_S_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitMoveAlt" syntax="AsmEmitMoveAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_MOVE_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitMovePri" syntax="AsmEmitMovePri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_MOVE_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitMovs" syntax="AsmEmitMovs(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Callback_Array"/>
			<referrer name="I@L"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_MOVS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitNeg" syntax="AsmEmitNeg(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Callback_Array"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_NEG"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitNeq" syntax="AsmEmitNeq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_NEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitNop" syntax="AsmEmitNop(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="AMX_Read"/>
			<referrer name="Callback_Array"/>
			<referrer name="Inline_OnAsmError"/>
			<referrer name="I@L"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_NOP"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitNot" syntax="AsmEmitNot(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_NOT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitOpcode" syntax="AsmEmitOpcode(ctx[], opcode)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="AsmEmitInstruction"/>
			<referrer name="AsmEmitJumpLabelInstruction"/>
			<dependency name="ASM_ERROR_OPCODE"/>
			<dependency name="AsmEmitCell"/>
			<dependency name="AsmRaiseError"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="RelocateOpcode"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitOperand" syntax="AsmEmitOperand(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="AsmEmitInstruction"/>
			<dependency name="AsmEmitCell"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitOr" syntax="AsmEmitOr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_OR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPadding" syntax="AsmEmitPadding(ctx[], op)">
			<stacksize value="7"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_buffer_size"/>
			<dependency name="GetOpcodeInstructionParameters"/>
			<dependency name="IsOpcodeValid"/>
			<dependency name="OP_NOP"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="WriteAmxMemory"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="op">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPopAlt" syntax="AsmEmitPopAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="AMX_Read"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<referrer name="StoredF_WritePublicCode"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_POP_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPopArgs" syntax="AsmEmitPopArgs(ctx[], n)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitStack"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="n">
			</param>
		</member>
		<member name="M:AsmEmitPopPri" syntax="AsmEmitPopPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<referrer name="YVA2_CodeGenDeepCleanup"/>
			<referrer name="I@L"/>
			<referrer name="StoredF_WritePublicCode"/>
			<referrer name="Remote_WriteStubCode"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_POP_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitProc" syntax="AsmEmitProc(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<referrer name="rawMemset"/>
			<referrer name="CallStoredFunction"/>
			<referrer name="Callback_Call"/>
			<referrer name="Callback_Array"/>
			<referrer name="I@L"/>
			<referrer name="StoredF_WritePublicCode"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PROC"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPush" syntax="AsmEmitPush(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitPushAdr" syntax="AsmEmitPushAdr(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="I@L"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH_ADR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitPushAlt" syntax="AsmEmitPushAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPushArg" syntax="AsmEmitPushArg(ctx[], n)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitPushS"/>
			<dependency name="AsmGetArgOffset"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="n">
			</param>
		</member>
		<member name="M:AsmEmitPushC" syntax="AsmEmitPushC(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AsmEmitPushNumArgs"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<referrer name="Callback_Array"/>
			<referrer name="I@L"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH_C"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitPushNumArgs" syntax="AsmEmitPushNumArgs(ctx[], n)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitPushC"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="n">
			</param>
		</member>
		<member name="M:AsmEmitPushPri" syntax="AsmEmitPushPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<referrer name="I@L"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPushS" syntax="AsmEmitPushS(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AsmEmitPushArg"/>
			<referrer name="bernstein"/>
			<referrer name="YVA2_CodeGenPushVariable"/>
			<referrer name="Callback_Array"/>
			<referrer name="I@L"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH_S"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitRet" syntax="AsmEmitRet(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_RET"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitRetn" syntax="AsmEmitRetn(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<referrer name="rawMemset"/>
			<referrer name="CallStoredFunction"/>
			<referrer name="Callback_Call"/>
			<referrer name="Callback_Array"/>
			<referrer name="I@L"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_RETN"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSctrl" syntax="AsmEmitSctrl(ctx[], index)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<referrer name="CallStoredFunction"/>
			<referrer name="Callback_Call"/>
			<referrer name="Callback_Array"/>
			<referrer name="Remote_WriteStubCode"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SCTRL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:AsmEmitSdiv" syntax="AsmEmitSdiv(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SDIV"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSdivAlt" syntax="AsmEmitSdivAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SDIV_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSgeq" syntax="AsmEmitSgeq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSgrtr" syntax="AsmEmitSgrtr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitShl" syntax="AsmEmitShl(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitShlCAlt" syntax="AsmEmitShlCAlt(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHL_C_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitShlCPri" syntax="AsmEmitShlCPri(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="rawMemset"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHL_C_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitShr" syntax="AsmEmitShr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitShrCAlt" syntax="AsmEmitShrCAlt(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHR_C_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitShrCPri" syntax="AsmEmitShrCPri(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHR_C_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitSignAlt" syntax="AsmEmitSignAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SIGN_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSignPri" syntax="AsmEmitSignPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SIGN_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSleq" syntax="AsmEmitSleq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSless" syntax="AsmEmitSless(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSmul" syntax="AsmEmitSmul(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SMUL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSmulC" syntax="AsmEmitSmulC(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="bernstein"/>
			<referrer name="Callback_Array"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SMUL_C"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitSrefAlt" syntax="AsmEmitSrefAlt(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SREF_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitSrefPri" syntax="AsmEmitSrefPri(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SREF_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitSrefSAlt" syntax="AsmEmitSrefSAlt(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="I@L"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SREF_S_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitSrefSPri" syntax="AsmEmitSrefSPri(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SREF_S_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitSshr" syntax="AsmEmitSshr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SSHR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitStack" syntax="AsmEmitStack(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AsmEmitPopArgs"/>
			<referrer name="bernstein"/>
			<referrer name="YVA2_CodeGenDeepCleanup"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="Callback_Array"/>
			<referrer name="I@L"/>
			<referrer name="Remote_WriteStubCode"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STACK"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitStorAlt" syntax="AsmEmitStorAlt(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STOR_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitStorI" syntax="AsmEmitStorI(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STOR_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitStorPri" syntax="AsmEmitStorPri(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="rawMemset"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<referrer name="Callback_Array"/>
			<referrer name="Remote_WriteStubCode"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STOR_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitStorSAlt" syntax="AsmEmitStorSAlt(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="StoredF_WritePublicCode"/>
			<referrer name="Remote_WriteStubCode"/>
			<referrer name="Remote_WriteSpecAndFunc"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STOR_S_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitStorSPri" syntax="AsmEmitStorSPri(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="I@L"/>
			<referrer name="StoredF_WritePublicCode"/>
			<referrer name="Remote_WriteStubCode"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STOR_S_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitStrbI" syntax="AsmEmitStrbI(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STRB_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitSub" syntax="AsmEmitSub(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SUB"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSubAlt" syntax="AsmEmitSubAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SUB_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSwapAlt" syntax="AsmEmitSwapAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="StoredF_WritePublicCode"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SWAP_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSwapPri" syntax="AsmEmitSwapPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="StoredF_WritePublicCode"/>
			<referrer name="Remote_WriteStubCode"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SWAP_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSysreq" syntax="AsmEmitSysreq(ctx[], name[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="I@L"/>
			<referrer name="Remote_WriteStubCode"/>
			<dependency name="AsmEmitSysreqC"/>
			<dependency name="GetNativeIndexFromName"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSysreqC" syntax="AsmEmitSysreqC(ctx[], index)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AsmEmitSysreq"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SYSREQ_C"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:AsmEmitSysreqD" syntax="AsmEmitSysreqD(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SYSREQ_D"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitSysreqPri" syntax="AsmEmitSysreqPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SYSREQ_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitUdiv" syntax="AsmEmitUdiv(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_UDIV"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitUdivAlt" syntax="AsmEmitUdivAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_UDIV_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitUmul" syntax="AsmEmitUmul(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_UMUL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitXchg" syntax="AsmEmitXchg(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_XCHG"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitXor" syntax="AsmEmitXor(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_XOR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitZero" syntax="AsmEmitZero(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ZERO"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitZeroAlt" syntax="AsmEmitZeroAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ZERO_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitZeroPri" syntax="AsmEmitZeroPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="I@L"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ZERO_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitZeroS" syntax="AsmEmitZeroS(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="I@L"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ZERO_S"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmFindLabelIndex" syntax="AsmFindLabelIndex(ctx[], hash)">
			<stacksize value="2"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="AsmEmitJumpStringize"/>
			<dependency name="AsmContext_label_names"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="hash">
			</param>
		</member>
		<member name="M:AsmGetArgOffset" syntax="AsmGetArgOffset(n)">
			<stacksize value="1"/>
			<referrer name="AsmEmitPushArg"/>
			<dependency name="ASM_ARGUMENTS_OFFSET"/>
			<param name="n">
			</param>
		</member>
		<member name="M:AsmGetBufferSize" syntax="AsmGetBufferSize(ctx[])">
			<stacksize value="1"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_buffer_size"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmGetCode" syntax="AsmGetCode(ctx[])">
			<stacksize value="21"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="GetAmxHeader"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmGetCodeSize" syntax="AsmGetCodeSize(ctx[])">
			<stacksize value="1"/>
			<referrer name="StoredF_WritePublicCode"/>
			<dependency name="AsmContext_buffer_offset"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmGetError" syntax="AsmGetError(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="1"/>
			<referrer name="Inline_OnAsmError"/>
			<dependency name="AsmContext_error"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmGetErrorHandler" syntax="AsmGetErrorHandler(ctx[])">
			<stacksize value="1"/>
			<dependency name="AsmContext_error_handler"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmGetJumpAddressFromOffset" syntax="AsmGetJumpAddressFromOffset(ctx[], offset)">
			<stacksize value="22"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="AsmEmitJumpInstruction"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmGetPreviousWriteOffset" syntax="AsmGetPreviousWriteOffset()">
			<stacksize value="1"/>
			<referrer name="Inline_OnAsmError"/>
			<dependency name="gPreviousWriteOffset"/>
		</member>
		<member name="M:AsmHashLabel" syntax="AsmHashLabel(label[])">
			<stacksize value="4"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="AsmEmitJumpStringize"/>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmInit" syntax="AsmInit(ctx[], buffer[], size)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="ref"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="buffer">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:AsmInitPtr" syntax="AsmInitPtr(ctx[], buffer, size)">
			<tagname value="AsmError"/>
			<stacksize value="2"/>
			<referrer name="AsmInit"/>
			<referrer name="CodeScanGetFunctionAsm"/>
			<referrer name="CodeScanGetMatchAsm"/>
			<referrer name="AMX_Read"/>
			<referrer name="bernstein"/>
			<referrer name="rawMemset"/>
			<referrer name="CGen_UseCodeSpace"/>
			<referrer name="CallStoredFunction"/>
			<referrer name="Callback_Call"/>
			<referrer name="Callback_Array"/>
			<referrer name="I@E"/>
			<referrer name="I@L"/>
			<referrer name="Remote_WriteStubCode"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_buffer_size"/>
			<dependency name="AsmContext_error_handler"/>
			<dependency name="AsmContext_label_names"/>
			<dependency name="AsmContext_labels"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="buffer">
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:AsmRaiseError" syntax="AsmRaiseError(ctx[], error)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AsmEmitCell"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="AsmEmitJumpStringize"/>
			<referrer name="AsmEmitOpcode"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_error_handler"/>
			<dependency name="AsmSetError"/>
			<dependency name="CallFunction"/>
			<dependency name="ref"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="error">
				<paraminfo>AsmError </paraminfo>
			</param>
		</member>
		<member name="M:AsmSetError" syntax="AsmSetError(ctx[], error)">
			<stacksize value="1"/>
			<referrer name="AsmRaiseError"/>
			<referrer name="AsmClearError"/>
			<dependency name="AsmContext_error"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="error">
				<paraminfo>AsmError </paraminfo>
			</param>
		</member>
		<member name="M:AsmSetErrorHandler" syntax="AsmSetErrorHandler(ctx[], error_handler)">
			<tagname value="AsmError"/>
			<stacksize value="1"/>
			<referrer name="I@L"/>
			<referrer name="StoredF_WritePublicCode"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_error_handler"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="error_handler">
			</param>
		</member>
		<member name="M:AsmSetErrorHandlerName" syntax="AsmSetErrorHandlerName(ctx[], error_handler[])">
			<tagname value="AsmError"/>
			<stacksize value="4"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_error_handler"/>
			<dependency name="GetPublicAddressFromName"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="error_handler">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Attach3DTextLabelToVehicle" syntax="Attach3DTextLabelToVehicle(id, vehicleid, OffsetX, OffsetY, OffsetZ)">
			<attribute name="native"/>
			<referrer name="@_yCstaffvehicle"/>
			<param name="id">
				<paraminfo>Text3D </paraminfo>
			</param>
			<param name="vehicleid">
			</param>
			<param name="OffsetX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="OffsetY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="OffsetZ">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:BCD" syntax="BCD(number)">
			<stacksize value="1"/>
			<param name="number">
			</param>
			<library>sscanf</library>  <remarks>  Converts a version string to  <a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">BCD</a>.  For example:  <code>  BCD(5.6.17);  </code>  Returns:  <code>  0x050617  </code>  Each section (between dots) is assigned a single byte and the last section is  always in the lowest byte.  This implies a maximum of four sections and two  digits per section.  </remarks> 
		</member>
		<member name="M:Bit_Bits" syntax="Bit_Bits(size)">
			<stacksize value="1"/>
			<param name="size">
				Number of bits required.
			</param>
			  <returns>  Number of cells required for the bit array.  </returns> 
		</member>
		<member name="M:Bit_Display" syntax="Bit_Display(array[], size)">
			<stacksize value="141"/>
			<dependency name="Bit_Display"/>
			<dependency name="Cell_ReverseBits"/>
			<dependency name="format"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Bit_FastSet" syntax="Bit_FastSet(array[], slot, set, size)">
			<stacksize value="1"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
				Array of bits.
			</param>
			<param name="slot">
				Bit slot.
			</param>
			<param name="set">
				<paraminfo>bool </paraminfo>
				State to set the slot to.
			</param>
			<param name="size">
				Size of array.
			</param>
			        <remarks>  Exactly the same as "Bit_Set", but as a macro not a function.  native Bit_FastSet(BitArray:array&lt;&gt;, slot, bool:set, size = sizeof (array));  </remarks> 
		</member>
		<member name="M:Bit_Get" syntax="Bit_Get(array[], slot)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
				Array of bits.
			</param>
			<param name="slot">
				Bit slot.
			</param>
			    <param name="size">Size of array.</param>  <returns>  State of the provided slot, 0 on fail.  </returns>  <remarks>  -  native Bit_Get(BitArray:array&lt;&gt;, slot);  </remarks> 
		</member>
		<member name="M:Bit_GetBit" syntax="Bit_GetBit(array[], slot)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
				Array of bits.
			</param>
			<param name="slot">
				Bit slot.
			</param>
			    <returns>  State of the provided slot, 0 on fail.  </returns>  <remarks>  Unsafe but faster for when you're sure you're within range.  </remarks> 
		</member>
		<member name="M:Bit_GetCount" syntax="Bit_GetCount(array[], size)">
			<stacksize value="6"/>
			<dependency name="Cell_CountBits"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
				Array to count.
			</param>
			<param name="size">
				Size of array.
			</param>
			    <returns>  Number of 1s in the array.  </returns>  <remarks>  Code from:  <a href="http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel" />  native Bit_Count(BitArray:array&lt;&gt;, size = sizeof (array));  </remarks> 
		</member>
		<member name="M:Bit_Let" syntax="Bit_Let(array[], slot)">
			<stacksize value="1"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
				Array of bits.
			</param>
			<param name="slot">
				Bit slot.
			</param>
			    <remarks>  Sets the slot to 1.  </remarks> 
		</member>
		<member name="M:Bit_Mask" syntax="Bit_Mask(value)">
			<stacksize value="1"/>
			<param name="value">
				Value to get the mask for
			</param>
			  <returns>  The bit in the array slot to use.  </returns> 
		</member>
		<member name="M:Bit_Set" syntax="Bit_Set(array[], slot, set)">
			<stacksize value="1"/>
			<referrer name="Group_SetCommandNew"/>
			<dependency name="cellbits"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
				Array of bits.
			</param>
			<param name="slot">
				Bit slot.
			</param>
			<param name="set">
				<paraminfo>bool </paraminfo>
				State to set the slot to.
			</param>
			      <param name="size">Size of array.</param> 
		</member>
		<member name="M:Bit_SetAll" syntax="Bit_SetAll(array[], set, size)">
			<stacksize value="6"/>
			<dependency name="memset"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
				Array to set all values of.
			</param>
			<param name="set">
				<paraminfo>bool </paraminfo>
				Wether to set them all 0 or 1.
			</param>
			<param name="size">
				Size of array.
			</param>
			     
		</member>
		<member name="M:Bit_Slot" syntax="Bit_Slot(value)">
			<stacksize value="1"/>
			<param name="value">
				Value to get the slot for.
			</param>
			  <returns>  The true array slot for this value.  </returns> 
		</member>
		<member name="M:Bit_Vet" syntax="Bit_Vet(array[], slot)">
			<stacksize value="1"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
				Array of bits.
			</param>
			<param name="slot">
				Bit slot.
			</param>
			    <remarks>  Sets the slot to 0.  </remarks> 
		</member>
		<member name="M:CGen_AddCodeSpace" syntax="CGen_AddCodeSpace(num)">
			<stacksize value="4"/>
			<referrer name="StoredF_WritePublicCode"/>
			<referrer name="Remote_WriteJustSpec"/>
			<referrer name="Remote_WriteSpecAndFunc"/>
			<referrer name="Hooks_GenerateCode"/>
			<dependency name="Debug_Print0"/>
			<dependency name="YSI_g_sCodeSpace"/>
			<param name="num">
			</param>
		</member>
		<member name="M:CGen_GetAddr" syntax="CGen_GetAddr(func[])">
			<stacksize value="6"/>
			<referrer name="CGen_SetupCodeSpace"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_Read"/>
			<dependency name="funcidx"/>
			<param name="func">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:CGen_GetCodeSpace" syntax="CGen_GetCodeSpace()">
			<stacksize value="3"/>
			<referrer name="StoredF_WritePublicCode"/>
			<referrer name="Remote_WriteJustSpec"/>
			<referrer name="Remote_WriteSpecAndFunc"/>
			<referrer name="Hooks_GenerateCode"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="CGen_SetupCodeSpace"/>
			<dependency name="YSI_g_sCodeSpace"/>
		</member>
		<member name="M:CGen_SetupCodeSpace" syntax="CGen_SetupCodeSpace()">
			<stacksize value="5"/>
			<referrer name="CGen_UseCodeSpace"/>
			<referrer name="CGen_GetCodeSpace"/>
			<dependency name="AMX_Write"/>
			<dependency name="CGen_GetAddr"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_RETN"/>
			<dependency name="OP_ZERO_PRI"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="YSI_g_sCodeEnd"/>
			<dependency name="YSI_g_sCodeSpace"/>
		</member>
		<member name="M:CGen_UseCodeSpace" syntax="CGen_UseCodeSpace(ctx[])">
			<stacksize value="6"/>
			<referrer name="StoredF_WritePublicCode"/>
			<referrer name="Remote_WriteSpecAndFunc"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="CGen_SetupCodeSpace"/>
			<dependency name="YSI_g_sCodeEnd"/>
			<dependency name="YSI_g_sCodeSpace"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:Call" syntax="Call(address, auto_pop)">
			<stacksize value="5"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="address">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:CallFunction" syntax="CallFunction(address, ...)">
			<stacksize value="5"/>
			<referrer name="AsmRaiseError"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<referrer name="Malloc_OnScriptInit"/>
			<param name="address">
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:CallLocalFunction" syntax="CallLocalFunction(function[], format[], ...)">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="HookChain_OnScriptInit"/>
			<referrer name="ScriptInit_OnScriptExit"/>
			<referrer name="@_"/>
			<referrer name="@a"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:CallN" syntax="CallN(address, args_to_push, auto_pop)">
			<stacksize value="6"/>
			<dependency name="cellmin"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="address">
			</param>
			<param name="args_to_push">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:CallNative" syntax="CallNative(index, ...)">
			<stacksize value="8"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<param name="index">
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:CallNativeByAddress" syntax="CallNativeByAddress(address, ...)">
			<stacksize value="8"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<param name="address">
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:CallRemoteFunction" syntax="CallRemoteFunction(function[], format[], ...)">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="_@_y_inline_@_"/>
			<referrer name="HookChain_OnScriptInit"/>
			<referrer name="ScriptInit_OnScriptExit"/>
			<referrer name="@_"/>
			<referrer name="_@_y_distribute_@_"/>
			<referrer name="Distribute_Do"/>
			<referrer name="Distribute_So"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="@a"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:CallStoredFunction" syntax="CallStoredFunction(func, ...)">
			<stacksize value="28"/>
			<referrer name="CallStoredFunction"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmEmitJzerRel"/>
			<dependency name="AsmEmitLoadSPri"/>
			<dependency name="AsmEmitProc"/>
			<dependency name="AsmEmitRetn"/>
			<dependency name="AsmEmitSctrl"/>
			<dependency name="AsmInitPtr"/>
			<param name="func">
				<paraminfo>Function </paraminfo>
				Function pointer to call.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				The function's parameters.
			</param>
			    <remarks>  Call the function in the given pointer with the given parameters.  </remarks> 
		</member>
		<member name="M:Callback_Array" syntax="Callback_Array(func[], params[], num)">
			<stacksize value="28"/>
			<referrer name="Callback_Array"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_REAL_DATA"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmEmitAddC"/>
			<dependency name="AsmEmitCall"/>
			<dependency name="AsmEmitJzerRel"/>
			<dependency name="AsmEmitLoadI"/>
			<dependency name="AsmEmitLoadSPri"/>
			<dependency name="AsmEmitMovs"/>
			<dependency name="AsmEmitNeg"/>
			<dependency name="AsmEmitNop"/>
			<dependency name="AsmEmitProc"/>
			<dependency name="AsmEmitPushC"/>
			<dependency name="AsmEmitPushS"/>
			<dependency name="AsmEmitRetn"/>
			<dependency name="AsmEmitSctrl"/>
			<dependency name="AsmEmitSmulC"/>
			<dependency name="AsmEmitStack"/>
			<dependency name="AsmEmitStorPri"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="Callback_Call"/>
			<param name="func">
				<paraminfo> [5] </paraminfo>
				Info on the function to be called.
			</param>
			<param name="params">
				<paraminfo> [] </paraminfo>
				Array of data pointers.
			</param>
			<param name="num">
				Size of the array.
			</param>
			      <remarks>  This is very similar to Callback_Call, but takes an array of ADDRESSES  instead of normal parameters.  This is designed to help support some  experimental OO code I was working on...  If the target is a public function, the parameters are resolved and passed  normally.  If the target is an inline function we are optimised for the  common case, so move the data on to the stack (currently done value-by-value  not all at once) and call "Callback_Call".  The new assembly is based on "rawMemset" in "y_utils".  </remarks> 
		</member>
		<member name="M:Callback_Call" syntax="Callback_Call(func[], ...)">
			<stacksize value="28"/>
			<referrer name="Callback_Call"/>
			<referrer name="Callback_Array"/>
			<referrer name="INI_ParseFile"/>
			<referrer name="INI_DoParentTag"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmEmitAddC"/>
			<dependency name="AsmEmitJzerRel"/>
			<dependency name="AsmEmitLoadI"/>
			<dependency name="AsmEmitLoadSPri"/>
			<dependency name="AsmEmitProc"/>
			<dependency name="AsmEmitRetn"/>
			<dependency name="AsmEmitSctrl"/>
			<dependency name="AsmInitPtr"/>
			<param name="func">
				<paraminfo> [5] </paraminfo>
				Info on the function to be called.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
			  <remarks>  Takes an inline function handler and parameters, and either calls the  public function while passing through the parameters, or just jumps to the  carefully crafted inline function code.  </remarks> 
		</member>
		<member name="M:Callback_Get" syntax="Callback_Get(name[], ret[], expect[], remote)">
			<tagname value="bool"/>
			<stacksize value="14"/>
			<referrer name="INI_ParseFile"/>
			<dependency name="AMX_Read"/>
			<dependency name="E_CALLBACK_DATA"/>
			<dependency name="E_CALLBACK_DATA_ALLOC"/>
			<dependency name="E_CALLBACK_DATA_FORMAT"/>
			<dependency name="E_CALLBACK_DATA_OFFSET"/>
			<dependency name="E_CALLBACK_DATA_POINTER"/>
			<dependency name="GetCurrentFramePreviousFrame"/>
			<dependency name="GetFrameFunction"/>
			<dependency name="GetFramePreviousFrame"/>
			<dependency name="GetFrameReturn"/>
			<dependency name="GetLocalFunction"/>
			<dependency name="GetRemoteFunction"/>
			<dependency name="Inline_EncodeFormatString"/>
			<dependency name="Inline_Reset"/>
			<dependency name="Malloc_Allocate"/>
			<dependency name="Malloc_Resolve"/>
			<dependency name="YSI_gMallocMemory"/>
			<dependency name="YSI_g_sPrevInlineFunc"/>
			<dependency name="false"/>
			<dependency name="memcpy"/>
			<dependency name="rawMemcpy"/>
			<dependency name="strcmp"/>
			<dependency name="strfind"/>
			<dependency name="strlen"/>
			<dependency name="true"/>
			<param name="name">
				<paraminfo>callback_tag [] </paraminfo>
				Callback to find by name.
			</param>
			<param name="ret">
				<paraminfo> [5] </paraminfo>
				Where to store the pointer.
			</param>
			<param name="expect">
				<paraminfo> [] </paraminfo>
				What parameters the function takes.
			</param>
			<param name="remote">
				<paraminfo>bool </paraminfo>
				Is this function called on one or all scripts?
			</param>
			        <remarks>  Looks up the callback by name.  If the name has the correct data embedded  within it that's great and we use that directly.  Otherwise this function  loops backwards over the callbacks currently in scope (mostly) to the start  of the parent function.  If a match is still not found this looks for a  public function of the same name.  If that isn't found either it gives up.  The new "remote" parameter returns instantly with a remote public function  stub, and no stored data.  </remarks> 
		</member>
		<member name="M:Callback_Release" syntax="Callback_Release(input[])">
			<stacksize value="4"/>
			<referrer name="INI_ParseFile"/>
			<dependency name="E_CALLBACK_DATA_ALLOC"/>
			<dependency name="E_CALLBACK_DATA_POINTER"/>
			<dependency name="Malloc_Free"/>
			<dependency name="YSI_gMallocMemory"/>
			<param name="input">
				<paraminfo> [5] </paraminfo>
				Callback to release.
			</param>
			  <remarks>  Releases all the data associated with a given callback (closure storage).  </remarks> 
		</member>
		<member name="M:Callback_Restore" syntax="Callback_Restore(func[])">
			<stacksize value="9"/>
			<referrer name="INI_ParseFile"/>
			<dependency name="E_CALLBACK_DATA_ALLOC"/>
			<dependency name="E_CALLBACK_DATA_OFFSET"/>
			<dependency name="GetCurrentFramePreviousFrame"/>
			<dependency name="GetFrameParameterSize"/>
			<dependency name="GetFramePreviousFrame"/>
			<dependency name="GetFrameReturn"/>
			<dependency name="SetFramePreviousFrame"/>
			<dependency name="SetFrameReturn"/>
			<dependency name="rawMemcpy"/>
			<param name="func">
				<paraminfo> [5] </paraminfo>
				Info on the restoration function.
			</param>
			  <remarks>  Makes variables referenced, instead of valued.  When used after  "Callback_Call" the values of any variables in the enclosing function that  were modified in the inline function will be propgated so that their new  values are seen by the original parent function (rather than that function  still seeing the original values prior to the inline function modifying  them).  Note that this does no checks at all at the minute - if you call an  inline function whose parent is not currently on the stack, this will  probably fail catastrophically!  </remarks> 
		</member>
		<member name="M:Cell_CompressRight" syntax="Cell_CompressRight(x, m)">
			<stacksize value="12"/>
			<dependency name="Cell_CompressRightPrecomputed"/>
			<dependency name="Cell_PrecomputeMaskPermutation"/>
			<dependency name="Cell_PrecomputeMaskPermutation"/>
			<param name="x">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				The number to compress.
			</param>
			<param name="m">
				The mask for which bits to compress.
			</param>
			<summary>  Cell_CompressRight(GLOBAL_TAG_TYPES:x, m);  </summary>      <returns>  Selected bits from "x", shifted to be LSBs.  </returns>  <remarks>  Doesn't require precomputation.  </remarks> 
		</member>
		<member name="M:Cell_CompressRightPrecomputed" syntax="Cell_CompressRightPrecomputed(x, m, masks[])">
			<stacksize value="2"/>
			<referrer name="Cell_CompressRight"/>
			<param name="x">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				The number to compress.
			</param>
			<param name="m">
				The mask for which bits to compress.
			</param>
			<param name="masks">
				<paraminfo> [5] </paraminfo>
				Precomputed constants for the compression.
			</param>
			<summary>  Cell_CompressRightPrecomputed(GLOBAL_TAG_TYPES:x, m, masks[5]);  </summary>        <returns>  Selected bits from "x", shifted to be LSBs.  </returns>  <remarks>  Very briefly, do "x &amp; m", to select certain bits, then shift those bits  by various amounts so that they are consecutive:  x = 0b110011  m = 0b011010  x &amp; m = 0b010010  From here, because the mask was three bits we know we want just those three  bits in the LSBs, so the answer becomes:  0b000101  Just read this question, it has a diagram:  <a href="http://stackoverflow.com/questions/28282869/shift-masked-bits-to-the-lsb" />  </remarks> 
		</member>
		<member name="M:Cell_CountBits" syntax="Cell_CountBits(data)">
			<stacksize value="1"/>
			<referrer name="Bit_GetCount"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
			<summary>  Cell_CountBits(number);  </summary>  <param name="number">The number to get the number of 1s in.</param>  <returns>  The number of 1s (set bits) in the input.  </returns>  <remarks>  1)  Example: 0  Returns: 0  2)  Example: 1  Returns: 1  3)  Example: 0x01010101  Returns: 4  I rewrote this in assembly just to see if I could pretty much.  I also  rewrote the lookup version in assembly.  In theory it should be faster, but  the marshalling of data was a little awkward.  </remarks> 
		</member>
		<member name="M:Cell_ExpandLeft" syntax="Cell_ExpandLeft(x, m)">
			<stacksize value="12"/>
			<dependency name="Cell_ExpandLeftPrecomputed"/>
			<dependency name="Cell_PrecomputeMaskPermutation"/>
			<dependency name="Cell_PrecomputeMaskPermutation"/>
			<param name="x">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				The number to expand.
			</param>
			<param name="m">
				The mask for which bits to expand to.
			</param>
			<summary>  Cell_ExpandLeft(GLOBAL_TAG_TYPES:x, m)  </summary>      <returns>  LSBs from "x", shifted to selected bit positions.  </returns>  <remarks>  Doesn't require precomputation.  </remarks> 
		</member>
		<member name="M:Cell_ExpandLeftPrecomputed" syntax="Cell_ExpandLeftPrecomputed(x, m, masks[])">
			<stacksize value="2"/>
			<referrer name="Cell_ExpandLeft"/>
			<param name="x">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				The number to expand.
			</param>
			<param name="m">
				The mask for which bits to expand to.
			</param>
			<param name="masks">
				<paraminfo> [5] </paraminfo>
				Precomputed constants for the expansion.
			</param>
			<summary>  Cell_ExpandLeftPrecomputed(GLOBAL_TAG_TYPES:x, m, masks[5])  </summary>        <returns>  LSBs from "x", shifted to selected bit positions.  </returns>  <remarks>  The reverse of "Cell_CompressRightPrecomputed".  Doesn't return exactly the  original number before a compression, just the original number ANDed with  the mask "m".  </remarks> 
		</member>
		<member name="M:Cell_GetLowestBit" syntax="Cell_GetLowestBit(data)">
			<stacksize value="1"/>
			<referrer name="Iter_Func@Bits"/>
			<referrer name="Iter_Func@Blanks"/>
			<referrer name="Iter_Func@PA"/>
			<referrer name="Command_ReProcess"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
			<summary>  Cell_GetLowestBit(number);  </summary>  <param name="number">The number to get the lowest set bit of.</param>  <returns>  The integer position of the lowest set bit.  </returns>  <remarks>  1)  Example: 0b00000000000000000000000000000001  Returns: 0  2)  Example: 0b00000000000000000000000000001000  Returns: 3  3)  Example: 0b00010001100011000011100010001000  Returns: 3  NOTE: This function returns "0" for both numbers with the "1" bit set AND  the number "0", which has NO bits set.  Check that the number is valid  before passing it to this function.  See: <a href="http://supertech.csail.mit.edu/papers/debruijn.pdf" />  </remarks> 
		</member>
		<member name="M:Cell_GetLowestBitEx" syntax="Cell_GetLowestBitEx(data)">
			<stacksize value="1"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
			<summary>  Cell_GetLowestBitEx(number);  </summary>  <param name="number">The number to get the lowest set bit of PLUS ONE.</param>  <returns>  The integer position of the lowest set bit PLUS ONE.  </returns>  <remarks>  This function is identical to "Cell_GetLowestBit", but gives different  results for 0 and non-zero numbers.  The examples below all have a result  one higher than the "Cell_GetLowestBit" function.  1)  Example: 0b00000000000000000000000000000001  Returns: 1  2)  Example: 0b00000000000000000000000000001000  Returns: 4  3)  Example: 0b00010001100011000011100010001000  Returns: 4  4)  Example: 0  Returns: 0  See: <a href="http://supertech.csail.mit.edu/papers/debruijn.pdf" />  </remarks> 
		</member>
		<member name="M:Cell_GetLowestComponent" syntax="Cell_GetLowestComponent(data)">
			<stacksize value="1"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
			<summary>  Cell_GetLowestComponent(number);  </summary>  <param name="number">The number to get the number of 1s in.</param>  <returns>  The lowest set bit.  </returns>  <remarks>  Similar to Cell_GetLowestBit, but returns the bit, not the position of the  bit.  1)  Example: 0b00000000000000000000000000000001  Returns: 0b00000000000000000000000000000001  2)  Example: 0b00000000000000000000000000001000  Returns: 0b00000000000000000000000000001000  3)  Example: 0b00010001100011000011100010001000  Returns: 0b00000000000000000000000000001000  </remarks> 
		</member>
		<member name="M:Cell_PrecomputeMaskPermutation" syntax="Cell_PrecomputeMaskPermutation(m)">
			<stacksize value="10"/>
			<referrer name="Cell_CompressRight"/>
			<referrer name="Cell_ExpandLeft"/>
			<dependency name="Cell_PrecomputeMaskPermutation"/>
			<param name="m">
				The mask.
			</param>
			<summary>  Cell_PrecomputeMaskPermutation(m)  </summary>    <returns>  Five precomputed constants to help expand or contract this mask.  </returns>  <remarks>  The full maths for generalised expansion and contraction is quite complex;  however, much of the inner loop relies only on the mask and not on the value  being manipulated.  Given this we can do a lot of work in advance, say  outside a loop, to avoid repeated calculations.  </remarks> 
		</member>
		<member name="M:Cell_ReverseBits" syntax="Cell_ReverseBits(data)">
			<stacksize value="1"/>
			<referrer name="Bit_Display"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
			<summary>  Cell_ReverseBits(number);  </summary>  <param name="number">The number to manipulate.</param>  <returns>  All the bits in the input reversed.  </returns>  <remarks>  1)  Example: 0b11110000000000000000000000000000  Becomes: 0b00000000000000000000000000001111  2)  Example: 0b10110011100011110000111110000010  Becomes: 0b01000001111100001111000111001101  3)  Example: 0b01010101010101010101010101010101  Becomes: 0b10101010101010101010101010101010  </remarks> 
		</member>
		<member name="M:Cell_ReverseBytes" syntax="Cell_ReverseBytes(data)">
			<stacksize value="1"/>
			<referrer name="Hooks_CompareNextCell"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
			<summary>  Cell_ReverseBytes(number);  </summary>  <param name="number">The number to manipulate.</param>  <returns>  All the bytes in the input reversed.  </returns>  <remarks>  1)  Example: 0x12345678  Becomes: 0x78563412  2)  Example: 0x01020304  Becomes: 0x04030201  3)  Example: 0xFF00FF00  Becomes: 0x00FF00FF  </remarks> 
		</member>
		<member name="M:Cell_ReverseNibbles" syntax="Cell_ReverseNibbles(data)">
			<stacksize value="1"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
			<summary>  Cell_ReverseNibbles(number);  </summary>  <param name="number">The number to manipulate.</param>  <returns>  All the nibbles (4-bit chunks) in the input reversed.  </returns>  <remarks>  1)  Example: 0x12345678  Becomes: 0x87654321  2)  Example: 0x010F0703  Becomes: 0x3070F010  3)  Example: 0xF0F0F0F0  Becomes: 0x0F0F0F0F  </remarks> 
		</member>
		<member name="M:ClearAnimations" syntax="ClearAnimations(playerid, forcesync)">
			<attribute name="native"/>
			<referrer name="Dzampo"/>
			<param name="playerid">
			</param>
			<param name="forcesync">
			</param>
		</member>
		<member name="M:CodeScanAddJumpTarget" syntax="CodeScanAddJumpTarget(cip, stk, hea, jumpTargets[], num)">
			<stacksize value="4"/>
			<referrer name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_jump_heap"/>
			<dependency name="CodeScanner_jump_stack"/>
			<dependency name="CodeScanner_jump_switch"/>
			<dependency name="CodeScanner_jump_target"/>
			<dependency name="CodeScanner_minn"/>
			<dependency name="min"/>
			<param name="cip">
			</param>
			<param name="stk">
			</param>
			<param name="hea">
			</param>
			<param name="jumpTargets">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:CodeScanAddMatcher" syntax="CodeScanAddMatcher(scanner[], searcher[])">
			<stacksize value="4"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="CodeScanner_first"/>
			<dependency name="ref"/>
			<param name="scanner">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="searcher">
				<paraminfo> [171] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanAddSwitchTarget" syntax="CodeScanAddSwitchTarget(dctx[], stk, hea, jumpTargets[], num)">
			<stacksize value="6"/>
			<referrer name="CodeScanStepInternal"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="CodeScanner_jump_heap"/>
			<dependency name="CodeScanner_jump_stack"/>
			<dependency name="CodeScanner_jump_switch"/>
			<dependency name="CodeScanner_jump_target"/>
			<dependency name="CodeScanner_minn"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="UnrelocateOpcode"/>
			<dependency name="cellbits"/>
			<dependency name="gBase"/>
			<dependency name="gHdr"/>
			<dependency name="min"/>
			<param name="dctx">
				<paraminfo> [22] </paraminfo>
			</param>
			<param name="stk">
			</param>
			<param name="hea">
			</param>
			<param name="jumpTargets">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:CodeScanCall" syntax="CodeScanCall(cs[], csState[])">
			<stacksize value="3"/>
			<referrer name="CodeScanRun"/>
			<dependency name="CodeScanMatcher_flags"/>
			<dependency name="CodeScanMatcher_func"/>
			<dependency name="CodeScanMatcher_user_data"/>
			<param name="cs">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="csState">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanCheck" syntax="CodeScanCheck(op, dctx[], cs[], fctx[], &amp;next)">
			<tagname value="bool"/>
			<stacksize value="12"/>
			<referrer name="CodeScanRun"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="CodeScanMatch_holes"/>
			<dependency name="CodeScanMatch_size"/>
			<dependency name="CodeScanMatcher_code"/>
			<dependency name="CodeScanMatcher_flags"/>
			<dependency name="CodeScanMatcher_holeidx"/>
			<dependency name="CodeScanMatcher_holes"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="CodeScanMatcher_offset"/>
			<dependency name="CodeScanMatcher_start"/>
			<dependency name="DisasmGetCurIp"/>
			<dependency name="DisasmGetNextIp"/>
			<dependency name="DisasmGetNumOperands"/>
			<dependency name="DisasmGetOperandReloc"/>
			<dependency name="OP_BOUNDS"/>
			<dependency name="OP_BREAK"/>
			<dependency name="OP_HALT"/>
			<dependency name="OP_NOP"/>
			<dependency name="cellbits"/>
			<dependency name="false"/>
			<dependency name="memcpy"/>
			<dependency name="true"/>
			<param name="op">
				<paraminfo>Opcode </paraminfo>
			</param>
			<param name="dctx">
				<paraminfo> [22] </paraminfo>
			</param>
			<param name="cs">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="fctx">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="next">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanCheckJumpTarget" syntax="CodeScanCheckJumpTarget(cip, deloc, &amp;stk, &amp;hea, jumpTargets[], num)">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<referrer name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_jump_heap"/>
			<dependency name="CodeScanner_jump_stack"/>
			<dependency name="CodeScanner_jump_switch"/>
			<dependency name="CodeScanner_jump_target"/>
			<dependency name="CodeScanner_minn"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="cellbits"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="cip">
			</param>
			<param name="deloc">
			</param>
			<param name="stk">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="hea">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="jumpTargets">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:CodeScanDeref" syntax="CodeScanDeref(v)">
			<stacksize value="1"/>
			<referrer name="CodeScanRun"/>
			<dependency name="CodeScanDeref"/>
			<dependency name="CodeScanMatcher"/>
			<param name="v">
			</param>
		</member>
		<member name="M:CodeScanGetFuncName" syntax="CodeScanGetFuncName(addr, name[])">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<referrer name="CodeScanGetMatchType"/>
			<dependency name="GetPublicIndexFromAddress"/>
			<dependency name="GetPublicNameFromIndex"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="addr">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetFunctionAsm" syntax="CodeScanGetFunctionAsm(csm[], ctx[], offset)">
			<stacksize value="6"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="cellmax"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:CodeScanGetFunctionDisasm" syntax="CodeScanGetFunctionDisasm(csm[], ctx[], offset)">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:CodeScanGetFunctionScanner" syntax="CodeScanGetFunctionScanner(csm[], ret[], ctx[])">
			<stacksize value="4"/>
			<referrer name="CodeScanGetMatchScanner"/>
			<dependency name="CodeScanInit"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="CodeScanMatch_type"/>
			<dependency name="CodeScanner_state"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="ret">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchAddress" syntax="CodeScanGetMatchAddress(csm[])">
			<stacksize value="1"/>
			<referrer name="YVA2_FoundPush"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="gDat"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchAddressData" syntax="CodeScanGetMatchAddressData(csm[])">
			<stacksize value="1"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="CodeScanMatch_cip"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchAsm" syntax="CodeScanGetMatchAsm(csm[], ctx[], offset)">
			<stacksize value="6"/>
			<referrer name="YVA2_FoundPush"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="cellmax"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:CodeScanGetMatchDisasm" syntax="CodeScanGetMatchDisasm(csm[], ctx[], offset)">
			<stacksize value="1"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:CodeScanGetMatchFunc" syntax="CodeScanGetMatchFunc(csm[])">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="gDat"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchFuncData" syntax="CodeScanGetMatchFuncData(csm[])">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_func"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchHeap" syntax="CodeScanGetMatchHeap(csm[])">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_heap"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchHole" syntax="CodeScanGetMatchHole(csm[], idx)">
			<stacksize value="1"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<dependency name="CodeScanMatch_holes"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:CodeScanGetMatchLength" syntax="CodeScanGetMatchLength(csm[])">
			<stacksize value="1"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<dependency name="CodeScanMatch_size"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchName" syntax="CodeScanGetMatchName(csm[], name[])">
			<stacksize value="5"/>
			<dependency name="CodeScanGetMatchType"/>
			<dependency name="CodeScanMatch_name"/>
			<dependency name="CodeScanMatch_type"/>
			<dependency name="strcat"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchScanner" syntax="CodeScanGetMatchScanner(csm[], ret[], ctx[], accurate)">
			<stacksize value="7"/>
			<dependency name="CodeScanGetFunctionScanner"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_param"/>
			<dependency name="CodeScanner_state"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="ret">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
			<param name="accurate">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchStack" syntax="CodeScanGetMatchStack(csm[])">
			<stacksize value="1"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<dependency name="CodeScanMatch_stack"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchType" syntax="CodeScanGetMatchType(csm[])">
			<stacksize value="5"/>
			<referrer name="CodeScanGetMatchName"/>
			<dependency name="CodeScanGetFuncName"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="CodeScanMatch_name"/>
			<dependency name="CodeScanMatch_type"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanInit" syntax="CodeScanInit(scanner[])">
			<stacksize value="5"/>
			<referrer name="CodeScanGetFunctionScanner"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="CodeScanMatch_heap"/>
			<dependency name="CodeScanMatch_name"/>
			<dependency name="CodeScanMatch_params"/>
			<dependency name="CodeScanMatch_stack"/>
			<dependency name="CodeScanMatch_type"/>
			<dependency name="CodeScanResetJumpTargets"/>
			<dependency name="CodeScanner_first"/>
			<dependency name="CodeScanner_param"/>
			<dependency name="CodeScanner_state"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="cellmin"/>
			<dependency name="gBase"/>
			<dependency name="gDat"/>
			<dependency name="gHdr"/>
			<param name="scanner">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanMatcherData" syntax="CodeScanMatcherData(searcher[], val)">
			<stacksize value="1"/>
			<dependency name="CodeScanMatcher_flags"/>
			<dependency name="CodeScanMatcher_user_data"/>
			<param name="searcher">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="val">
			</param>
		</member>
		<member name="M:CodeScanMatcherInit_" syntax="CodeScanMatcherInit_(searcher[], address, flags)">
			<stacksize value="5"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="CodeScanMatcher_flags"/>
			<dependency name="CodeScanMatcher_func"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="CodeScanMatcher_user_data"/>
			<dependency name="CodeScanReset"/>
			<param name="searcher">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="address">
			</param>
			<param name="flags">
			</param>
		</member>
		<member name="M:CodeScanMatcherPattern_" syntax="CodeScanMatcherPattern_(searcher[], ...)">
			<stacksize value="10"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="CodeScanMatcher_code"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="GetOpcodeInstructionParameters"/>
			<dependency name="getarg"/>
			<dependency name="numargs"/>
			<param name="searcher">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Opcode,Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanReset" syntax="CodeScanReset(cs[], &amp;next)">
			<stacksize value="1"/>
			<referrer name="CodeScanMatcherInit_"/>
			<referrer name="CodeScanRun"/>
			<dependency name="CodeScanMatcher_func"/>
			<dependency name="CodeScanMatcher_holeidx"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="CodeScanMatcher_offset"/>
			<param name="cs">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="next">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanResetJumpTargets" syntax="CodeScanResetJumpTargets(jumpTargets[], num)">
			<stacksize value="1"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanInit"/>
			<dependency name="CodeScanner_jump_target"/>
			<dependency name="CodeScanner_minn"/>
			<param name="jumpTargets">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:CodeScanRun" syntax="CodeScanRun(csState[])">
			<tagname value="bool"/>
			<stacksize value="205"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="CodeScanCall"/>
			<dependency name="CodeScanCheck"/>
			<dependency name="CodeScanDeref"/>
			<dependency name="CodeScanDeref"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="CodeScanReset"/>
			<dependency name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_first"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmInit"/>
			<dependency name="true"/>
			<param name="csState">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanStep" syntax="CodeScanStep(dctx[], csState[])">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<dependency name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_param"/>
			<dependency name="CodeScanner_state"/>
			<param name="dctx">
				<paraminfo> [22] </paraminfo>
			</param>
			<param name="csState">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanStepInternal" syntax="CodeScanStepInternal(dctx[], csState[], &amp;parseState, &amp;parseParam)">
			<tagname value="bool"/>
			<stacksize value="13"/>
			<referrer name="CodeScanStep"/>
			<referrer name="CodeScanRun"/>
			<referrer name="CodeScanGetMatchScanner"/>
			<dependency name="CodeScanAddJumpTarget"/>
			<dependency name="CodeScanAddSwitchTarget"/>
			<dependency name="CodeScanCheckJumpTarget"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="CodeScanMatch_heap"/>
			<dependency name="CodeScanMatch_stack"/>
			<dependency name="CodeScanMatch_type"/>
			<dependency name="CodeScanResetJumpTargets"/>
			<dependency name="DISASM_DONE"/>
			<dependency name="DISASM_NOP"/>
			<dependency name="DISASM_OK"/>
			<dependency name="DisasmGetCurIp"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmNext"/>
			<dependency name="OP_ADD_C"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CALL_PRI"/>
			<dependency name="OP_HALT"/>
			<dependency name="OP_HEAP"/>
			<dependency name="OP_JEQ"/>
			<dependency name="OP_JGEQ"/>
			<dependency name="OP_JGRTR"/>
			<dependency name="OP_JLEQ"/>
			<dependency name="OP_JLESS"/>
			<dependency name="OP_JNEQ"/>
			<dependency name="OP_JNZ"/>
			<dependency name="OP_JREL"/>
			<dependency name="OP_JSGEQ"/>
			<dependency name="OP_JSGRTR"/>
			<dependency name="OP_JSLEQ"/>
			<dependency name="OP_JSLESS"/>
			<dependency name="OP_JUMP"/>
			<dependency name="OP_JZER"/>
			<dependency name="OP_LCTRL"/>
			<dependency name="OP_LOAD_PRI"/>
			<dependency name="OP_POP_ALT"/>
			<dependency name="OP_POP_PRI"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_PUSH"/>
			<dependency name="OP_PUSH_ADR"/>
			<dependency name="OP_PUSH_ALT"/>
			<dependency name="OP_PUSH_C"/>
			<dependency name="OP_PUSH_PRI"/>
			<dependency name="OP_PUSH_R"/>
			<dependency name="OP_PUSH_S"/>
			<dependency name="OP_SCTRL"/>
			<dependency name="OP_STACK"/>
			<dependency name="OP_SWITCH"/>
			<dependency name="cellbits"/>
			<dependency name="cellmin"/>
			<dependency name="false"/>
			<dependency name="gBase"/>
			<dependency name="true"/>
			<param name="dctx">
				<paraminfo> [22] </paraminfo>
			</param>
			<param name="csState">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="parseState">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="parseParam">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:Command_Add" syntax="Command_Add(cmd[], ptr)">
			<stacksize value="8"/>
			<automaton name="@_"/>
			<referrer name="@yH_OnScriptInit@005"/>
			<referrer name="Command_Add@"/>
			<dependency name="Command_Find"/>
			<dependency name="Command_GetEmptySlot"/>
			<dependency name="Command_InitialiseFromGroups"/>
			<dependency name="Debug_Print0"/>
			<dependency name="E_COMMAND_POINTER"/>
			<dependency name="E_COMMAND_USERS"/>
			<dependency name="HashMap_Add"/>
			<dependency name="I@"/>
			<dependency name="PA_Init"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="Y@"/>
			<dependency name="YSI_g_sCommandMap"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sHighestID"/>
			<dependency name="YSI_g_sMasterData"/>
			<dependency name="Z@"/>
			<dependency name="_@"/>
			<dependency name="cellmax"/>
			<dependency name="max"/>
			<dependency name="strpack"/>
			<dependency name="true"/>
			<param name="cmd">
				<paraminfo> [] </paraminfo>
				The command name to add.
			</param>
			<param name="ptr">
				The command's pointer.
			</param>
			    <param name="id">Where to store the command (default -1 = find).</param>  <returns>  The command's ID.  </returns>  <remarks>  This was an external API function, but there is no reason for it to be as it  is called for all found commands at mode start.  </remarks> 
		</member>
		<member name="M:Command_Add@" syntax="Command_Add@(cmd[], ptr)">
			<attribute name="public"/>
			<stacksize value="5"/>
			<automaton name="@_"/>
			<dependency name="Command_Add"/>
			<dependency name="X@"/>
			<param name="cmd">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="ptr">
			</param>
		</member>
		<member name="M:Command_AddAlt" syntax="Command_AddAlt(oidx, cmd[])">
			<stacksize value="9"/>
			<automaton name="@_"/>
			<referrer name="Command_AddAlt@"/>
			<referrer name="Command_AddAltNamed"/>
			<dependency name="Command_Find"/>
			<dependency name="Command_GetEmptySlot"/>
			<dependency name="Command_InitialiseFromGroups"/>
			<dependency name="Debug_Print0"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="E_COMMAND_POINTER"/>
			<dependency name="E_COMMAND_USERS"/>
			<dependency name="HashMap_Add"/>
			<dependency name="PA_Init"/>
			<dependency name="Puny_EncodeHash"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandMap"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sHighestID"/>
			<dependency name="YSI_g_sMasterData"/>
			<dependency name="cellmax"/>
			<dependency name="cellmin"/>
			<dependency name="max"/>
			<dependency name="strpack"/>
			<dependency name="true"/>
			<param name="oidx">
				The function this is an alternate to.
			</param>
			<param name="cmd">
				<paraminfo> [] </paraminfo>
				The new name.
			</param>
			    <returns>  The command's ID.  </returns> 
		</member>
		<member name="M:Command_AddAlt@" syntax="Command_AddAlt@(oidx, cmd[])">
			<attribute name="public"/>
			<stacksize value="5"/>
			<automaton name="@_"/>
			<dependency name="Command_AddAlt"/>
			<dependency name="X@"/>
			<param name="oidx">
			</param>
			<param name="cmd">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Command_AddAltNamed" syntax="Command_AddAltNamed(function[], altname[])">
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_AddAltNamed@"/>
			<dependency name="Command_AddAlt"/>
			<dependency name="Command_Find"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
				The function this is an alternate to.
			</param>
			<param name="altname">
				<paraminfo> [] </paraminfo>
				The new name.
			</param>
			    <remarks>  Add an alternate command for an existing command.  native Command_AddAltNamed(function[], altname[]);  </remarks> 
		</member>
		<member name="M:Command_AddAltNamed@" syntax="Command_AddAltNamed@(function[], altname[])">
			<attribute name="public"/>
			<stacksize value="5"/>
			<automaton name="@_"/>
			<dependency name="Command_AddAltNamed"/>
			<dependency name="X@"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="altname">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Command_DecOPCP" syntax="Command_DecOPCP()">
			<stacksize value="4"/>
			<automaton name="@_"/>
			<referrer name="@yH_OnScriptExit@005"/>
			<referrer name="Command_DecOPCP@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="e_COMM_FLAG_OPCP_ADD"/>
		</member>
		<member name="M:Command_DecOPCP@" syntax="Command_DecOPCP@()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="@_"/>
			<dependency name="Command_DecOPCP"/>
		</member>
		<member name="M:Command_DecOPCR" syntax="Command_DecOPCR()">
			<stacksize value="4"/>
			<automaton name="@_"/>
			<referrer name="@yH_OnScriptExit@005"/>
			<referrer name="Command_DecOPCR@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="e_COMM_FLAG_OPCR_ADD"/>
		</member>
		<member name="M:Command_DecOPCR@" syntax="Command_DecOPCR@()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="@_"/>
			<dependency name="Command_DecOPCR"/>
		</member>
		<member name="M:Command_Find" syntax="Command_Find(cmd[])">
			<stacksize value="8"/>
			<automaton name="@_"/>
			<referrer name="Command_GetID"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_GetPlayerNamed"/>
			<referrer name="Command_SetPlayerNamed"/>
			<referrer name="Command_Find@"/>
			<referrer name="Command_TouchNamed"/>
			<referrer name="Command_AddAltNamed"/>
			<referrer name="Command_RemoveNamed"/>
			<referrer name="Command_GetDisplayNamed"/>
			<referrer name="Command_Add"/>
			<dependency name="HashMap_Get"/>
			<dependency name="Puny_EncodeHash"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandMap"/>
			<param name="cmd">
				<paraminfo> [] </paraminfo>
				The command name to find.
			</param>
			  <returns>  The array slot of this command, or -1.  </returns> 
		</member>
		<member name="M:Command_Find@" syntax="Command_Find@(cmd[])">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_Find"/>
			<dependency name="X@"/>
			<param name="cmd">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Command_GetCurrent" syntax="Command_GetCurrent()">
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_GetCurrent@"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCurrentID"/>
			<returns>  The command currently being processed, or "COMMAND_NOT_FOUND".  </returns> 
		</member>
		<member name="M:Command_GetCurrent@" syntax="Command_GetCurrent@()">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_GetCurrent"/>
			<dependency name="X@"/>
		</member>
		<member name="M:Command_GetDeniedReturn" syntax="Command_GetDeniedReturn()">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_GetDeniedReturn@"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="e_COMMAND_FLAGS_DENIED"/>
		</member>
		<member name="M:Command_GetDeniedReturn@" syntax="Command_GetDeniedReturn@()">
			<tagname value="bool"/>
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_GetDeniedReturn"/>
			<dependency name="X@"/>
		</member>
		<member name="M:Command_GetDisconnectReturn" syntax="Command_GetDisconnectReturn()">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_GetDisconnectReturn@"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="e_COMMAND_FLAGS_NO_PLAYER"/>
		</member>
		<member name="M:Command_GetDisconnectReturn@" syntax="Command_GetDisconnectReturn@()">
			<tagname value="bool"/>
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_GetDisconnectReturn"/>
			<dependency name="X@"/>
		</member>
		<member name="M:Command_GetDisplay" syntax="Command_GetDisplay(funcid, playerid)">
			<stacksize value="6"/>
			<automaton name="@_"/>
			<referrer name="Command_GetDisplay@"/>
			<dependency name="Command_GetDisplay"/>
			<dependency name="F@"/>
			<dependency name="Q@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sReturnBuffer"/>
			<dependency name="_Command_GetDisplay"/>
			<param name="funcid">
			</param>
			<param name="playerid">
			</param>
			<param name="f">Command to get the real name of.</param>  <param name="p">Player to get the name for.</param>  <returns>  The name of a command for a single player.  </returns>  <remarks>  Abstracted because there's a crash when chain returning a string from a  foreign function (see "Command_GetDisplayNamed").  native Command_GetDisplay(funcid, playerid);  </remarks> 
		</member>
		<member name="M:Command_GetDisplay@" syntax="Command_GetDisplay@(funcid, playerid)">
			<attribute name="public"/>
			<stacksize value="136"/>
			<automaton name="@_"/>
			<dependency name="Command_GetDisplay"/>
			<dependency name="Command_GetDisplay"/>
			<dependency name="R@"/>
			<param name="funcid">
			</param>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Command_GetDisplayNamed" syntax="Command_GetDisplayNamed(func[], playerid)">
			<stacksize value="6"/>
			<automaton name="@_"/>
			<referrer name="Command_GetDisplayNamed@"/>
			<dependency name="Command_Find"/>
			<dependency name="Command_GetDisplayNamed"/>
			<dependency name="F@"/>
			<dependency name="Q@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sReturnBuffer"/>
			<dependency name="_Command_GetDisplay"/>
			<param name="func">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="playerid">
			</param>
			<param name="f">Command to get the real name of.</param>  <param name="p">Player to get the name for.</param>  <returns>  The name of a named function for one player.  </returns>  <remarks>  Remote function call for Command_GetDisplayNameNamed - avoids needing to  expose users to the master system's odd way of returning strings.  This is  the only part I've not yet fixed up to be nice and hidden.  native string:Command_GetDisplayNamed(string:funcid[], playerid);  </remarks> 
		</member>
		<member name="M:Command_GetDisplayNamed@" syntax="Command_GetDisplayNamed@(func[], playerid)">
			<attribute name="public"/>
			<stacksize value="136"/>
			<automaton name="@_"/>
			<dependency name="Command_GetDisplayNamed"/>
			<dependency name="Command_GetDisplayNamed"/>
			<dependency name="R@"/>
			<param name="func">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Command_GetEmptySlot" syntax="Command_GetEmptySlot()">
			<stacksize value="2"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_Add"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="YSI_g_sCommands"/>
			<returns>  The first available slot in "YSI_g_sCommands".  </returns> 
		</member>
		<member name="M:Command_GetID" syntax="Command_GetID(function[])">
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_GetID@"/>
			<dependency name="Command_Find"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
				Function name to find.
			</param>
			  <returns>  The ID of the passed function.  </returns>  <remarks>  -  native Command_GetID(function[])  </remarks> 
		</member>
		<member name="M:Command_GetID@" syntax="Command_GetID@(function[])">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_GetID"/>
			<dependency name="X@"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Command_GetIllegalReturn" syntax="Command_GetIllegalReturn()">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_GetIllegalReturn@"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="e_COMMAND_FLAGS_INVALID_INPUT"/>
		</member>
		<member name="M:Command_GetIllegalReturn@" syntax="Command_GetIllegalReturn@()">
			<tagname value="bool"/>
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_GetIllegalReturn"/>
			<dependency name="X@"/>
		</member>
		<member name="M:Command_GetName" syntax="Command_GetName(f)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Command_GetName@"/>
			<dependency name="Command_GetName"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="F@"/>
			<dependency name="Q@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sReturnBuffer"/>
			<dependency name="cellmin"/>
			<dependency name="strunpack"/>
			<param name="f">
				Command to get the name of.
			</param>
			  <remarks>  native Command_GetName(funcid);  </remarks> 
		</member>
		<member name="M:Command_GetName@" syntax="Command_GetName@(f)">
			<attribute name="public"/>
			<stacksize value="135"/>
			<automaton name="@_"/>
			<dependency name="Command_GetName"/>
			<dependency name="Command_GetName"/>
			<dependency name="R@"/>
			<param name="f">
			</param>
		</member>
		<member name="M:Command_GetNext" syntax="Command_GetNext(index, playerid)">
			<stacksize value="8"/>
			<automaton name="@_"/>
			<referrer name="Command_GetNext@"/>
			<dependency name="Command_GetNext"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="E_COMMAND_USERS"/>
			<dependency name="F@"/>
			<dependency name="Q@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sHighestID"/>
			<dependency name="YSI_g_sReturnBuffer"/>
			<dependency name="cellbits"/>
			<dependency name="strunpack"/>
			<param name="index">
				Index of the next command for this player.
			</param>
			<param name="playerid">
				Player to get the name for.
			</param>
			    <returns>  The name of a command for a single player.  </returns>  <remarks>  -  native Command_GetNext(index, playerid);  </remarks> 
		</member>
		<member name="M:Command_GetNext@" syntax="Command_GetNext@(index, playerid)">
			<attribute name="public"/>
			<stacksize value="136"/>
			<automaton name="@_"/>
			<dependency name="Command_GetNext"/>
			<dependency name="Command_GetNext"/>
			<dependency name="R@"/>
			<param name="index">
			</param>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Command_GetPlayer" syntax="Command_GetPlayer(cmd, pid)">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_GetPlayer@"/>
			<referrer name="Command_GetPlayerNamed"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="E_COMMAND_USERS"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="cellbits"/>
			<dependency name="cellmin"/>
			<dependency name="false"/>
			<param name="cmd">
			</param>
			<param name="pid">
			</param>
			<param name="command">Command to get for.</param>  <param name="playerid">Player to get.</param>  <returns>  Can this player use this command?  </returns>  <remarks>  native bool:Command_GetPlayer(command, playerid);  </remarks> 
		</member>
		<member name="M:Command_GetPlayer@" syntax="Command_GetPlayer@(cmd, pid)">
			<tagname value="bool"/>
			<attribute name="public"/>
			<stacksize value="5"/>
			<automaton name="@_"/>
			<dependency name="Command_GetPlayer"/>
			<dependency name="X@"/>
			<param name="cmd">
			</param>
			<param name="pid">
			</param>
		</member>
		<member name="M:Command_GetPlayerCommandCount" syntax="Command_GetPlayerCommandCount(playerid)">
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_GetPlayerCommandCount@"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="E_COMMAND_USERS"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sHighestID"/>
			<dependency name="cellbits"/>
			<param name="playerid">
				Player to count for.
			</param>
			  <remarks>  Gets the number of comamnds this player can use.  native Command_GetPlayerCommandCount(playerid);  </remarks> 
		</member>
		<member name="M:Command_GetPlayerCommandCount@" syntax="Command_GetPlayerCommandCount@(playerid)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_GetPlayerCommandCount"/>
			<dependency name="X@"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Command_GetPlayerDisabled" syntax="Command_GetPlayerDisabled(playerid)">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_GetPlayerDisabled@"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sDisabledPlayers"/>
			<dependency name="cellbits"/>
			<param name="playerid">
				Player to get.
			</param>
			  <returns>  Can this player use any commands?  </returns> 
		</member>
		<member name="M:Command_GetPlayerDisabled@" syntax="Command_GetPlayerDisabled@(playerid)">
			<tagname value="bool"/>
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_GetPlayerDisabled"/>
			<dependency name="X@"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Command_GetPlayerNamed" syntax="Command_GetPlayerNamed(func[], playerid)">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_GetPlayerNamed@"/>
			<dependency name="Command_Find"/>
			<dependency name="Command_GetPlayer"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<param name="func">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="playerid">
				Player to get.
			</param>
			<param name="funcname">Command to get for.</param>    <remarks>  Like Command_GetPlayer but for a function name.  native bool:Command_GetPlayerNamed(funcname[], playerid);  </remarks> 
		</member>
		<member name="M:Command_GetPlayerNamed@" syntax="Command_GetPlayerNamed@(func[], playerid)">
			<tagname value="bool"/>
			<attribute name="public"/>
			<stacksize value="5"/>
			<automaton name="@_"/>
			<dependency name="Command_GetPlayerNamed"/>
			<dependency name="X@"/>
			<param name="func">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Command_GetUnknownReturn" syntax="Command_GetUnknownReturn()">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_GetUnknownReturn@"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="e_COMMAND_FLAGS_NOT_FOUND"/>
		</member>
		<member name="M:Command_GetUnknownReturn@" syntax="Command_GetUnknownReturn@()">
			<tagname value="bool"/>
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_GetUnknownReturn"/>
			<dependency name="X@"/>
		</member>
		<member name="M:Command_IncOPCP" syntax="Command_IncOPCP()">
			<stacksize value="4"/>
			<automaton name="@_"/>
			<referrer name="@yH_OnScriptInit@005"/>
			<referrer name="Command_IncOPCP@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="e_COMM_FLAG_OPCP_ADD"/>
		</member>
		<member name="M:Command_IncOPCP@" syntax="Command_IncOPCP@()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="@_"/>
			<dependency name="Command_IncOPCP"/>
		</member>
		<member name="M:Command_IncOPCR" syntax="Command_IncOPCR()">
			<stacksize value="4"/>
			<automaton name="@_"/>
			<referrer name="@yH_OnScriptInit@005"/>
			<referrer name="Command_IncOPCR@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="e_COMM_FLAG_OPCR_ADD"/>
			<remarks>  This function, and the three other related ones, increment and decrement the  number of callbacks known to exist on the server.  If they are 0, there's no  point trying to call them on errors etc.  </remarks> 
		</member>
		<member name="M:Command_IncOPCR@" syntax="Command_IncOPCR@()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="@_"/>
			<dependency name="Command_IncOPCR"/>
		</member>
		<member name="M:Command_InitialiseFromGroups" syntax="Command_InitialiseFromGroups(x)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="Group_ExclusiveCommand"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_TouchNamed"/>
			<referrer name="Command_Touch"/>
			<referrer name="Command_Add"/>
			<dependency name="false"/>
			<param name="x">
				The element that was added (maybe).
			</param>
			  <remarks>  The name is a macro, so this function isn't actually called this.  This is  called when a new element is created, and as such it is NOT chained to other  parts of the groups system because each part handles one type of element.  Loop through all players and set up the element for them if they are in a  group that this is also in by default.  If x is "_GROUP_MAKE_LIMIT" then this is the test used in OnPlayerConnect in  various libraries to see if the groups system exists, and if not locally  initialise the player instead of leaving it up to this system.  </remarks> 
		</member>
		<member name="M:Command_IsValid" syntax="Command_IsValid(cmd)">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_IsValid@"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="cellmin"/>
			<param name="cmd">
			</param>
			<param name="command">Command to get for.</param>  <returns>  Is this command ID valid?  </returns> 
		</member>
		<member name="M:Command_IsValid@" syntax="Command_IsValid@(cmd)">
			<tagname value="bool"/>
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_IsValid"/>
			<dependency name="X@"/>
			<param name="cmd">
			</param>
		</member>
		<member name="M:Command_Name" syntax="Command_Name(f)">
			<stacksize value="1"/>
			<param name="f">
				Command to get the name of.
			</param>
			 
		</member>
		<member name="M:Command_ReProcess" syntax="Command_ReProcess(p, c[], h)">
			<stacksize value="11"/>
			<automaton name="@_"/>
			<referrer name="Command_ReProcess@"/>
			<referrer name="@yH_OnPlayerText@005"/>
			<referrer name="@yH_OnPlayerCommandText@005"/>
			<dependency name="COMMAND_DENIED"/>
			<dependency name="COMMAND_DISABLED"/>
			<dependency name="COMMAND_INVALID_INPUT"/>
			<dependency name="COMMAND_NO_PLAYER"/>
			<dependency name="COMMAND_OK"/>
			<dependency name="COMMAND_UNDEFINED"/>
			<dependency name="CallRemoteFunction"/>
			<dependency name="Cell_GetLowestBit"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="E_COMMAND_POINTER"/>
			<dependency name="E_COMMAND_USERS"/>
			<dependency name="HashMap_GetWithHash"/>
			<dependency name="IsPlayerConnected"/>
			<dependency name="NULL"/>
			<dependency name="Puny_EncodeHash"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="YSI_g_sCommandMap"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sCurrentID"/>
			<dependency name="YSI_g_sDisabledPlayers"/>
			<dependency name="YSI_g_sMasterData"/>
			<dependency name="YSI_gscISI"/>
			<dependency name="YSI_gscISII"/>
			<dependency name="YSI_gscOPCP"/>
			<dependency name="YSI_gscOPCR"/>
			<dependency name="_@"/>
			<dependency name="cellbits"/>
			<dependency name="cellmin"/>
			<dependency name="e_COMM_FLAG_OPCP"/>
			<dependency name="e_COMM_FLAG_OPCR"/>
			<dependency name="getproperty"/>
			<dependency name="strunpack"/>
			<param name="p">
				(playerid) - Player who entered the command.
			</param>
			<param name="c">
				<paraminfo> [] </paraminfo>
				(cmdtext) - Text entered.
			</param>
			<param name="h">
				1 - Called from the help commmand or OnPlayerCommandText.  2 - Bypass permissions checks.  
			</param>
			      <returns>  true - success or hidden fail.  false - fail.  </returns>  <remarks>  Does all the command and error handling.  The macro version takes four  parameters:  <code>Command_ReProcess(playerid,cmdtext,help,force);</code>  <c>help</c> and <c>force</c> are combined together in to a bitmap.  </remarks> 
		</member>
		<member name="M:Command_ReProcess@" syntax="Command_ReProcess@(p, c[], h)">
			<attribute name="public"/>
			<stacksize value="6"/>
			<automaton name="@_"/>
			<dependency name="Command_ReProcess"/>
			<dependency name="X@"/>
			<param name="p">
			</param>
			<param name="c">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="h">
			</param>
		</member>
		<member name="M:Command_Remove" syntax="Command_Remove(func)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Command_Remove@"/>
			<referrer name="Command_RemoveNamed"/>
			<referrer name="@yH_OnMasterSystemClose@005"/>
			<dependency name="E_COMMAND_POINTER"/>
			<dependency name="HashMap_RemoveValue"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandMap"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sCommands"/>
			<param name="func">
				The slot of the command to remove.
			</param>
			  <remarks>  native Command_Remove(func);  </remarks> 
		</member>
		<member name="M:Command_Remove@" syntax="Command_Remove@(func)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_Remove"/>
			<param name="func">
			</param>
		</member>
		<member name="M:Command_RemoveNamed" syntax="Command_RemoveNamed(func[])">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Command_RemoveNamed@"/>
			<dependency name="Command_Find"/>
			<dependency name="Command_Remove"/>
			<dependency name="W@"/>
			<param name="func">
				<paraminfo> [] </paraminfo>
				The name of the command to remove.
			</param>
			  <remarks>  native Command_RemoveNamed(string:func[]);  </remarks> 
		</member>
		<member name="M:Command_RemoveNamed@" syntax="Command_RemoveNamed@(func[])">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_RemoveNamed"/>
			<param name="func">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Command_SetDeniedReturn" syntax="Command_SetDeniedReturn(set)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Command_SetDeniedReturn@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="e_COMMAND_FLAGS_DENIED"/>
			<param name="set">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Command_SetDeniedReturn@" syntax="Command_SetDeniedReturn@(set)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_SetDeniedReturn"/>
			<param name="set">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Command_SetDisconnectReturn" syntax="Command_SetDisconnectReturn(set)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Command_SetDisconnectReturn@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="e_COMMAND_FLAGS_NO_PLAYER"/>
			<param name="set">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Command_SetDisconnectReturn@" syntax="Command_SetDisconnectReturn@(set)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_SetDisconnectReturn"/>
			<param name="set">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Command_SetIllegalReturn" syntax="Command_SetIllegalReturn(set)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Command_SetIllegalReturn@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="e_COMMAND_FLAGS_INVALID_INPUT"/>
			<param name="set">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Command_SetIllegalReturn@" syntax="Command_SetIllegalReturn@(set)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_SetIllegalReturn"/>
			<param name="set">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Command_SetPlayer" syntax="Command_SetPlayer(c, p, s)">
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Group_FullPlayerUpdate"/>
			<referrer name="_Group_IncludeAll_1"/>
			<referrer name="Command_SetPlayer@"/>
			<referrer name="Command_SetPlayerNamed"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="E_COMMAND_USERS"/>
			<dependency name="PA_Set"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="cellmin"/>
			<param name="c">
			</param>
			<param name="p">
			</param>
			<param name="s">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="command">Command to set for.</param>  <param name="playerid">Player to set.</param>  <param name="set">Wether or not this player can use this command.</param>  <remarks>  native bool:Command_SetPlayer(command, playerid, bool:set);  </remarks> 
		</member>
		<member name="M:Command_SetPlayer@" syntax="Command_SetPlayer@(c, p, s)">
			<attribute name="public"/>
			<stacksize value="6"/>
			<automaton name="@_"/>
			<dependency name="Command_SetPlayer"/>
			<param name="c">
			</param>
			<param name="p">
			</param>
			<param name="s">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Command_SetPlayerDisabled" syntax="Command_SetPlayerDisabled(playerid, set)">
			<stacksize value="6"/>
			<automaton name="@_"/>
			<referrer name="Command_SetPlayerDisabled@"/>
			<dependency name="PA_Set"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sDisabledPlayers"/>
			<param name="playerid">
				Player to set.
			</param>
			<param name="set">
				<paraminfo>bool </paraminfo>
				Can they use any commands at all.
			</param>
			    <remarks>  Enables or disables using commands for this player.  Enabling commands does  not enable ALL commands, just allows them to use the ones for which they  have otherwise set permissions.  Disabling prevents them from using ANY  commands at all (though this can be overridden by returning `COMMAND_OK` in  `OnPlayerCommandReceived`).  </remarks> 
		</member>
		<member name="M:Command_SetPlayerDisabled@" syntax="Command_SetPlayerDisabled@(playerid, set)">
			<attribute name="public"/>
			<stacksize value="5"/>
			<automaton name="@_"/>
			<dependency name="Command_SetPlayerDisabled"/>
			<param name="playerid">
			</param>
			<param name="set">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Command_SetPlayerNamed" syntax="Command_SetPlayerNamed(f[], p, s)">
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_SetPlayerNamed@"/>
			<dependency name="Command_Find"/>
			<dependency name="Command_SetPlayer"/>
			<dependency name="W@"/>
			<param name="f">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="p">
			</param>
			<param name="s">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="funcname">Command to set for.</param>  <param name="playerid">Player to set.</param>  <param name="set">Wether or not this player can use this command.</param>  <remarks>  Like Command_SetPlayer but for a function name.  native bool:Command_SetPlayerNamed(funcname[], playerid, bool:set);  </remarks> 
		</member>
		<member name="M:Command_SetPlayerNamed@" syntax="Command_SetPlayerNamed@(f[], p, s)">
			<attribute name="public"/>
			<stacksize value="6"/>
			<automaton name="@_"/>
			<dependency name="Command_SetPlayerNamed"/>
			<param name="f">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="p">
			</param>
			<param name="s">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Command_SetUnknownReturn" syntax="Command_SetUnknownReturn(set)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Command_SetUnknownReturn@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="e_COMMAND_FLAGS_NOT_FOUND"/>
			<param name="set">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Command_SetUnknownReturn@" syntax="Command_SetUnknownReturn@(set)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_SetUnknownReturn"/>
			<param name="set">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Command_Touch" syntax="Command_Touch(command)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Command_Touch@"/>
			<dependency name="Command_InitialiseFromGroups"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="cellmin"/>
			<param name="command">
				Command to "touch".
			</param>
			  <remarks>  Used within "GROUP_ADD" to quickly assign a load of commands to just one  group.  </remarks> 
		</member>
		<member name="M:Command_Touch@" syntax="Command_Touch@(command)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_Touch"/>
			<param name="command">
			</param>
		</member>
		<member name="M:Command_TouchNamed" syntax="Command_TouchNamed(command[])">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Command_TouchNamed@"/>
			<dependency name="Command_Find"/>
			<dependency name="Command_InitialiseFromGroups"/>
			<dependency name="W@"/>
			<param name="command">
				<paraminfo> [] </paraminfo>
				Command to "touch".
			</param>
			  <remarks>  Used within "GROUP_ADD" to quickly assign a load of commands to just one  group.  </remarks> 
		</member>
		<member name="M:Command_TouchNamed@" syntax="Command_TouchNamed@(command[])">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_TouchNamed"/>
			<param name="command">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Create3DTextLabel" syntax="Create3DTextLabel(text[], color, X, Y, Z, DrawDistance, virtualworld, testLOS)">
			<tagname value="Text3D"/>
			<attribute name="native"/>
			<referrer name="Ucitaj_TextLabel"/>
			<referrer name="@_yCstaffvehicle"/>
			<param name="text">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="color">
			</param>
			<param name="X">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="Y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="Z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="DrawDistance">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="virtualworld">
			</param>
			<param name="testLOS">
			</param>
		</member>
		<member name="M:CreateActor" syntax="CreateActor(modelid, X, Y, Z, Rotation)">
			<attribute name="native"/>
			<referrer name="Iter_CreateActor"/>
			<param name="modelid">
				The model ID (skin ID) the actor should have
			</param>
			<param name="X">
				<paraminfo>Float </paraminfo>
				The X coordinate to create the actor at
			</param>
			<param name="Y">
				<paraminfo>Float </paraminfo>
				The Y coordinate to create the actor at
			</param>
			<param name="Z">
				<paraminfo>Float </paraminfo>
				The Z coordinate to create the actor at
			</param>
			<param name="Rotation">
				<paraminfo>Float </paraminfo>
				The facing angle (rotation) for the actor to have
			</param>
			<summary>Create a static 'actor' in the world. These 'actors' are like NPCs, however they have limited functionality. They do not take up server player slots.</summary>      <seealso name="DestroyActor"/> <seealso name="SetActorPos"/> <seealso name="GetActorPos"/> <seealso name="SetActorFacingAngle"/> <seealso name="GetActorFacingAngle"/> <seealso name="SetActorVirtualWorld"/> <seealso name="GetActorVirtualWorld"/> <seealso name="ApplyActorAnimation"/> <seealso name="ClearActorAnimations"/> <seealso name="GetPlayerCameraTargetActor"/> <seealso name="IsActorStreamedIn"/> <seealso name="SetActorHealth"/> <seealso name="GetActorHealth"/> <seealso name="SetActorInvulnerable"/> <seealso name="IsActorInvulnerable"/> <seealso name="IsValidActor"/> <seealso name="GetActorPoolSize"/> <seealso name="GetPlayerTargetActor"/> <seealso name="OnActorStreamIn"/> <seealso name="OnActorStreamOut"/> <seealso name="OnPlayerGiveDamageActor"/> <remarks>This function was added in <b>SA-MP 0.3.7</b> and will not work in earlier versions!</remarks> <remarks> Actors are completely separate from NPCs. They do NOT use player IDs/slots on the server and CANNOT be handled like NPCs.<p/> Actors are limited to <b><c>1000</c></b> (<b><c>MAX_ACTORS</c></b>).<p/> Actors can be pushed by vehicles, use a timer to put them back at their positions.<p/> As of <b>0.3.7 R2</b> actors default to being <a href="http://wiki.sa-mp.com/wiki/SetActorInvulnerable">invulnerable</a>. </remarks> <returns> The created Actor ID (start at <b><c>0</c></b>).<p/> <b><c>INVALID_ACTOR_ID</c></b> (<b><c>65535</c></b>) If the actor limit (<b><c>1000</c></b>) is reached. </returns>
		</member>
		<member name="M:CreateDynamic3DTextLabel" syntax="CreateDynamic3DTextLabel(text[], color, x, y, z, drawdistance, attachedplayer, attachedvehicle, testlos, worldid, interiorid, playerid, streamdistance, areaid, priority)">
			<tagname value="Text3D"/>
			<attribute name="native"/>
			<referrer name="Ucitaj_TextLabel"/>
			<param name="text">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="color">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="drawdistance">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="attachedplayer">
			</param>
			<param name="attachedvehicle">
			</param>
			<param name="testlos">
			</param>
			<param name="worldid">
			</param>
			<param name="interiorid">
			</param>
			<param name="playerid">
			</param>
			<param name="streamdistance">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="areaid">
			</param>
			<param name="priority">
			</param>
		</member>
		<member name="M:CreateDynamicObject" syntax="CreateDynamicObject(modelid, x, y, z, rx, ry, rz, worldid, interiorid, playerid, streamdistance, drawdistance, areaid, priority)">
			<attribute name="native"/>
			<referrer name="KreirajObjekte"/>
			<param name="modelid">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="rx">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="ry">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="rz">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="worldid">
			</param>
			<param name="interiorid">
			</param>
			<param name="playerid">
			</param>
			<param name="streamdistance">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="drawdistance">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="areaid">
			</param>
			<param name="priority">
			</param>
		</member>
		<member name="M:CreateDynamicObjectEx" syntax="CreateDynamicObjectEx(modelid, x, y, z, rx, ry, rz, streamdistance, drawdistance, worlds[], interiors[], players[], areas[], priority, maxworlds, maxinteriors, maxplayers, maxareas)">
			<attribute name="native"/>
			<referrer name="KreirajObjekte"/>
			<param name="modelid">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="rx">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="ry">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="rz">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="streamdistance">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="drawdistance">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="worlds">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="interiors">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="players">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="areas">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="priority">
			</param>
			<param name="maxworlds">
			</param>
			<param name="maxinteriors">
			</param>
			<param name="maxplayers">
			</param>
			<param name="maxareas">
			</param>
		</member>
		<member name="M:CreateDynamicPickup" syntax="CreateDynamicPickup(modelid, type, x, y, z, worldid, interiorid, playerid, streamdistance, areaid, priority)">
			<attribute name="native"/>
			<referrer name="Ucitaj_Pickups"/>
			<param name="modelid">
			</param>
			<param name="type">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="worldid">
			</param>
			<param name="interiorid">
			</param>
			<param name="playerid">
			</param>
			<param name="streamdistance">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="areaid">
			</param>
			<param name="priority">
			</param>
		</member>
		<member name="M:CreateGTextDraws" syntax="CreateGTextDraws()">
			<stacksize value="5"/>
			<referrer name="SSCANF_OnGameModeInit"/>
			<dependency name="TextDrawAlignment"/>
			<dependency name="TextDrawBackgroundColor"/>
			<dependency name="TextDrawColor"/>
			<dependency name="TextDrawCreate"/>
			<dependency name="TextDrawFont"/>
			<dependency name="TextDrawLetterSize"/>
			<dependency name="TextDrawSetProportional"/>
			<dependency name="TextDrawSetShadow"/>
			<dependency name="fortz_ptd"/>
		</member>
		<member name="M:CreateObject" syntax="CreateObject(modelid, X, Y, Z, rX, rY, rZ, DrawDistance)">
			<attribute name="native"/>
			<referrer name="KreirajObjekte"/>
			<param name="modelid">
			</param>
			<param name="X">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="Y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="Z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="rX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="rY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="rZ">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="DrawDistance">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:CreatePTextDraws" syntax="CreatePTextDraws(playerid)">
			<stacksize value="6"/>
			<referrer name="@yH_OnPlayerSpawn@019"/>
			<dependency name="CreatePlayerTextDraw"/>
			<dependency name="Ingame_PTD"/>
			<dependency name="Ingame_PTD"/>
			<dependency name="PlayerTextDrawAlignment"/>
			<dependency name="PlayerTextDrawBackgroundColor"/>
			<dependency name="PlayerTextDrawColor"/>
			<dependency name="PlayerTextDrawFont"/>
			<dependency name="PlayerTextDrawLetterSize"/>
			<dependency name="PlayerTextDrawSetProportional"/>
			<dependency name="PlayerTextDrawSetShadow"/>
			<dependency name="PlayerTextDrawTextSize"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:CreatePickup" syntax="CreatePickup(model, type, X, Y, Z, virtualworld)">
			<attribute name="native"/>
			<referrer name="Ucitaj_Pickups"/>
			<param name="model">
			</param>
			<param name="type">
			</param>
			<param name="X">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="Y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="Z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="virtualworld">
			</param>
		</member>
		<member name="M:CreatePlayerTextDraw" syntax="CreatePlayerTextDraw(playerid, x, y, text[])">
			<tagname value="PlayerText"/>
			<attribute name="native"/>
			<referrer name="va_CreatePlayerTextDraw"/>
			<referrer name="CreatePTextDraws"/>
			<param name="playerid">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="text">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:CreateVehicle" syntax="CreateVehicle(vehicletype, x, y, z, rotation, color1, color2, respawn_delay, addsiren)">
			<attribute name="native"/>
			<referrer name="Iter_CreateVehicle"/>
			<param name="vehicletype">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="rotation">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="color1">
			</param>
			<param name="color2">
			</param>
			<param name="respawn_delay">
			</param>
			<param name="addsiren">
			</param>
		</member>
		<member name="M:DajIgracuNovac" syntax="DajIgracuNovac(playerid, novac)">
			<stacksize value="4"/>
			<referrer name="@_yCdajnovac"/>
			<referrer name="@yH_OnDialogResponse@029"/>
			<dependency name="GivePlayerMoney"/>
			<dependency name="PlayerInfo"/>
			<dependency name="PlayerInfo"/>
			<dependency name="ResetPlayerMoney"/>
			<dependency name="SacuvajKorisnike"/>
			<dependency name="player_money"/>
			<param name="playerid">
			</param>
			<param name="novac">
			</param>
		</member>
		<member name="M:Debug_Code1" syntax="Debug_Code1(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code1(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:1(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 1</c>.  </remarks> 
		</member>
		<member name="M:Debug_Code2" syntax="Debug_Code2(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code2(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:2(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 2</c>.  </remarks> 
		</member>
		<member name="M:Debug_Code3" syntax="Debug_Code3(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code3(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:3(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 3</c>.  </remarks> 
		</member>
		<member name="M:Debug_Code4" syntax="Debug_Code4(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code4(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:4(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 4</c>.  </remarks> 
		</member>
		<member name="M:Debug_Code5" syntax="Debug_Code5(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code5(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:5(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 5</c>.  </remarks> 
		</member>
		<member name="M:Debug_Code6" syntax="Debug_Code6(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code6(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:6(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 6</c>.  </remarks> 
		</member>
		<member name="M:Debug_Code7" syntax="Debug_Code7(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code7(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:7(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 7</c>.  </remarks> 
		</member>
		<member name="M:Debug_Disable" syntax="Debug_Disable()">
			<stacksize value="1"/>
			<remarks>  Turn off level 0 prints.  </remarks>  <transition target="off"/>

		</member>
		<member name="M:Debug_Enable" syntax="Debug_Enable()">
			<stacksize value="1"/>
			<remarks>  Turn on level 0 prints.  </remarks>  <transition target="on"/>

		</member>
		<member name="M:Debug_Level" syntax="Debug_Level(level)">
			<stacksize value="1"/>
			<dependency name="YSI_gDebugLevel"/>
			<param name="level">
			</param>
			<remarks>  Set the debug level when the code is compiled with <c>_DEBUG=-1</c>, which  means full run-time selection.  </remarks> 
		</member>
		<member name="M:Debug_OnScriptInit" syntax="Debug_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetGlobal"/>
			<dependency name="AMX_HEADER_AMX_VERSION"/>
			<dependency name="AMX_HEADER_CIP"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_HEADER_DAT"/>
			<dependency name="AMX_HEADER_DEFSIZE"/>
			<dependency name="AMX_HEADER_FILE_VERSION"/>
			<dependency name="AMX_HEADER_FLAGS"/>
			<dependency name="AMX_HEADER_HEA"/>
			<dependency name="AMX_HEADER_LIBRARIES"/>
			<dependency name="AMX_HEADER_MAGIC"/>
			<dependency name="AMX_HEADER_NAMETABLE"/>
			<dependency name="AMX_HEADER_NATIVES"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_HEADER_PUBVARS"/>
			<dependency name="AMX_HEADER_SIZE"/>
			<dependency name="AMX_HEADER_STP"/>
			<dependency name="AMX_HEADER_TAGS"/>
			<dependency name="AMX_REAL_ADDRESS"/>
			<dependency name="AMX_REAL_DATA"/>
		</member>
		<member name="M:Debug_Print0" syntax="Debug_Print0(str[], ...)">
			<stacksize value="1"/>
			<automaton name="ysi_debug"/>
			<referrer name="YVers_OnScriptInit"/>
			<referrer name="AMX_Read"/>
			<referrer name="YVA2_DummyPush"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<referrer name="AMX_OnScriptInit"/>
			<referrer name="Malloc_TrySetup"/>
			<referrer name="OnRuntimeError"/>
			<referrer name="CGen_AddCodeSpace"/>
			<referrer name="I@E"/>
			<referrer name="I@F"/>
			<referrer name="Inline_OnAsmError"/>
			<referrer name="I@L"/>
			<referrer name="StoredF_OnPubGenError"/>
			<referrer name="Hooks_IsolateName"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GetStubEntry"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="INI_ParseFile"/>
			<referrer name="INI_Open"/>
			<referrer name="INI_WriteBuffer"/>
			<referrer name="@_"/>
			<referrer name="HashMap_Add"/>
			<referrer name="Iter_YieldEnter"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="@yH_OnScriptInit@005"/>
			<referrer name="@yH_OnMasterSystemClose@005"/>
			<referrer name="Command_Add"/>
			<referrer name="@a"/>
			<dependency name="printf"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				
			</param>
			<param name="format">str.</param>    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print0("variables: %d, %d", i, j);  </code>  Or:  <code>  P:0("variables: %d, %d", i, j);  </code>  <c>_DEBUG</c> level 0 prints are ALWAYS compiled, but are runtime switched  using the automata <c>ysi_debug</c>.  When then state is <c>ysi_debug :  on</c>, the prints are executed.  When then state is <c>ysi_debug : off</c>,  they aren't.  </remarks> 
		</member>
		<member name="M:Debug_Print1" syntax="Debug_Print1(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print1("variables: %d, %d", i, j);  </code>  Or:  <code>  P:1("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 1</c>.  </remarks> 
		</member>
		<member name="M:Debug_Print2" syntax="Debug_Print2(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print2("variables: %d, %d", i, j);  </code>  Or:  <code>  P:2("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 2</c>.  </remarks> 
		</member>
		<member name="M:Debug_Print3" syntax="Debug_Print3(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print3("variables: %d, %d", i, j);  </code>  Or:  <code>  P:3("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 3</c>.  </remarks> 
		</member>
		<member name="M:Debug_Print4" syntax="Debug_Print4(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print4("variables: %d, %d", i, j);  </code>  Or:  <code>  P:4("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 4</c>.  </remarks> 
		</member>
		<member name="M:Debug_Print5" syntax="Debug_Print5(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print5("variables: %d, %d", i, j);  </code>  Or:  <code>  P:5("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 5</c>.  </remarks> 
		</member>
		<member name="M:Debug_Print6" syntax="Debug_Print6(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print6("variables: %d, %d", i, j);  </code>  Or:  <code>  P:6("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 6</c>.  </remarks> 
		</member>
		<member name="M:Debug_Print7" syntax="Debug_Print7(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print7("variables: %d, %d", i, j);  </code>  Or:  <code>  P:7("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 7</c>.  </remarks> 
		</member>
		<member name="M:Debug_PrintArray" syntax="Debug_PrintArray(arr[], size)">
			<stacksize value="108"/>
			<dependency name="Debug_PrintArray"/>
			<dependency name="format"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Debug_SetState" syntax="Debug_SetState()">
			<stacksize value="1"/>
			<automaton name="ysi_debug"/>
			<referrer name="YVers_OnScriptInit"/>
			<transition keep="true" target="ysi_debug : on" source="ysi_debug : "/>  <remarks>  Mostly exists to define the full range of <c>ysi_debug</c> states.  </remarks> <p/> <transition target="on"/>

		</member>
		<member name="M:Delete3DTextLabel" syntax="Delete3DTextLabel(id)">
			<attribute name="native"/>
			<referrer name="@_yCstaffvehicle"/>
			<param name="id">
				<paraminfo>Text3D </paraminfo>
			</param>
		</member>
		<member name="M:DestroyActor" syntax="DestroyActor(actorid)">
			<attribute name="native"/>
			<referrer name="Iter_DestroyActor"/>
			<param name="actorid">
				The ID of the actor to destroy. Returned by <a href="#CreateActor">CreateActor</a>
			</param>
			<summary>Destroy an actor which was created with <a href="#CreateActor">CreateActor</a>.</summary>  <seealso name="CreateActor"/> <remarks>This function was added in <b>SA-MP 0.3.7</b> and will not work in earlier versions!</remarks> <returns> <b><c>1</c></b>: The function executed successfully.<p/> <b><c>0</c></b>: The function failed to execute. The actor with the ID specified does not exist. </returns>
		</member>
		<member name="M:DestroyVehicle" syntax="DestroyVehicle(vehicleid)">
			<attribute name="native"/>
			<referrer name="Iter_DestroyVehicle"/>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:DisableInteriorEnterExits" syntax="DisableInteriorEnterExits()">
			<attribute name="native"/>
			<referrer name="SSCANF_OnGameModeInit"/>
		</member>
		<member name="M:DisasmDecodeInsn" syntax="DisasmDecodeInsn(ctx[])">
			<tagname value="bool"/>
			<stacksize value="24"/>
			<referrer name="DisasmNext"/>
			<referrer name="DisasmNextInsn"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="AMX_Read"/>
			<referrer name="I@E"/>
			<referrer name="I@F"/>
			<referrer name="I@L"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_insn"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="GetOpcodeInstructionInformation"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_NONE"/>
			<dependency name="OpcodeInsnInfo_num_opers"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="UnrelocateOpcode"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmDump" syntax="DisasmDump(filename[])">
			<stacksize value="4"/>
			<dependency name="DisasmWrite"/>
			<param name="filename">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmGetCurIp" syntax="DisasmGetCurIp(ctx[])">
			<stacksize value="1"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="CodeScanStepInternal"/>
			<dependency name="DisasmContext_cip"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmGetInsnName" syntax="DisasmGetInsnName(ctx[], name[], size)">
			<stacksize value="5"/>
			<referrer name="DisasmWriteCode"/>
			<dependency name="DisasmContext_insn"/>
			<dependency name="OpcodeInsnInfo_name"/>
			<dependency name="strcat"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:DisasmGetNextIp" syntax="DisasmGetNextIp(ctx[])">
			<stacksize value="1"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanCheck"/>
			<dependency name="DisasmContext_nip"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmGetNumOperands" syntax="DisasmGetNumOperands(ctx[])">
			<stacksize value="1"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="Hooks_GetStubEntry"/>
			<dependency name="DisasmContext_insn"/>
			<dependency name="OpcodeInsnInfo_num_opers"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmGetOpcode" syntax="DisasmGetOpcode(ctx[])">
			<tagname value="Opcode"/>
			<stacksize value="1"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanRun"/>
			<referrer name="AMX_Read"/>
			<referrer name="I@E"/>
			<referrer name="I@F"/>
			<referrer name="I@L"/>
			<dependency name="DisasmContext_opcode"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmGetOperand" syntax="DisasmGetOperand(ctx[], index)">
			<stacksize value="4"/>
			<referrer name="DisasmGetOperandReloc"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="AMX_Read"/>
			<referrer name="I@E"/>
			<referrer name="I@F"/>
			<referrer name="I@L"/>
			<referrer name="Hooks_GetStubEntry"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="ReadAmxMemory"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:DisasmGetOperandReloc" syntax="DisasmGetOperandReloc(ctx[], index)">
			<stacksize value="6"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanCheck"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmNeedReloc"/>
			<dependency name="DisasmReloc"/>
			<dependency name="OP_CASETBL"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:DisasmGetRemaining" syntax="DisasmGetRemaining(ctx[])">
			<stacksize value="1"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmInit" syntax="DisasmInit(ctx[], start, end)">
			<stacksize value="21"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanRun"/>
			<referrer name="AMX_Read"/>
			<referrer name="I@E"/>
			<referrer name="I@F"/>
			<referrer name="I@L"/>
			<referrer name="Hooks_GetStubEntry"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="gCodBase"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="end">
			</param>
		</member>
		<member name="M:DisasmNeedReloc" syntax="DisasmNeedReloc(ctx[])">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="DisasmGetOperandReloc"/>
			<dependency name="DisasmContext_insn"/>
			<dependency name="OpcodeInsnInfo_needs_reloc"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmNext" syntax="DisasmNext(ctx[])">
			<tagname value="DisasmResult"/>
			<stacksize value="4"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanStepInternal"/>
			<dependency name="DISASM_DONE"/>
			<dependency name="DISASM_NOP"/>
			<dependency name="DISASM_OK"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="DisasmDecodeInsn"/>
			<dependency name="NUM_OPCODES"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmNextInsn" syntax="DisasmNextInsn(ctx[])">
			<tagname value="Opcode"/>
			<stacksize value="4"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<referrer name="Hooks_GetStubEntry"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="DisasmDecodeInsn"/>
			<dependency name="OP_NONE"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmReloc" syntax="DisasmReloc(addr)">
			<stacksize value="1"/>
			<referrer name="DisasmGetOperandReloc"/>
			<dependency name="gCodBase"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:DisasmWrite" syntax="DisasmWrite(filename[])">
			<tagname value="bool"/>
			<stacksize value="5"/>
			<referrer name="DisasmDump"/>
			<dependency name="DisasmWriteFile"/>
			<dependency name="false"/>
			<dependency name="fclose"/>
			<dependency name="fopen"/>
			<dependency name="io_write"/>
			<dependency name="true"/>
			<param name="filename">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmWriteCode" syntax="DisasmWriteCode(file)">
			<stacksize value="176"/>
			<referrer name="DisasmWriteFile"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_CIP"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmDecodeInsn"/>
			<dependency name="DisasmGetCurIp"/>
			<dependency name="DisasmGetInsnName"/>
			<dependency name="DisasmGetNextIp"/>
			<dependency name="DisasmGetNumOperands"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmGetOperandReloc"/>
			<dependency name="DisasmInit"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="GetNativeIndexFromAddress"/>
			<dependency name="GetNativeNameFromIndex"/>
			<dependency name="GetPublicIndexFromAddress"/>
			<dependency name="GetPublicNameFromIndex"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ToHexStr"/>
			<dependency name="ToHexStr"/>
			<dependency name="fwrite"/>
			<dependency name="gCodBase"/>
			<dependency name="strcat"/>
			<dependency name="strlen"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
		</member>
		<member name="M:DisasmWriteData" syntax="DisasmWriteData(file)">
			<stacksize value="38"/>
			<referrer name="DisasmWriteFile"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_HEA"/>
			<dependency name="DisasmWriteDataRowChar"/>
			<dependency name="DisasmWriteDataRowHex"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="ToHexStr"/>
			<dependency name="ToHexStr"/>
			<dependency name="fwrite"/>
			<dependency name="min"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
		</member>
		<member name="M:DisasmWriteDataRowChar" syntax="DisasmWriteDataRowChar(file, start, num, max)">
			<stacksize value="13"/>
			<referrer name="DisasmWriteData"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ToPrintableAscii"/>
			<dependency name="fwrite"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="num">
			</param>
			<param name="max">
			</param>
		</member>
		<member name="M:DisasmWriteDataRowHex" syntax="DisasmWriteDataRowHex(file, start, num, max)">
			<stacksize value="19"/>
			<referrer name="DisasmWriteData"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ToHexStr"/>
			<dependency name="ToHexStr"/>
			<dependency name="fwrite"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="num">
			</param>
			<param name="max">
			</param>
		</member>
		<member name="M:DisasmWriteFile" syntax="DisasmWriteFile(file)">
			<stacksize value="4"/>
			<referrer name="DisasmWrite"/>
			<dependency name="DisasmWriteCode"/>
			<dependency name="DisasmWriteData"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
		</member>
		<member name="M:Distribute_Do" syntax="Distribute_Do(func[], ...)">
			<stacksize value="7"/>
			<referrer name="YSI_g_sCommandFlags_Dist"/>
			<referrer name="YSI_g_sErrorMessages_Dist"/>
			<referrer name="YSI_g_sDisabledPlayers_Dist"/>
			<dependency name="CallRemoteFunction"/>
			<dependency name="Hooks_NumArgs"/>
			<dependency name="getarg"/>
			<param name="func">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:Distribute_So" syntax="Distribute_So(func[], idx, masters[], ...)">
			<stacksize value="8"/>
			<referrer name="YSI_g_sCommands_Dist"/>
			<dependency name="CallRemoteFunction"/>
			<dependency name="Hooks_NumArgs"/>
			<dependency name="_@"/>
			<dependency name="getarg"/>
			<param name="func">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="masters">
				<paraminfo>Bit [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:Distribute_To" syntax="Distribute_To(from[], ss, ...)">
			<stacksize value="7"/>
			<referrer name="YSI_g_sCommandFlags@Dist"/>
			<referrer name="YSI_g_sErrorMessages@Dist"/>
			<referrer name="YSI_g_sDisabledPlayers@Dist"/>
			<referrer name="YSI_g_sCommands@Dist"/>
			<dependency name="Hooks_NumArgs"/>
			<dependency name="getarg"/>
			<dependency name="memcpy"/>
			<dependency name="min"/>
			<param name="from">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="ss">
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:DumpStack" syntax="DumpStack()">
			<stacksize value="9"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="print"/>
			<dependency name="printf"/>
		</member>
		<member name="M:Dzampo" syntax="Dzampo(playerid)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<dependency name="BunnyHop"/>
			<dependency name="ClearAnimations"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:EnterijerBR2" syntax="EnterijerBR2(playerid)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<dependency name="TogglePlayerControllable"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:EnterijerBrojac" syntax="EnterijerBrojac(playerid)">
			<attribute name="public"/>
			<stacksize value="6"/>
			<referrer name="@yH_OnPlayerKeyStateChange@028"/>
			<dependency name="GameTextForPlayer"/>
			<dependency name="SetTimer"/>
			<dependency name="TogglePlayerControllable"/>
			<dependency name="false"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:F@" syntax="F@()">
			<stacksize value="6"/>
			<referrer name="Command_GetName"/>
			<referrer name="Command_GetDisplay"/>
			<referrer name="Command_GetDisplayNamed"/>
			<referrer name="Command_GetNext"/>
			<dependency name="Q@"/>
			<dependency name="getproperty"/>
			<dependency name="strunpack"/>
		</member>
		<member name="M:G@" syntax="G@(...)">
			<stacksize value="1"/>
			<dependency name="G@"/>
			<dependency name="Q@"/>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:GameTextForAll" syntax="GameTextForAll(string[], time, style)">
			<attribute name="native"/>
			<referrer name="va_GameTextForAll"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="time">
			</param>
			<param name="style">
			</param>
		</member>
		<member name="M:GameTextForPlayer" syntax="GameTextForPlayer(playerid, string[], time, style)">
			<attribute name="native"/>
			<referrer name="va_GameTextForPlayer"/>
			<referrer name="@yH_OnPlayerKeyStateChange@015"/>
			<referrer name="@yH_OnPlayerKeyStateChange@016"/>
			<referrer name="EnterijerBrojac"/>
			<param name="playerid">
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="time">
			</param>
			<param name="style">
			</param>
		</member>
		<member name="M:GetAmxAddress" syntax="GetAmxAddress()">
			<stacksize value="5"/>
			<referrer name="ReadAmxCell"/>
			<referrer name="WriteAmxCell"/>
			<dependency name="RunShellcode"/>
			<dependency name="refabs"/>
		</member>
		<member name="M:GetAmxBaseAddress" syntax="GetAmxBaseAddress()">
			<stacksize value="3"/>
			<referrer name="AbsToRel"/>
			<referrer name="RelToAbs"/>
			<referrer name="AsmGetJumpAddressFromOffset"/>
			<referrer name="AsmEmitCallAbs"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="DisasmInit"/>
			<referrer name="CodeScanInit"/>
			<referrer name="ProfilerInit"/>
			<referrer name="GetFunctionFromReturnAddress"/>
			<dependency name="GetAmxBaseAddressNow"/>
		</member>
		<member name="M:GetAmxBaseAddressNow" syntax="GetAmxBaseAddressNow()">
			<stacksize value="9"/>
			<referrer name="GetAmxBaseAddress"/>
			<dependency name="GetAmxBaseAddress_helper"/>
		</member>
		<member name="M:GetAmxBaseAddress_helper" syntax="GetAmxBaseAddress_helper()">
			<stacksize value="1"/>
			<referrer name="GetAmxBaseAddressNow"/>
		</member>
		<member name="M:GetAmxFrame" syntax="GetAmxFrame()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxHeader" syntax="GetAmxHeader(amxhdr[])">
			<stacksize value="3"/>
			<referrer name="AsmGetJumpAddressFromOffset"/>
			<referrer name="AsmGetCode"/>
			<referrer name="AsmEmitCallAbs"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="DisasmInit"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DisasmWriteData"/>
			<referrer name="CodeScanInit"/>
			<referrer name="ProfilerInit"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetAmxHeaderComponent" syntax="GetAmxHeaderComponent(comp)">
			<stacksize value="3"/>
			<referrer name="GetPublicNameFromIndex"/>
			<referrer name="GetNativeNameFromIndex"/>
			<referrer name="GetPubVarNameFromIndex"/>
			<referrer name="GetTagNameFromIndex"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="comp">
				<paraminfo>AMX_HDR </paraminfo>
			</param>
		</member>
		<member name="M:GetAmxHeaderNow" syntax="GetAmxHeaderNow(amxhdr[])">
			<stacksize value="21"/>
			<referrer name="ResetStaticAmxHeader"/>
			<dependency name="AMX_HDR_AMX_VERSION"/>
			<dependency name="AMX_HDR_CIP"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_FILE_VERSION"/>
			<dependency name="AMX_HDR_FLAGS"/>
			<dependency name="AMX_HDR_HEA"/>
			<dependency name="AMX_HDR_LIBRARIES"/>
			<dependency name="AMX_HDR_MAGIC"/>
			<dependency name="AMX_HDR_NAMETABLE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="AMX_HDR_OFFSET_AMX_VERSION"/>
			<dependency name="AMX_HDR_OFFSET_CIP"/>
			<dependency name="AMX_HDR_OFFSET_COD"/>
			<dependency name="AMX_HDR_OFFSET_DAT"/>
			<dependency name="AMX_HDR_OFFSET_DEFSIZE"/>
			<dependency name="AMX_HDR_OFFSET_FILE_VERSION"/>
			<dependency name="AMX_HDR_OFFSET_FLAGS"/>
			<dependency name="AMX_HDR_OFFSET_HEA"/>
			<dependency name="AMX_HDR_OFFSET_LIBRARIES"/>
			<dependency name="AMX_HDR_OFFSET_MAGIC"/>
			<dependency name="AMX_HDR_OFFSET_NAMETABLE"/>
			<dependency name="AMX_HDR_OFFSET_NATIVES"/>
			<dependency name="AMX_HDR_OFFSET_PUBLICS"/>
			<dependency name="AMX_HDR_OFFSET_PUBVARS"/>
			<dependency name="AMX_HDR_OFFSET_SIZE"/>
			<dependency name="AMX_HDR_OFFSET_STP"/>
			<dependency name="AMX_HDR_OFFSET_TAGS"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="AMX_HDR_SIZE"/>
			<dependency name="AMX_HDR_STP"/>
			<dependency name="AMX_HDR_TAGS"/>
			<dependency name="GetRawAmxHeader"/>
			<dependency name="copy_1"/>
			<dependency name="copy_2"/>
			<dependency name="copy_4"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetAmxHeapBase" syntax="GetAmxHeapBase()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxHeapTop" syntax="GetAmxHeapTop()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxJITBaseAddress" syntax="GetAmxJITBaseAddress()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxNextInstructionPointer" syntax="GetAmxNextInstructionPointer()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxStackBase" syntax="GetAmxStackBase()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxStackBottom" syntax="GetAmxStackBottom()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetCallerFrame" syntax="GetCallerFrame()">
			<stacksize value="1"/>
			<referrer name="GetCurrentFramePreviousFrame"/>
			<referrer name="GetCurrentFrameReturn"/>
			<referrer name="GetCurrentFrameTotalSize"/>
			<referrer name="GetCurrentFrameTotalCount"/>
			<referrer name="GetCurrentFrameLocalSize"/>
			<referrer name="GetCurrentFrameLocalCount"/>
			<referrer name="GetCurrentFrameHeaderSize"/>
			<referrer name="GetCurrentFrameHeaderCount"/>
			<referrer name="GetCurrentFrameParameterSize"/>
			<referrer name="GetCurrentFrameParameter"/>
			<referrer name="GetCurrentFrameLocal"/>
			<referrer name="GetCurrentFrameParameterCount"/>
			<referrer name="SetCurrentFrameReturn"/>
			<referrer name="SetCurrentFramePreviousFrame"/>
			<referrer name="SetCurrentParameterSize"/>
			<referrer name="SetCurrentParameterCount"/>
			<referrer name="GetCurrentFrameFunction"/>
		</member>
		<member name="M:GetCurrentFrame" syntax="GetCurrentFrame()">
			<stacksize value="1"/>
			<referrer name="GetFrameNextFrame"/>
		</member>
		<member name="M:GetCurrentFrameFunction" syntax="GetCurrentFrameFunction()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameFunction"/>
		</member>
		<member name="M:GetCurrentFrameHeaderCount" syntax="GetCurrentFrameHeaderCount()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameHeaderCount"/>
		</member>
		<member name="M:GetCurrentFrameHeaderSize" syntax="GetCurrentFrameHeaderSize()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameHeaderSize"/>
		</member>
		<member name="M:GetCurrentFrameLocal" syntax="GetCurrentFrameLocal(param)">
			<stacksize value="5"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameLocal"/>
			<param name="param">
			</param>
		</member>
		<member name="M:GetCurrentFrameLocalCount" syntax="GetCurrentFrameLocalCount()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameLocalCount"/>
		</member>
		<member name="M:GetCurrentFrameLocalSize" syntax="GetCurrentFrameLocalSize()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameLocalSize"/>
		</member>
		<member name="M:GetCurrentFrameParameter" syntax="GetCurrentFrameParameter(param, idx)">
			<stacksize value="6"/>
			<referrer name="I@E"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameParameter"/>
			<param name="param">
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:GetCurrentFrameParameterCount" syntax="GetCurrentFrameParameterCount()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameParameterCount"/>
		</member>
		<member name="M:GetCurrentFrameParameterSize" syntax="GetCurrentFrameParameterSize()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameParameterSize"/>
		</member>
		<member name="M:GetCurrentFramePreviousFrame" syntax="GetCurrentFramePreviousFrame()">
			<stacksize value="4"/>
			<referrer name="Callback_Get"/>
			<referrer name="Callback_Restore"/>
			<referrer name="I@E"/>
			<referrer name="I@L"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFramePreviousFrame"/>
		</member>
		<member name="M:GetCurrentFrameReturn" syntax="GetCurrentFrameReturn()">
			<stacksize value="4"/>
			<referrer name="O@A_"/>
			<referrer name="AMX_Read"/>
			<referrer name="I@E"/>
			<referrer name="I@F"/>
			<referrer name="I@L"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameReturn"/>
		</member>
		<member name="M:GetCurrentFrameTotalCount" syntax="GetCurrentFrameTotalCount()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameTotalCount"/>
		</member>
		<member name="M:GetCurrentFrameTotalSize" syntax="GetCurrentFrameTotalSize()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameTotalSize"/>
		</member>
		<member name="M:GetDat" syntax="GetDat()">
			<stacksize value="1"/>
			<referrer name="AbsToRel"/>
			<referrer name="RelToAbs"/>
		</member>
		<member name="M:GetFrameFunction" syntax="GetFrameFunction(frm_addr)">
			<stacksize value="29"/>
			<referrer name="GetCurrentFrameFunction"/>
			<referrer name="Callback_Get"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_CIP"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="GetFrameNextFrame"/>
			<dependency name="GetFramePreviousFrame"/>
			<dependency name="GetFrameReturn"/>
			<dependency name="GetFrameVariable"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CONST_PRI"/>
			<dependency name="OP_LOAD_PRI"/>
			<dependency name="OP_LOAD_S_PRI"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_RETN"/>
			<dependency name="OP_SCTRL"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="UnrelocateOpcode"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameHeaderCount" syntax="GetFrameHeaderCount(frm_addr)">
			<stacksize value="4"/>
			<referrer name="GetCurrentFrameHeaderCount"/>
			<dependency name="GetFrameHeaderSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameHeaderSize" syntax="GetFrameHeaderSize(frm_addr)">
			<stacksize value="1"/>
			<referrer name="GetFrameTotalSize"/>
			<referrer name="GetFrameLocalSize"/>
			<referrer name="GetFrameHeaderCount"/>
			<referrer name="GetCurrentFrameHeaderSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameLocal" syntax="GetFrameLocal(frm_addr, param)">
			<stacksize value="1"/>
			<referrer name="GetCurrentFrameLocal"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
		</member>
		<member name="M:GetFrameLocalCount" syntax="GetFrameLocalCount(frm_addr)">
			<stacksize value="4"/>
			<referrer name="GetCurrentFrameLocalCount"/>
			<dependency name="GetFrameLocalSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameLocalSize" syntax="GetFrameLocalSize(frm_addr)">
			<stacksize value="6"/>
			<referrer name="GetFrameTotalSize"/>
			<referrer name="GetFrameLocalCount"/>
			<referrer name="GetCurrentFrameLocalSize"/>
			<referrer name="I@E"/>
			<referrer name="I@L"/>
			<dependency name="GetFrameHeaderSize"/>
			<dependency name="GetFrameNextFrame"/>
			<dependency name="GetFrameParameterSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameNextFrame" syntax="GetFrameNextFrame(frm_addr)">
			<stacksize value="6"/>
			<referrer name="GetFrameLocalSize"/>
			<referrer name="GetFrameFunction"/>
			<dependency name="GetCurrentFrame"/>
			<dependency name="GetFramePreviousFrame"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameParameter" syntax="GetFrameParameter(frm_addr, param, idx)">
			<stacksize value="1"/>
			<referrer name="GetCurrentFrameParameter"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:GetFrameParameterCount" syntax="GetFrameParameterCount(frm_addr)">
			<stacksize value="4"/>
			<referrer name="GetCurrentFrameParameterCount"/>
			<dependency name="GetFrameParameterSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameParameterSize" syntax="GetFrameParameterSize(frm_addr)">
			<stacksize value="1"/>
			<referrer name="GetFrameTotalSize"/>
			<referrer name="GetFrameLocalSize"/>
			<referrer name="GetFrameParameterCount"/>
			<referrer name="GetCurrentFrameParameterSize"/>
			<referrer name="Callback_Restore"/>
			<referrer name="I@E"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFramePreviousFrame" syntax="GetFramePreviousFrame(frm_addr)">
			<stacksize value="1"/>
			<referrer name="GetFrameNextFrame"/>
			<referrer name="GetCurrentFramePreviousFrame"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="GetStackTrace"/>
			<referrer name="Callback_Get"/>
			<referrer name="Callback_Restore"/>
			<referrer name="I@E"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameReturn" syntax="GetFrameReturn(frm_addr)">
			<stacksize value="1"/>
			<referrer name="GetCurrentFrameReturn"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="GetStackTrace"/>
			<referrer name="Malloc_FindStackTop"/>
			<referrer name="Callback_Get"/>
			<referrer name="Callback_Restore"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameTotalCount" syntax="GetFrameTotalCount(frm_addr)">
			<stacksize value="4"/>
			<referrer name="GetCurrentFrameTotalCount"/>
			<dependency name="GetFrameTotalSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameTotalSize" syntax="GetFrameTotalSize(frm_addr)">
			<stacksize value="4"/>
			<referrer name="GetFrameTotalCount"/>
			<referrer name="GetCurrentFrameTotalSize"/>
			<dependency name="GetFrameHeaderSize"/>
			<dependency name="GetFrameLocalSize"/>
			<dependency name="GetFrameParameterSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameVariable" syntax="GetFrameVariable(frm_addr, param, idx)">
			<stacksize value="1"/>
			<referrer name="GetFrameFunction"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:GetFunctionFromReturnAddress" syntax="GetFunctionFromReturnAddress(ret_addr)">
			<stacksize value="4"/>
			<referrer name="PrintStackTrace"/>
			<dependency name="GetAmxBaseAddress"/>
			<param name="ret_addr">
			</param>
		</member>
		<member name="M:GetIP" syntax="GetIP(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
				Player to get IP of.
			</param>
			  <returns>  IP as a 32bit int.  </returns> 
		</member>
		<member name="M:GetJITGeneratorVersion" syntax="GetJITGeneratorVersion()">
			<stacksize value="1"/>
			<referrer name="SysreqC"/>
			<referrer name="SysreqD"/>
			<referrer name="SysreqCN"/>
			<referrer name="SysreqDN"/>
			<referrer name="CallNative"/>
			<referrer name="CallNativeByAddress"/>
		</member>
		<member name="M:GetLocalFunction" syntax="GetLocalFunction(func[], spec[])">
			<tagname value="Function"/>
			<stacksize value="6"/>
			<referrer name="Callback_Get"/>
			<dependency name="StoredF_WritePublicCode"/>
			<dependency name="funcidx"/>
			<param name="func">
				<paraminfo> [] </paraminfo>
				Public function to get.
			</param>
			<param name="spec">
				<paraminfo> [] </paraminfo>
				The structure of the function's parameters.
			</param>
			    <returns>  A pointer to the function.  </returns>  <remarks>  Accepts the following parameter specifiers:  i - Integer (also x/c/d/h)  f - Float (also g)  s - String  ai - Array (followed by length)  v - Reference (&amp;var, any tag)  </remarks> 
		</member>
		<member name="M:GetMaxPlayers" syntax="GetMaxPlayers()">
			<attribute name="native"/>
			<referrer name="SSCANF_RunInit"/>
		</member>
		<member name="M:GetName" syntax="GetName(playerid)">
			<stacksize value="29"/>
			<referrer name="@_yCdo"/>
			<referrer name="@_yCb"/>
			<referrer name="@_yCme"/>
			<referrer name="@_yCmakestaff"/>
			<dependency name="GetName"/>
			<dependency name="GetPlayerName"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:GetNativeAddressFromIndex" syntax="GetNativeAddressFromIndex(index)">
			<stacksize value="7"/>
			<referrer name="GetNativeAddressFromName"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetNativeInfo"/>
			<param name="index">
			</param>
		</member>
		<member name="M:GetNativeAddressFromName" syntax="GetNativeAddressFromName(name[])">
			<stacksize value="4"/>
			<dependency name="GetNativeAddressFromIndex"/>
			<dependency name="GetNativeIndexFromName"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetNativeIndexFromAddress" syntax="GetNativeIndexFromAddress(address)">
			<stacksize value="7"/>
			<referrer name="GetNativeNameFromAddress"/>
			<referrer name="DisasmWriteCode"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="GetNumNatives"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="address">
			</param>
		</member>
		<member name="M:GetNativeIndexFromName" syntax="GetNativeIndexFromName(name[])">
			<stacksize value="10"/>
			<referrer name="GetNativeAddressFromName"/>
			<referrer name="AsmEmitSysreq"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="GetNumNatives"/>
			<dependency name="NtCompare"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetNativeInfo" syntax="GetNativeInfo(index, info[])">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<referrer name="GetNativeAddressFromIndex"/>
			<referrer name="GetNativeNameFromIndex"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="GetNumNatives"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="false"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="true"/>
			<param name="index">
			</param>
			<param name="info">
				<paraminfo> [2] </paraminfo>
			</param>
		</member>
		<member name="M:GetNativeNameFromAddress" syntax="GetNativeNameFromAddress(address, name[], size)">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<dependency name="GetNativeIndexFromAddress"/>
			<dependency name="GetNativeNameFromIndex"/>
			<param name="address">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetNativeNameFromIndex" syntax="GetNativeNameFromIndex(index, name[], size)">
			<tagname value="bool"/>
			<stacksize value="8"/>
			<referrer name="GetNativeNameFromAddress"/>
			<referrer name="DisasmWriteCode"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="GetAmxHeaderComponent"/>
			<dependency name="GetNativeInfo"/>
			<dependency name="NtCopy"/>
			<dependency name="false"/>
			<param name="index">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetNumNatives" syntax="GetNumNatives(amxhdr[])">
			<stacksize value="1"/>
			<referrer name="GetNativeIndexFromAddress"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="HookNative"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_LIBRARIES"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetNumPubVars" syntax="GetNumPubVars(amxhdr[])">
			<stacksize value="1"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetPubVarIndexFromAddress"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="AMX_HDR_TAGS"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetNumPublics" syntax="GetNumPublics(amxhdr[])">
			<stacksize value="2"/>
			<referrer name="GetPublicIndexFromAddress"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="HookPublic"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetNumTags" syntax="GetNumTags(amxhdr[])">
			<stacksize value="4"/>
			<dependency name="GetNumTagsInternal"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetNumTagsInternal" syntax="GetNumTagsInternal(amxhdr[])">
			<stacksize value="1"/>
			<referrer name="GetNumTags"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagIndexFromName"/>
			<referrer name="GetTagIndexFromID"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NAMETABLE"/>
			<dependency name="AMX_HDR_TAGS"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetOS" syntax="GetOS()">
			<tagname value="OS"/>
			<stacksize value="4"/>
			<referrer name="IsWindows"/>
			<referrer name="IsLinux"/>
			<dependency name="OP_LOAD_PRI"/>
			<dependency name="OS_LINUX"/>
			<dependency name="OS_UNKNOWN"/>
			<dependency name="OS_WINDOWS"/>
			<dependency name="RelocateOpcode"/>
		</member>
		<member name="M:GetOpcodeInstructionInformation" syntax="GetOpcodeInstructionInformation(opcode)">
			<stacksize value="1"/>
			<referrer name="DisasmDecodeInsn"/>
			<dependency name="GetOpcodeInstructionInformation"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="insn_table"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:GetOpcodeInstructionName" syntax="GetOpcodeInstructionName(opcode)">
			<stacksize value="1"/>
			<dependency name="GetOpcodeInstructionName"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="insn_table"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:GetOpcodeInstructionParameters" syntax="GetOpcodeInstructionParameters(opcode)">
			<stacksize value="1"/>
			<referrer name="AsmEmitPadding"/>
			<referrer name="CodeScanMatcherPattern_"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="OpcodeInsnInfo_num_opers"/>
			<dependency name="insn_table"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:GetOpcodeInstructionRelocatable" syntax="GetOpcodeInstructionRelocatable(opcode)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="OpcodeInsnInfo_needs_reloc"/>
			<dependency name="false"/>
			<dependency name="insn_table"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:GetPlayer2DZone" syntax="GetPlayer2DZone(playerid, zone[], len)">
			<stacksize value="11"/>
			<referrer name="GlobalTimer"/>
			<referrer name="ZonaIgraca"/>
			<dependency name="operator&gt;=(Float:,Float:)"/>
			<dependency name="operator&lt;=(Float:,Float:)"/>
			<dependency name="GetPlayerPos"/>
			<dependency name="IG_ZONE_IMENA"/>
			<dependency name="IG_Zone"/>
			<dependency name="IG_Zone"/>
			<dependency name="SAZONE_AREA"/>
			<dependency name="format"/>
			<param name="playerid">
			</param>
			<param name="zone">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:GetPlayerIp" syntax="GetPlayerIp(playerid, name[], len)">
			<attribute name="native"/>
			<referrer name="OnPlayerConnect"/>
			<param name="playerid">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:GetPlayerMoney" syntax="GetPlayerMoney(playerid)">
			<attribute name="native"/>
			<referrer name="SacuvajKorisnike"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:GetPlayerName" syntax="GetPlayerName(playerid, name[], len)">
			<attribute name="native"/>
			<referrer name="ReturnPlayerName"/>
			<referrer name="SSCANF_RunInit"/>
			<referrer name="_y_utils_OnPlayerConnect"/>
			<referrer name="UserPath"/>
			<referrer name="GetName"/>
			<referrer name="ImeIgraca"/>
			<referrer name="@yH_OnPlayerKeyStateChange@016"/>
			<referrer name="@yH_OnPlayerConnect@019"/>
			<referrer name="@_yCmakestaff"/>
			<referrer name="@_yCstaffon"/>
			<referrer name="@_yCclearchat"/>
			<referrer name="@yH_OnDialogResponse@029"/>
			<param name="playerid">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:GetPlayerPos" syntax="GetPlayerPos(playerid, &amp;x, &amp;y, &amp;z)">
			<attribute name="native"/>
			<referrer name="Proxara"/>
			<referrer name="@_yCjetpack"/>
			<referrer name="@_yCstaffvehicle"/>
			<referrer name="GetPlayer2DZone"/>
			<param name="playerid">
			</param>
			<param name="x">
				<paraminfo>Float &amp; </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float &amp; </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float &amp; </paraminfo>
			</param>
		</member>
		<member name="M:GetPlayerVehicleID" syntax="GetPlayerVehicleID(playerid)">
			<attribute name="native"/>
			<referrer name="@_yCstaffvehicle"/>
			<referrer name="@_yCxgoto"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:GetPlayerVirtualWorld" syntax="GetPlayerVirtualWorld(playerid)">
			<attribute name="native"/>
			<referrer name="Proxara"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:GetPlayerWeapon" syntax="GetPlayerWeapon(playerid)">
			<attribute name="native"/>
			<referrer name="@yH_OnPlayerKeyStateChange@015"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:GetPubVarAddressFromIndex" syntax="GetPubVarAddressFromIndex(index)">
			<stacksize value="7"/>
			<referrer name="GetPubVarAddressFromName"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetPubVarInfo"/>
			<param name="index">
			</param>
		</member>
		<member name="M:GetPubVarAddressFromName" syntax="GetPubVarAddressFromName(name[])">
			<stacksize value="4"/>
			<dependency name="GetPubVarAddressFromIndex"/>
			<dependency name="GetPubVarIndexFromName"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetPubVarIndexFromAddress" syntax="GetPubVarIndexFromAddress(address)">
			<stacksize value="7"/>
			<referrer name="GetPubVarNameFromAddress"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="GetNumPubVars"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="address">
			</param>
		</member>
		<member name="M:GetPubVarIndexFromName" syntax="GetPubVarIndexFromName(name[])">
			<stacksize value="12"/>
			<referrer name="GetPubVarAddressFromName"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="GetNumPubVars"/>
			<dependency name="NtCompare"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetPubVarInfo" syntax="GetPubVarInfo(index, info[])">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<referrer name="GetPubVarAddressFromIndex"/>
			<referrer name="GetPubVarNameFromIndex"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="GetNumPubVars"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="false"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="true"/>
			<param name="index">
			</param>
			<param name="info">
				<paraminfo> [2] </paraminfo>
			</param>
		</member>
		<member name="M:GetPubVarNameFromAddress" syntax="GetPubVarNameFromAddress(address, name[], size)">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<dependency name="GetPubVarIndexFromAddress"/>
			<dependency name="GetPubVarNameFromIndex"/>
			<param name="address">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetPubVarNameFromIndex" syntax="GetPubVarNameFromIndex(index, name[], size)">
			<tagname value="bool"/>
			<stacksize value="8"/>
			<referrer name="GetPubVarNameFromAddress"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="GetAmxHeaderComponent"/>
			<dependency name="GetPubVarInfo"/>
			<dependency name="NtCopy"/>
			<dependency name="false"/>
			<param name="index">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetPublicAddressFromIndex" syntax="GetPublicAddressFromIndex(index)">
			<stacksize value="7"/>
			<referrer name="GetPublicAddressFromName"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetPublicInfo"/>
			<param name="index">
			</param>
		</member>
		<member name="M:GetPublicAddressFromName" syntax="GetPublicAddressFromName(name[])">
			<stacksize value="4"/>
			<referrer name="AsmSetErrorHandlerName"/>
			<referrer name="I@L"/>
			<referrer name="StoredF_WritePublicCode"/>
			<dependency name="GetPublicAddressFromIndex"/>
			<dependency name="GetPublicIndexFromName"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetPublicIndexFromAddress" syntax="GetPublicIndexFromAddress(address)">
			<stacksize value="7"/>
			<referrer name="GetPublicNameFromAddress"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanGetFuncName"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetNumPublics"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="address">
			</param>
		</member>
		<member name="M:GetPublicIndexFromName" syntax="GetPublicIndexFromName(name[])">
			<stacksize value="12"/>
			<referrer name="GetPublicAddressFromName"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetNumPublics"/>
			<dependency name="NtCompare"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetPublicInfo" syntax="GetPublicInfo(index, info[])">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<referrer name="GetPublicAddressFromIndex"/>
			<referrer name="GetPublicNameFromIndex"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetNumPublics"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="false"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="true"/>
			<param name="index">
			</param>
			<param name="info">
				<paraminfo> [2] </paraminfo>
			</param>
		</member>
		<member name="M:GetPublicNameFromAddress" syntax="GetPublicNameFromAddress(address, name[], size)">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<referrer name="PrintStackTrace"/>
			<dependency name="GetPublicIndexFromAddress"/>
			<dependency name="GetPublicNameFromIndex"/>
			<param name="address">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetPublicNameFromIndex" syntax="GetPublicNameFromIndex(index, name[], size)">
			<tagname value="bool"/>
			<stacksize value="8"/>
			<referrer name="GetPublicNameFromAddress"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanGetFuncName"/>
			<referrer name="ProfilerWriteData"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="GetAmxHeaderComponent"/>
			<dependency name="GetPublicInfo"/>
			<dependency name="NtCopy"/>
			<dependency name="false"/>
			<param name="index">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetRawAmxHeader" syntax="GetRawAmxHeader(plain_amxhdr[])">
			<stacksize value="6"/>
			<referrer name="GetAmxHeaderNow"/>
			<dependency name="ReadAmxMemory"/>
			<param name="plain_amxhdr">
				<paraminfo> [15] </paraminfo>
			</param>
		</member>
		<member name="M:GetRemoteFunction" syntax="GetRemoteFunction(func[], spec[])">
			<tagname value="Function"/>
			<stacksize value="8"/>
			<referrer name="Callback_Get"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_Read"/>
			<dependency name="Remote_DoSearch"/>
			<dependency name="Remote_WriteJustSpec"/>
			<dependency name="Remote_WriteSpecAndFunc"/>
			<dependency name="Remote_WriteStubCode"/>
			<dependency name="YSI_g_sRemoteFunctions"/>
			<dependency name="YSI_g_sRemoteSpecifiers"/>
			<dependency name="YSI_g_sRemoteStub"/>
			<dependency name="ref"/>
			<param name="func">
				<paraminfo> [] </paraminfo>
				Public function to get.
			</param>
			<param name="spec">
				<paraminfo> [] </paraminfo>
				The structure of the function's parameters.
			</param>
			    <returns>  A pointer to the function.  </returns>  <remarks>  Accepts the following parameter specifiers:  i - Integer (also x/c/d/h)  f - Float (also g)  s - String  ai - Array (followed by length)  v - Reference (&amp;var, any tag)  </remarks> 
		</member>
		<member name="M:GetStackTrace" syntax="GetStackTrace(trace[], skip, max)">
			<stacksize value="7"/>
			<dependency name="GetFramePreviousFrame"/>
			<dependency name="GetFrameReturn"/>
			<param name="trace">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="skip">
			</param>
			<param name="max">
			</param>
		</member>
		<member name="M:GetTagIDFromIndex" syntax="GetTagIDFromIndex(index)">
			<stacksize value="7"/>
			<referrer name="GetTagIDFromName"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetTagInfo"/>
			<param name="index">
			</param>
		</member>
		<member name="M:GetTagIDFromName" syntax="GetTagIDFromName(name[])">
			<stacksize value="4"/>
			<dependency name="GetTagIDFromIndex"/>
			<dependency name="GetTagIndexFromName"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetTagIndexFromID" syntax="GetTagIndexFromID(id)">
			<stacksize value="7"/>
			<referrer name="GetTagNameFromID"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_TAGS"/>
			<dependency name="GetNumTagsInternal"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="id">
			</param>
		</member>
		<member name="M:GetTagIndexFromName" syntax="GetTagIndexFromName(name[])">
			<stacksize value="12"/>
			<referrer name="GetTagIDFromName"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_TAGS"/>
			<dependency name="GetNumTagsInternal"/>
			<dependency name="NtCompare"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetTagInfo" syntax="GetTagInfo(index, info[])">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<referrer name="GetTagIDFromIndex"/>
			<referrer name="GetTagNameFromIndex"/>
			<referrer name="IsTagIndexStrong"/>
			<referrer name="IsTagIndexWeak"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_TAGS"/>
			<dependency name="GetNumTagsInternal"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="false"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="true"/>
			<param name="index">
			</param>
			<param name="info">
				<paraminfo> [2] </paraminfo>
			</param>
		</member>
		<member name="M:GetTagNameFromID" syntax="GetTagNameFromID(id, name[], size)">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<dependency name="GetTagIndexFromID"/>
			<dependency name="GetTagNameFromIndex"/>
			<dependency name="true"/>
			<param name="id">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetTagNameFromIndex" syntax="GetTagNameFromIndex(index, name[], size)">
			<tagname value="bool"/>
			<stacksize value="8"/>
			<referrer name="GetTagNameFromID"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="GetAmxHeaderComponent"/>
			<dependency name="GetTagInfo"/>
			<dependency name="NtCopy"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="index">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetVehicleModel" syntax="GetVehicleModel(vehicleid)">
			<attribute name="native"/>
			<referrer name="@yH_OnScriptInit@004"/>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:GetVehicleParamsEx" syntax="GetVehicleParamsEx(vehicleid, &amp;engine, &amp;lights, &amp;alarm, &amp;doors, &amp;bonnet, &amp;boot, &amp;objective)">
			<attribute name="native"/>
			<referrer name="@_yCstaffvehicle"/>
			<param name="vehicleid">
			</param>
			<param name="engine">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="lights">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="alarm">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="doors">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="bonnet">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="boot">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="objective">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:GivePlayerMoney" syntax="GivePlayerMoney(playerid, money)">
			<attribute name="native"/>
			<referrer name="DajIgracuNovac"/>
			<referrer name="OnDialogResponse"/>
			<param name="playerid">
			</param>
			<param name="money">
			</param>
		</member>
		<member name="M:GlobalTimer" syntax="GlobalTimer()">
			<attribute name="public"/>
			<stacksize value="67"/>
			<dependency name="GetPlayer2DZone"/>
			<dependency name="Ingame_PTD"/>
			<dependency name="Ingame_PTD"/>
			<dependency name="Iterator@Player"/>
			<dependency name="PlayerTextDrawSetString"/>
			<dependency name="ZonaIgraca"/>
			<dependency name="format"/>
		</member>
		<member name="M:Group_ExclusiveCommand" syntax="Group_ExclusiveCommand(g, el)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Group_ExclusiveCommand@"/>
			<referrer name="Group_GlobalExclusiveCommand"/>
			<dependency name="Command_InitialiseFromGroups"/>
			<dependency name="H@"/>
			<dependency name="YSI_gTempGroups"/>
			<dependency name="YSI_g_cEmptyGroups"/>
			<dependency name="YSI_g_sDefaultMembership"/>
			<dependency name="YSI_g_sEmpty"/>
			<dependency name="cellbits"/>
			<param name="g">
				<paraminfo>Group </paraminfo>
				Group to add this to.
			</param>
			<param name="el">
				Element to add.
			</param>
			<summary>Group_Exclusive...</summary>      <remarks>  Add this element to ONLY this group and remove it from any others it might  already be in.  This is basically a simplified version of "GROUP_ADD".  </remarks> 
		</member>
		<member name="M:Group_ExclusiveCommand@" syntax="Group_ExclusiveCommand@(g, el)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="Group_ExclusiveCommand"/>
			<param name="g">
				<paraminfo>Group </paraminfo>
			</param>
			<param name="el">
			</param>
		</member>
		<member name="M:Group_FullPlayerUpdate" syntax="Group_FullPlayerUpdate(playerid, el, p[], c[], r[])">
			<stacksize value="6"/>
			<referrer name="Group_SetCommand"/>
			<referrer name="Group_SetCommandDefault"/>
			<referrer name="_yGUCommand"/>
			<dependency name="Command_SetPlayer"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="playerid">
				Player to check.
			</param>
			<param name="el">
				Element to show or hide.
			</param>
			<param name="p">
				<paraminfo>Bit [] </paraminfo>
			</param>
			<param name="c">
				<paraminfo>Bit [] </paraminfo>
			</param>
			<param name="r">
				<paraminfo>Bit [] </paraminfo>
			</param>
			    <param name="previous">(p) The old state of affairs.</param>  <param name="current">(c) The new state of affairs.</param>  <param name="reference">(r) What to compare changes to.</param>  <remarks>  I did have a good reason for calling this "FU", but I forgot it!  Anyway,  the state of some groups has changed - either a player's groups or an  elements groups have changed.  If the player could previously see the  element but now can't, hide it.  If the player previously couldn't see it  but now can, show it.  If there is no change do nothing.  The old version of  this library would just re-show the element even if they could already see  it, but this was a bad design as it could incur large overheads in other  libraries when they had to do IO to enable or disable something for a  player.  The change can be in either the player's groups or the element's groups,  either way this code will work regardless.  </remarks> 
		</member>
		<member name="M:Group_GetCommand" syntax="Group_GetCommand(g, el)">
			<tagname value="bool"/>
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Group_GetCommand@"/>
			<referrer name="Group_GetGlobalCommand"/>
			<dependency name="H@"/>
			<dependency name="YSI_g_sElementMembership"/>
			<dependency name="cellbits"/>
			<param name="g">
				<paraminfo>Group </paraminfo>
				Group to get from.
			</param>
			<param name="el">
				Element to get.
			</param>
			<summary>Group_Get...</summary>      <returns>  bool: Does the group have the element?  </returns> 
		</member>
		<member name="M:Group_GetCommand@" syntax="Group_GetCommand@(g, el)">
			<tagname value="bool"/>
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="Group_GetCommand"/>
			<param name="g">
				<paraminfo>Group </paraminfo>
			</param>
			<param name="el">
			</param>
		</member>
		<member name="M:Group_GetGlobalCommand" syntax="Group_GetGlobalCommand(el)">
			<tagname value="bool"/>
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Group_GetGlobalCommand@"/>
			<dependency name="Group_GetCommand"/>
			<dependency name="H@"/>
			<param name="el">
				Element to get.
			</param>
			<summary>Group_GetGlobal...</summary>    <returns>  bool: Does the global group have the element?  </returns> 
		</member>
		<member name="M:Group_GetGlobalCommand@" syntax="Group_GetGlobalCommand@(el)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="Group_GetGlobalCommand"/>
			<param name="el">
			</param>
		</member>
		<member name="M:Group_GlobalExclusiveCommand" syntax="Group_GlobalExclusiveCommand(el)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Group_GlobalExclusiveCommand@"/>
			<dependency name="Group_ExclusiveCommand"/>
			<dependency name="H@"/>
			<param name="el">
				Element to add.
			</param>
			<summary>Group_GlobalExclusive...</summary>    <remarks>  Add this element to ONLY the global group and remove it from any others it  might already be in.  </remarks> 
		</member>
		<member name="M:Group_GlobalExclusiveCommand@" syntax="Group_GlobalExclusiveCommand@(el)">
			<stacksize value="4"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="Group_GlobalExclusiveCommand"/>
			<param name="el">
			</param>
		</member>
		<member name="M:Group_Handoff" syntax="Group_Handoff(i, a[], s)">
			<stacksize value="7"/>
			<referrer name="HANDOFF_SOURCE@_Group"/>
			<dependency name="YSI_g_sDefaultMembership"/>
			<dependency name="YSI_g_sElementMembership"/>
			<dependency name="YSI_g_sElementMembership"/>
			<dependency name="cellbits"/>
			<dependency name="memcpy"/>
			<dependency name="min"/>
			<param name="i">
			</param>
			<param name="a">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="s">
			</param>
		</member>
		<member name="M:Group_SetCommand" syntax="Group_SetCommand(g, el, s)">
			<stacksize value="11"/>
			<automaton name="@_"/>
			<referrer name="Group_SetCommand@"/>
			<referrer name="Group_SetGlobalCommand"/>
			<dependency name="Group_FullPlayerUpdate"/>
			<dependency name="H@"/>
			<dependency name="Iterator@Player"/>
			<dependency name="YSI_gGroupPlayers"/>
			<dependency name="YSI_gGroupPlayers"/>
			<dependency name="YSI_gTempGroups"/>
			<dependency name="YSI_g_sElementMembership"/>
			<dependency name="YSI_g_sElementMembership"/>
			<dependency name="cellbits"/>
			<param name="g">
				<paraminfo>Group </paraminfo>
				Group to set for.
			</param>
			<param name="el">
				Element to set.
			</param>
			<param name="s">
				<paraminfo>bool </paraminfo>
				Set or unset?
			</param>
			<summary>Group_Set...</summary>        <remarks>  If "s" is true, then one element is added to the current group.  False it is  removed.  </remarks> 
		</member>
		<member name="M:Group_SetCommand@" syntax="Group_SetCommand@(g, el, s)">
			<stacksize value="6"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="Group_SetCommand"/>
			<param name="g">
				<paraminfo>Group </paraminfo>
			</param>
			<param name="el">
			</param>
			<param name="s">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Group_SetCommandDefault" syntax="Group_SetCommandDefault(g, s)">
			<stacksize value="1014"/>
			<automaton name="@_"/>
			<referrer name="Group_SetCommandDefault@"/>
			<referrer name="Group_SetGlobalCommandDefault"/>
			<dependency name="Group_FullPlayerUpdate"/>
			<dependency name="H@"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iterator@Player"/>
			<dependency name="YSI_gGroupPlayers"/>
			<dependency name="YSI_gGroupPlayers"/>
			<dependency name="YSI_g_sDefaultMembership"/>
			<dependency name="YSI_g_sElementMembership"/>
			<dependency name="YSI_g_sElementMembership"/>
			<dependency name="YSI_g_sMaxEncountered"/>
			<dependency name="cellbits"/>
			<param name="g">
				<paraminfo>Group </paraminfo>
				Group to set for.
			</param>
			<param name="s">
				<paraminfo>bool </paraminfo>
				Set or unset?
			</param>
			<summary>Group_Set...Default</summary>      <remarks>  If "s" is true, then all elements are added to this group (i.e. the default  is set to true and all previous settings are wiped out).  If it is false  then all elements are removed and a full update is done.  </remarks> 
		</member>
		<member name="M:Group_SetCommandDefault@" syntax="Group_SetCommandDefault@(g, s)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="Group_SetCommandDefault"/>
			<param name="g">
				<paraminfo>Group </paraminfo>
			</param>
			<param name="s">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Group_SetCommandNew" syntax="Group_SetCommandNew(g, s)">
			<stacksize value="6"/>
			<automaton name="@_"/>
			<referrer name="Group_SetCommandNew@"/>
			<referrer name="Group_SetGlobalCommandNew"/>
			<dependency name="Bit_Set"/>
			<dependency name="H@"/>
			<dependency name="YSI_g_sDefaultMembership"/>
			<param name="g">
				<paraminfo>Group </paraminfo>
				Group to set for.
			</param>
			<param name="s">
				<paraminfo>bool </paraminfo>
				Set or unset?
			</param>
			<summary>Group_Set...New</summary>      <remarks>  Similar to "Group_Set...Default", but doesn't reset all existing elements,  just sets the permissions for any future items.  </remarks> 
		</member>
		<member name="M:Group_SetCommandNew@" syntax="Group_SetCommandNew@(g, s)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="Group_SetCommandNew"/>
			<param name="g">
				<paraminfo>Group </paraminfo>
			</param>
			<param name="s">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Group_SetGlobalCommand" syntax="Group_SetGlobalCommand(el, s)">
			<stacksize value="6"/>
			<automaton name="@_"/>
			<referrer name="Group_SetGlobalCommand@"/>
			<dependency name="Group_SetCommand"/>
			<dependency name="H@"/>
			<param name="el">
				Element to set.
			</param>
			<param name="s">
				<paraminfo>bool </paraminfo>
				Set or unset?
			</param>
			<summary>Group_SetGlobal...</summary>      <remarks>  If "s" is true, then one element is added to the global group.  False it is  removed.  </remarks> 
		</member>
		<member name="M:Group_SetGlobalCommand@" syntax="Group_SetGlobalCommand@(el, s)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="Group_SetGlobalCommand"/>
			<param name="el">
			</param>
			<param name="s">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Group_SetGlobalCommandDefault" syntax="Group_SetGlobalCommandDefault(s)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Group_SetGlobalCommandDefault@"/>
			<dependency name="Group_SetCommandDefault"/>
			<dependency name="H@"/>
			<param name="s">
				<paraminfo>bool </paraminfo>
				Set or unset?
			</param>
			<summary>Group_SetGlobal...Default</summary>    <remarks>  If "s" is true, then all elements are added to the global group (i.e. the  default is set to true and all previous settings are wiped out).  If it is  false then all elements are removed and a full update is done.  </remarks> 
		</member>
		<member name="M:Group_SetGlobalCommandDefault@" syntax="Group_SetGlobalCommandDefault@(s)">
			<stacksize value="4"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="Group_SetGlobalCommandDefault"/>
			<param name="s">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Group_SetGlobalCommandNew" syntax="Group_SetGlobalCommandNew(s)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Group_SetGlobalCommandNew@"/>
			<dependency name="Group_SetCommandNew"/>
			<dependency name="H@"/>
			<param name="s">
				<paraminfo>bool </paraminfo>
				Set or unset?
			</param>
			<summary>Group_SetGlobal...New</summary>    <remarks>  All elements created FROM THIS POINT ON will have this default setting.  </remarks> 
		</member>
		<member name="M:Group_SetGlobalCommandNew@" syntax="Group_SetGlobalCommandNew@(s)">
			<stacksize value="4"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="Group_SetGlobalCommandNew"/>
			<param name="s">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:H@" syntax="H@(...)">
			<stacksize value="1"/>
			<referrer name="Group_SetCommand"/>
			<referrer name="Group_GetCommand"/>
			<referrer name="Group_SetCommandDefault"/>
			<referrer name="Group_SetCommandNew"/>
			<referrer name="Group_ExclusiveCommand"/>
			<referrer name="Group_SetGlobalCommand"/>
			<referrer name="Group_GetGlobalCommand"/>
			<referrer name="Group_SetGlobalCommandDefault"/>
			<referrer name="Group_SetGlobalCommandNew"/>
			<referrer name="Group_GlobalExclusiveCommand"/>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:HANDOFF_SOURCE@_" syntax="HANDOFF_SOURCE@_()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="@_"/>
			<dependency name="YSI_g_sCommandFlags_Dist"/>
			<dependency name="YSI_g_sCommands_Dist"/>
			<dependency name="YSI_g_sDisabledPlayers_Dist"/>
			<dependency name="YSI_g_sErrorMessages_Dist"/>
			<dependency name="_Command_Rebuild"/>
			<remarks>  Passes additional commands data to the new master.  </remarks> 
		</member>
		<member name="M:HANDOFF_SOURCE@_Group" syntax="HANDOFF_SOURCE@_Group()">
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="Group_Handoff"/>
			<dependency name="YSI_g_sDefaultMembership"/>
			<dependency name="YSI_g_sElementMembership"/>
			<dependency name="YSI_g_sElementMembership"/>
		</member>
		<member name="M:HPdaj" syntax="HPdaj(playerid)">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="Float:operator=(_:)"/>
			<dependency name="SendClientMessage"/>
			<dependency name="SetPlayerHealth"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:HashMap_Add" syntax="HashMap_Add(m[], str[], value, ignorecase)">
			<tagname value="bool"/>
			<stacksize value="8"/>
			<referrer name="HashMap_Set"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="_Command_Rebuild"/>
			<referrer name="Command_Add"/>
			<dependency name="AMX_Write"/>
			<dependency name="Debug_Print0"/>
			<dependency name="YHash"/>
			<dependency name="false"/>
			<dependency name="rawMemcpy"/>
			<dependency name="ref"/>
			<dependency name="strcmp"/>
			<dependency name="true"/>
			<param name="m">
				<paraminfo> [260] </paraminfo>
				
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
				
			</param>
			<param name="value">
				More like the target slot.
			</param>
			<param name="ignorecase">
				<paraminfo>bool </paraminfo>
			</param>
			      <remarks>  Adds a value to the given hash map under the given string key.  Actually more like adding an index, not a value...  </remarks> 
		</member>
		<member name="M:HashMap_ByteLen" syntax="HashMap_ByteLen(str[])">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to get the size of.
			</param>
			  <returns>  The number of BYTES this string takes up including the NULL.  </returns>  <remarks>  Caters for both packed and unpacked strings.  The weirdness is basically  just: <code>ispacked(str) ? (* 1) : (* 4)</code>.  </remarks> 
		</member>
		<member name="M:HashMap_Get" syntax="HashMap_Get(m[], str[], ignorecase)">
			<stacksize value="10"/>
			<referrer name="Command_Find"/>
			<dependency name="HashMap_GetWithHash"/>
			<dependency name="YHash"/>
			<param name="m">
				<paraminfo> [260] </paraminfo>
				The hash map to search.
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The key to find.
			</param>
			<param name="ignorecase">
				<paraminfo>bool </paraminfo>
			</param>
			    <returns>  The value associated with this key in the given hash map.  </returns> 
		</member>
		<member name="M:HashMap_GetBranchEnd" syntax="HashMap_GetBranchEnd(cur, &amp;height, &amp;parent, dir)">
			<stacksize value="4"/>
			<referrer name="HashMap_RemoveKeyWithHash"/>
			<dependency name="AMX_Read"/>
			<param name="cur">
			</param>
			<param name="height">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="parent">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="dir">
			</param>
		</member>
		<member name="M:HashMap_GetWithHash" syntax="HashMap_GetWithHash(m[], str[], hash, ignorecase)">
			<stacksize value="5"/>
			<referrer name="HashMap_Get"/>
			<referrer name="Command_ReProcess"/>
			<dependency name="ref"/>
			<dependency name="strcmp"/>
			<param name="m">
				<paraminfo> [260] </paraminfo>
				The hash map to search.
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The key to find.
			</param>
			<param name="hash">
				The hashed key.
			</param>
			<param name="ignorecase">
				<paraminfo>bool </paraminfo>
			</param>
			      <returns>  The value associated with this key in the given hash map.  </returns> 
		</member>
		<member name="M:HashMap_Hash" syntax="HashMap_Hash(str[], &amp;hash)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to hash.
			</param>
			<param name="hash">
				<paraminfo> &amp; </paraminfo>
				Desination of the hash.
			</param>
			    <remarks>  Quickly hashes the string using Bernstein.  Caters for both packed and  unpacked strings.  </remarks> 
		</member>
		<member name="M:HashMap_Init" syntax="HashMap_Init(m[], target[][], slot)">
			<stacksize value="1"/>
			<param name="m">
				<paraminfo> [260] </paraminfo>
				Hash map to initialise.
			</param>
			<param name="target">
				<paraminfo> [][] </paraminfo>
				Array to point in to.
			</param>
			<param name="slot">
				Second dimension slot of the hashed data.
			</param>
			      <remarks>  Finds the location of the hash map linked list data in the passed array data  and uses that to read the data through pointers subsequently.  It doesn't  matter WHERE in the enum the hash map data is, and if its not there you'll  get an error, or at least a warning.  </remarks> 
		</member>
		<member name="M:HashMap_RemoveKey" syntax="HashMap_RemoveKey(m[], str[], ignorecase)">
			<tagname value="bool"/>
			<stacksize value="10"/>
			<referrer name="HashMap_RemoveValue"/>
			<referrer name="HashMap_Set"/>
			<dependency name="HashMap_RemoveKeyWithHash"/>
			<dependency name="YHash"/>
			<param name="m">
				<paraminfo> [260] </paraminfo>
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="ignorecase">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:HashMap_RemoveKeyWithHash" syntax="HashMap_RemoveKeyWithHash(m[], str[], hash, ignorecase)">
			<tagname value="bool"/>
			<stacksize value="17"/>
			<referrer name="HashMap_RemoveKey"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="HashMap_GetBranchEnd"/>
			<dependency name="false"/>
			<dependency name="ref"/>
			<dependency name="strcmp"/>
			<dependency name="true"/>
			<param name="m">
				<paraminfo> [260] </paraminfo>
				The hash map to modify.
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The key to remove from the hash map.
			</param>
			<param name="hash">
			</param>
			<param name="ignorecase">
				<paraminfo>bool </paraminfo>
			</param>
			    <remarks>  Removes a given key and its associated value from the given hash map (if it  can be found in the map in the first place).  </remarks> 
		</member>
		<member name="M:HashMap_RemoveValue" syntax="HashMap_RemoveValue(m[], value)">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<referrer name="HashMap_Set"/>
			<referrer name="Command_Remove"/>
			<dependency name="HashMap_RemoveKey"/>
			<dependency name="false"/>
			<dependency name="min"/>
			<dependency name="rawMemcpy"/>
			<dependency name="ref"/>
			<param name="m">
				<paraminfo> [260] </paraminfo>
				Hash map to modify.
			</param>
			<param name="value">
				Value to remove.
			</param>
			    <remarks>  Removes a value from the hash map.  First it gets the string key for the  value, then removes that (to update associated linked lists correctly).  </remarks> 
		</member>
		<member name="M:HashMap_Set" syntax="HashMap_Set(m[], str[], value)">
			<stacksize value="7"/>
			<dependency name="HashMap_Add"/>
			<dependency name="HashMap_RemoveKey"/>
			<dependency name="HashMap_RemoveValue"/>
			<param name="m">
				<paraminfo> [260] </paraminfo>
				The hash map to modify.
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The key to modify.
			</param>
			<param name="value">
				The new value for the given key.
			</param>
			      <remarks>  If this key is already in the hash map it is removed, and then the new value  is added in its place.  If the string already exists, its associated data is  removed.  If the value already exists, it is removed as well.  </remarks> 
		</member>
		<member name="M:HaveToRelocateOpcodes" syntax="HaveToRelocateOpcodes()">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="RelocateOpcodeNow"/>
			<dependency name="OP_CALL"/>
			<dependency name="ReadOpcodeNearThis"/>
		</member>
		<member name="M:HeapAllocBytes" syntax="HeapAllocBytes(nbytes)">
			<stacksize value="2"/>
			<referrer name="HeapAllocCells"/>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:HeapAllocCells" syntax="HeapAllocCells(ncells)">
			<stacksize value="4"/>
			<dependency name="HeapAllocBytes"/>
			<param name="ncells">
			</param>
		</member>
		<member name="M:HeapRelease" syntax="HeapRelease(address)">
			<stacksize value="1"/>
			<param name="address">
			</param>
		</member>
		<member name="M:HookChain_OnScriptInit" syntax="HookChain_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="8"/>
			<automaton name="_ALS"/>
			<referrer name="Malloc_OnScriptInit"/>
			<dependency name="CallLocalFunction"/>
			<dependency name="CallRemoteFunction"/>
			<dependency name="Master_OnScriptInit"/>
			<dependency name="_@"/>
			<dependency name="existproperty"/>
			<dependency name="getproperty"/>
			<dependency name="setproperty"/>
			<returns>  OnScriptInit  </returns>  <remarks>  Constructor.  Gets the script a master ID.  Now ALWAYS gets an ID, even if  the master system is disabled - doing otherwise is just too complicated.  </remarks>  <transition keep="true" target="_ALS : _ALS_go" />  <transition target="_ALS_go" source="_ALS_go"/>

		</member>
		<member name="M:HookNative" syntax="HookNative(index, address)">
			<stacksize value="8"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="GetNumNatives"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="WriteAmxMemory"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="index">
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:HookPublic" syntax="HookPublic(index, address)">
			<stacksize value="8"/>
			<referrer name="ProfilerInit"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetNumPublics"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="WriteAmxMemory"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="index">
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:Hooks_Collate" syntax="Hooks_Collate(preloads[][], precount, name[], idx)">
			<stacksize value="18"/>
			<referrer name="Hooks_DoAllHooks"/>
			<dependency name="Hooks_GenerateCode"/>
			<dependency name="Hooks_GetAllHooks"/>
			<dependency name="Hooks_GetPointerRewrite"/>
			<dependency name="Hooks_GetPreHooks"/>
			<dependency name="Hooks_IsolateName"/>
			<dependency name="Hooks_MakeLongName"/>
			<dependency name="strlen"/>
			<dependency name="strunpack"/>
			<param name="preloads">
				<paraminfo> [][17] </paraminfo>
			</param>
			<param name="precount">
			</param>
			<param name="name">
				<paraminfo> [32] </paraminfo>
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:Hooks_CompareNextCell" syntax="Hooks_CompareNextCell(addr0, addr1)">
			<stacksize value="6"/>
			<referrer name="Hooks_ComparePublics"/>
			<dependency name="AMX_Read"/>
			<dependency name="Cell_ReverseBytes"/>
			<param name="addr0">
				The 1st address to read.
			</param>
			<param name="addr1">
				The 2nd address to read.
			</param>
			    <returns>  -1 - The first address is bigger.  0  - The addresses are the same  1  - The second address is bigger.  </returns>  <remarks>  Reads two addresses, converts them to big endian, and compares them as four  characters of a string at once.  </remarks> 
		</member>
		<member name="M:Hooks_ComparePublics" syntax="Hooks_ComparePublics(idx0, idx1)">
			<stacksize value="9"/>
			<referrer name="Hooks_SortPublics"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="Hooks_CompareNextCell"/>
			<param name="idx0">
				The index of the 1st public.
			</param>
			<param name="idx1">
				The index of the 2nd public.
			</param>
			    <remarks>  Compares two public function entries, and if need-be, swaps them over.  </remarks> 
		</member>
		<member name="M:Hooks_CountInvalidPublics" syntax="Hooks_CountInvalidPublics()">
			<stacksize value="10"/>
			<referrer name="Hooks_SortPublics"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<remarks>  Counts the number of public functions that have had their names erased.  </remarks> 
		</member>
		<member name="M:Hooks_DoAllHooks" syntax="Hooks_DoAllHooks()">
			<stacksize value="185"/>
			<referrer name="Malloc_OnScriptInit"/>
			<dependency name="AMX_GetNamePrefix"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="E_PRE_HOOK"/>
			<dependency name="Hooks_Collate"/>
			<dependency name="Hooks_GetPreloadLibraries"/>
			<dependency name="Hooks_SortPublics"/>
		</member>
		<member name="M:Hooks_GenerateCode" syntax="Hooks_GenerateCode(name[], hooks[], count, write, hasprehooks)">
			<stacksize value="7"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_REAL_DATA"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="CGen_AddCodeSpace"/>
			<dependency name="CGen_GetCodeSpace"/>
			<dependency name="Hooks_GetDefaultReturn"/>
			<dependency name="Hooks_WriteFunction"/>
			<param name="name">
				<paraminfo> [64] </paraminfo>
				Name of the function to generate.
			</param>
			<param name="hooks">
				<paraminfo> [] </paraminfo>
				All the functions to call.
			</param>
			<param name="count">
				Number of functions to call.
			</param>
			<param name="write">
				Where to write the new function's pointer.
			</param>
			<param name="hasprehooks">
				<paraminfo>bool </paraminfo>
				Needs to call other stuff first.
			</param>
			         
		</member>
		<member name="M:Hooks_GetAllHooks" syntax="Hooks_GetAllHooks(name[], hooks[], idx, &amp;namelen)">
			<stacksize value="73"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<dependency name="AMX_GetStringFromEntry"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="Debug_Print0"/>
			<dependency name="Hooks_InvalidateName"/>
			<dependency name="Hooks_IsolateName"/>
			<dependency name="Hooks_MakeLongName"/>
			<dependency name="strcmp"/>
			<dependency name="strlen"/>
			<dependency name="strunpack"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The name of the callback (with y_hooks prefix).
			</param>
			<param name="hooks">
				<paraminfo> [128] </paraminfo>
				Array in which to store the function headers.
			</param>
			<param name="idx">
				Current position in the AMX header.
			</param>
			<param name="namelen">
				<paraminfo> &amp; </paraminfo>
				Min bound of space used by all these names.
			</param>
			        <returns>  The number of hooks found.  </returns>  <remarks>  The name of the function currently being processed is derived from the first  found hook.  This means we already know of one hook, but to simplify the  code we get that one again here.  Above we only know the name not the  address.  Hence the "- 1" in "i = idx - 1" (to go back one function name).  Our "namelen" variable already contains the full length of the first found  hook - this is the length of "name", plus N extra characters.  The following  are all valid, and may occur when orders are played with:  @yH_OnX@  @yH_OnX@1  @yH_OnX@01  @yH_OnX@024  @yH_OnX@ZZZ  @yH_OnX@999@024  If we want to get the EXACT space taken up by all these hook names we would  need to get the string of the name in this function then measure it.  There  is really no point in doing this - if we have a second we will always have  enough space for our new names.  Instead, we assume that they are all just  @yH_OnX@  And add on that minimum length accordingly (plus 1 for the NULL character).  This length is used if the original callback doesn't exist but hooks do.  In  that case we need to add the callback to the AMX header, and there is a tiny  chance that the original name will be longer than one hook's name.  In that  case, having two or more hooks will (AFAIK) always ensure that we have  enough space to write the longer name.  If there is only one hook, no original function, and the name of the hook is  shorter than the name of the original function then we have an issue and  will have to do something else instead.  </remarks> 
		</member>
		<member name="M:Hooks_GetDefaultReturn" syntax="Hooks_GetDefaultReturn(name[])">
			<stacksize value="9"/>
			<referrer name="Hooks_GenerateCode"/>
			<dependency name="AMX_GetEntry"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="CallFunction"/>
			<dependency name="Hooks_MakeShortName"/>
			<dependency name="strins"/>
			<dependency name="true"/>
			<param name="name">
				<paraminfo> [64] </paraminfo>
				The function to get the default return of.
			</param>
			  <returns>  The default return for a callback, normally 1.  </returns> 
		</member>
		<member name="M:Hooks_GetFunctionWritePoint" syntax="Hooks_GetFunctionWritePoint(name[], &amp;write)">
			<stacksize value="8"/>
			<dependency name="AMX_GetEntry"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="true"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The function to get the address pointer of.
			</param>
			<param name="write">
				<paraminfo> &amp; </paraminfo>
				Destination variable.
			</param>
			    <returns>  The address at which this function's pointer is stored in the AMX header, if  the function exists of course.  </returns> 
		</member>
		<member name="M:Hooks_GetPointerRewrite" syntax="Hooks_GetPointerRewrite(hooks[], num, &amp;ptr, &amp;next, name[], nlen)">
			<stacksize value="39"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_REAL_DATA"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="AMX_WriteString"/>
			<dependency name="Debug_Print0"/>
			<dependency name="Hooks_GetStubEntry"/>
			<dependency name="OP_JUMP"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="strlen"/>
			<dependency name="strpack"/>
			<param name="hooks">
				<paraminfo> [] </paraminfo>
				All the prehooks for this callback.
			</param>
			<param name="num">
				The number of prehooks.
			</param>
			<param name="ptr">
				<paraminfo> &amp; </paraminfo>
				A pointer to write the new stub address to.
			</param>
			<param name="next">
				<paraminfo> &amp; </paraminfo>
				The pointer for the function called after y_hooks.
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The name of the callback being processed.
			</param>
			<param name="nlen">
				Space available in the header to write text in.
			</param>
			           
		</member>
		<member name="M:Hooks_GetPreHooks" syntax="Hooks_GetPreHooks(preloads[][], precount, name[], hooks[], &amp;count)">
			<stacksize value="73"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="AMX_GetEntry"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="E_PRE_HOOK_NAME"/>
			<dependency name="Hooks_MakeShortName"/>
			<dependency name="strcat"/>
			<dependency name="true"/>
			<param name="preloads">
				<paraminfo> [][17] </paraminfo>
				Names of libraries that come before y_hooks.
			</param>
			<param name="precount">
				Number of pre libraries.
			</param>
			<param name="name">
				<paraminfo> [64] </paraminfo>
				Name of the callback.
			</param>
			<param name="hooks">
				<paraminfo> [] </paraminfo>
				Destination in which to store the headers.
			</param>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
				Number of headers found.
			</param>
			          <remarks>  Finds all the AMX file headers for functions with a similar name to the  given callback that should be called before (or near) the given callback.  </remarks> 
		</member>
		<member name="M:Hooks_GetPreloadLibraries" syntax="Hooks_GetPreloadLibraries(preloads[][], &amp;precount, size)">
			<stacksize value="20"/>
			<referrer name="Hooks_DoAllHooks"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_ReadString"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="CallFunction"/>
			<dependency name="Debug_Print0"/>
			<dependency name="E_PRE_HOOK"/>
			<dependency name="E_PRE_HOOK_NAME"/>
			<dependency name="E_PRE_HOOK_VALUE"/>
			<dependency name="Hooks_InvalidateName"/>
			<dependency name="strunpack"/>
			<param name="preloads">
				<paraminfo> [][17] </paraminfo>
				Desination in which to store all the preloads.
			</param>
			<param name="precount">
				<paraminfo> &amp; </paraminfo>
				Number of found preload libraries.
			</param>
			<param name="size">
				Maximum number of libraries to store.
			</param>
			      <remarks>  Some includes, like "fixes.inc" and anti-cheats MUST come before all other  includes in order for everything to function correctly (at least fixes.inc  must).  This function looks for these definitions:  PRE_HOOK(FIXES)  Which tell y_hooks that any "FIXES_" prefixed callbacks are part of one of  these chains.  </remarks> 
		</member>
		<member name="M:Hooks_GetStubEntry" syntax="Hooks_GetStubEntry(stub)">
			<stacksize value="30"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<dependency name="Debug_Print0"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmGetNumOperands"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmInit"/>
			<dependency name="DisasmNextInsn"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_JUMP"/>
			<dependency name="OP_LOAD_PRI"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_SWITCH"/>
			<param name="stub">
				Starting address of the function.
			</param>
			  <returns>  The address at which the actual code in this function starts.  </returns>  <remarks>  This handles three cases.  Regular functions end instantly as found.  Functions that start with a switch (even before "PROC") are assumed to be  state-based functions, and we find the most likely state to be used (i.e. we  remove all future state changes).  </remarks> 
		</member>
		<member name="M:Hooks_InvalidateName" syntax="Hooks_InvalidateName(entry)">
			<stacksize value="5"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Malloc_OnScriptInit"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<param name="entry">
				The public function slot to destroy.
			</param>
			  <remarks>  Basically, once we know a function has been included, wipe it from the AMX  header.  </remarks> 
		</member>
		<member name="M:Hooks_IsolateName" syntax="Hooks_IsolateName(name[])">
			<stacksize value="138"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="Debug_Print0"/>
			<dependency name="false"/>
			<dependency name="strdel"/>
			<dependency name="strfind"/>
			<dependency name="unpack"/>
			<dependency name="unpack"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The string to get the hooked function name from.
			</param>
			  <returns>  The input string without y_hooks name decorations.  </returns> 
		</member>
		<member name="M:Hooks_MakeLongName" syntax="Hooks_MakeLongName(name[])">
			<stacksize value="10"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_LONG"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MAX"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MIN"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_SHORT"/>
			<dependency name="Hooks_MakeShortName"/>
			<dependency name="YSI_g_sReplacePtr"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacementsShortOrder"/>
			<dependency name="false"/>
			<dependency name="strdel"/>
			<dependency name="strfind"/>
			<dependency name="strins"/>
			<param name="name">
				<paraminfo> [64] </paraminfo>
				Function name to modify.
			</param>
			  <remarks>  Expands all name parts like "CP" and "Obj" to their full versions (in this  example "Checkpoint" and "Object").  </remarks> 
		</member>
		<member name="M:Hooks_MakeShortName" syntax="Hooks_MakeShortName(name[])">
			<stacksize value="10"/>
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_GetPreHooks"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_LONG"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MAX"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_SHORT"/>
			<dependency name="YSI_g_sReplacePtr"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacementsLongOrder"/>
			<dependency name="false"/>
			<dependency name="strdel"/>
			<dependency name="strfind"/>
			<dependency name="strins"/>
			<dependency name="strlen"/>
			<param name="name">
				<paraminfo> [64] </paraminfo>
				Function name to modify.
			</param>
			  <remarks>  Compresses function names when required to fit within 32 characters  according to well defined rules (see "YSI_g_sReplacements").  </remarks> 
		</member>
		<member name="M:Hooks_NumArgs" syntax="Hooks_NumArgs()">
			<stacksize value="1"/>
			<referrer name="Distribute_Do"/>
			<referrer name="Distribute_So"/>
			<referrer name="Distribute_To"/>
		</member>
		<member name="M:Hooks_SortPublics" syntax="Hooks_SortPublics()">
			<stacksize value="9"/>
			<referrer name="Hooks_DoAllHooks"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_HEADER_NATIVES"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="Hooks_ComparePublics"/>
			<dependency name="Hooks_CountInvalidPublics"/>
			<dependency name="ResetStaticAmxHeader"/>
			<remarks>  Goes through the whole of the public functions table and sorts them all in  to alphabetical order.  This is done as we move and rename some so we need  to fix the virtual machine's binary search.  </remarks> 
		</member>
		<member name="M:Hooks_SortReplacements" syntax="Hooks_SortReplacements()">
			<stacksize value="6"/>
			<referrer name="Malloc_OnScriptInit"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MAX"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MIN"/>
			<dependency name="YSI_g_sReplacePtr"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacementsLongOrder"/>
			<dependency name="YSI_g_sReplacementsShortOrder"/>
			<remarks>  Once all the replacement strings have been found, sort them by the length of  the short versions of the strings.  This is so that the longest (and special  case, e.g. "DynamicCP"-> "DynamicCP") replacements are always done first.  </remarks> 
		</member>
		<member name="M:Hooks_WriteFunction" syntax="Hooks_WriteFunction(pointers[], size, ret, skipable)">
			<stacksize value="29"/>
			<referrer name="Hooks_GenerateCode"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_REAL_ADDRESS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmEmitAddC"/>
			<dependency name="AsmEmitAnd"/>
			<dependency name="AsmEmitCall"/>
			<dependency name="AsmEmitInvert"/>
			<dependency name="AsmEmitJsgeqRel"/>
			<dependency name="AsmEmitJslessRel"/>
			<dependency name="AsmEmitJumpRel"/>
			<dependency name="AsmEmitLctrl"/>
			<dependency name="AsmEmitLoadSAlt"/>
			<dependency name="AsmEmitMoveAlt"/>
			<dependency name="AsmEmitMovePri"/>
			<dependency name="AsmEmitMovs"/>
			<dependency name="AsmEmitOr"/>
			<dependency name="AsmEmitProc"/>
			<dependency name="AsmEmitPushC"/>
			<dependency name="AsmEmitRetn"/>
			<dependency name="AsmEmitSctrl"/>
			<dependency name="AsmEmitStorPri"/>
			<dependency name="AsmEmitStorSPri"/>
			<dependency name="AsmEmitSub"/>
			<dependency name="AsmEmitXchg"/>
			<dependency name="AsmEmitZeroAlt"/>
			<dependency name="CGen_GetCodeSpace"/>
			<dependency name="CGen_UseCodeSpace"/>
			<dependency name="Debug_Print0"/>
			<param name="pointers">
				<paraminfo> [] </paraminfo>
				The hooks to link together.
			</param>
			<param name="size">
				The number of functions in the array.
			</param>
			<param name="ret">
				The default return.
			</param>
			<param name="skipable">
				Can future hooks be ignored on -1?
			</param>
			        <returns>  The number of bytes written to memory.  </returns>  <remarks>  Generate some new code, very nicely :D.  </remarks> 
		</member>
		<member name="M:I@E" syntax="I@E(s[])">
			<stacksize value="53"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_REAL_ADDRESS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmEmitJump"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="Debug_Print0"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<dependency name="DisasmDecodeInsn"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmInit"/>
			<dependency name="GetCurrentFrameParameter"/>
			<dependency name="GetCurrentFramePreviousFrame"/>
			<dependency name="GetCurrentFrameReturn"/>
			<dependency name="GetFrameLocalSize"/>
			<dependency name="GetFrameParameterSize"/>
			<dependency name="GetFramePreviousFrame"/>
			<dependency name="OP_BREAK"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CONST_PRI"/>
			<dependency name="OP_JZER"/>
			<dependency name="OP_PUSH_C"/>
			<dependency name="OP_PUSH_PRI"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="YSI_g_sCurInlineEntry"/>
			<dependency name="YSI_g_sCurInlineLocals"/>
			<dependency name="YSI_g_sCurInlineParams"/>
			<dependency name="YSI_g_sCurInlinePointer"/>
			<dependency name="YSI_g_sPrevInlineFunc"/>
			<dependency name="YSI_g_sPrevJumpOver"/>
			<dependency name="YSI_g_scError"/>
			<dependency name="ref"/>
			<dependency name="strfind"/>
			<param name="s">
				<paraminfo> [] </paraminfo>
				The array to store an inline function's data in.
			</param>
			  <param name="constFunc">Should this function copy the stack back?</param>  <remarks>  AKA. Inline_Entry  This function gets the start of an inline function's code block.  It then  removes itself from the compiled code so that it can never be called agian.  If "constFunc" is 3, copy the stack back, if it isn't don't.  </remarks> 
		</member>
		<member name="M:I@F" syntax="I@F()">
			<stacksize value="29"/>
			<dependency name="Debug_Print0"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmDecodeInsn"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmInit"/>
			<dependency name="GetCurrentFrameReturn"/>
			<dependency name="OP_BREAK"/>
			<dependency name="OP_JZER"/>
			<dependency name="YSI_g_sCurInlineCode"/>
			<dependency name="YSI_g_sCurInlineLoop"/>
			<dependency name="YSI_g_scError"/>
			<remarks>  AKA. Inline_Allocator.  This function determines the exact address of the start of the main inline  function container loop.  That is, the label that things like "continue"  jump to so that we know how much space we have to play with and where it is.  </remarks> 
		</member>
		<member name="M:I@K" syntax="I@K(...)">
			<stacksize value="2"/>
			<dependency name="numargs"/>
			<param name="...">
			</param>
		</member>
		<member name="M:I@L" syntax="I@L(constFunc, ...)">
			<stacksize value="57"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_REAL_ADDRESS"/>
			<dependency name="AMX_Write"/>
			<dependency name="ASM_ERROR_SPACE"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmContext_buffer_size"/>
			<dependency name="AsmEmitAddrAlt"/>
			<dependency name="AsmEmitAddrPri"/>
			<dependency name="AsmEmitLoadSAlt"/>
			<dependency name="AsmEmitLoadSPri"/>
			<dependency name="AsmEmitLrefSAlt"/>
			<dependency name="AsmEmitLrefSPri"/>
			<dependency name="AsmEmitMovs"/>
			<dependency name="AsmEmitNop"/>
			<dependency name="AsmEmitPopPri"/>
			<dependency name="AsmEmitProc"/>
			<dependency name="AsmEmitPushAdr"/>
			<dependency name="AsmEmitPushC"/>
			<dependency name="AsmEmitPushPri"/>
			<dependency name="AsmEmitPushS"/>
			<dependency name="AsmEmitRetn"/>
			<dependency name="AsmEmitSrefSAlt"/>
			<dependency name="AsmEmitStack"/>
			<dependency name="AsmEmitStorSPri"/>
			<dependency name="AsmEmitSysreq"/>
			<dependency name="AsmEmitZeroPri"/>
			<dependency name="AsmEmitZeroS"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="AsmSetErrorHandler"/>
			<dependency name="Debug_Print0"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmDecodeInsn"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmInit"/>
			<dependency name="GetCurrentFramePreviousFrame"/>
			<dependency name="GetCurrentFrameReturn"/>
			<dependency name="GetFrameLocalSize"/>
			<dependency name="GetPublicAddressFromName"/>
			<dependency name="OP_BREAK"/>
			<dependency name="OP_HEAP"/>
			<dependency name="OP_JZER"/>
			<dependency name="SetCurrentFrameReturn"/>
			<dependency name="YSI_g_sCurInlineCode"/>
			<dependency name="YSI_g_sCurInlineEntry"/>
			<dependency name="YSI_g_sCurInlineLocals"/>
			<dependency name="YSI_g_sCurInlineLoop"/>
			<dependency name="YSI_g_sCurInlineParams"/>
			<dependency name="YSI_g_sCurInlinePointer"/>
			<dependency name="YSI_g_sJumpAddress"/>
			<dependency name="YSI_g_sRequiredSpace"/>
			<dependency name="YSI_g_scError"/>
			<dependency name="cellmax"/>
			<dependency name="getarg"/>
			<dependency name="numargs"/>
			<param name="constFunc">
			</param>
			<param name="...">
			</param>
		</member>
		<member name="M:INI_AddToBuffer" syntax="INI_AddToBuffer(file, key[], value[])">
			<stacksize value="8"/>
			<referrer name="INI_RemoveEntry"/>
			<referrer name="INI_WriteString"/>
			<referrer name="INI_WriteInt"/>
			<referrer name="INI_WriteHex"/>
			<referrer name="INI_WriteBin"/>
			<referrer name="INI_WriteBool"/>
			<referrer name="INI_WriteFloat"/>
			<dependency name="E_INI_KV_ENTRY_NAME"/>
			<dependency name="E_INI_KV_ENTRY_NEXT"/>
			<dependency name="E_INI_KV_ENTRY_TEXT"/>
			<dependency name="E_INI_TAGS_START"/>
			<dependency name="INI_Flush"/>
			<dependency name="INI_NO_TAG"/>
			<dependency name="INI_SetTag"/>
			<dependency name="YSI_g_sINICurrentTag"/>
			<dependency name="YSI_g_sINITagBuffer"/>
			<dependency name="YSI_g_sINITagBuffer"/>
			<dependency name="YSI_g_sINIWriteBuffer"/>
			<dependency name="YSI_g_sINIWriteBuffer"/>
			<dependency name="YSI_g_sINIWriteFile"/>
			<dependency name="YSI_g_sINIWritePos"/>
			<dependency name="cellmax"/>
			<dependency name="strcat"/>
			<dependency name="strcmp"/>
			<dependency name="true"/>
			<param name="file">
				<paraminfo>INI </paraminfo>
				INI file to write to.
			</param>
			<param name="key">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="value">
				<paraminfo> [] </paraminfo>
			</param>
			  <param name="name">Data name to write.</param>  <param name="data">Data to write.</param>  <returns>  The slot written to, or -1 on failure.  </returns>  <remarks>  First checks the name doesn't already exist under the current tag header  and if it does overwrites the current value.  If not checks there's room  in the buffer to write to and purges the buffer if not.  Finally saves the  data in the buffer for writing when required and adds the data to the  relevant list for tag inclusion.  </remarks> 
		</member>
		<member name="M:INI_Bin" syntax="INI_Bin(name[], &amp;variable)">
			<stacksize value="1"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				Name of the INI key.
			</param>
			<param name="variable">
				<paraminfo> &amp; </paraminfo>
				Variable to fill with binary value.
			</param>
			   
		</member>
		<member name="M:INI_Bool" syntax="INI_Bool(name[], &amp;variable)">
			<stacksize value="1"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				Name of the INI key.
			</param>
			<param name="variable">
				<paraminfo>bool &amp; </paraminfo>
				Variable to fill with string value.
			</param>
			   
		</member>
		<member name="M:INI_Close" syntax="INI_Close(file)">
			<stacksize value="4"/>
			<referrer name="SacuvajKorisnike"/>
			<referrer name="OnDialogResponse"/>
			<dependency name="INI_WriteBuffer"/>
			<dependency name="YSI_g_sINIWriteFile"/>
			<dependency name="YSI_g_sINIWriteFile"/>
			<param name="file">
				<paraminfo>INI </paraminfo>
				Handle to the ini to close.
			</param>
			  <remarks>  Writes any outstanding buffer data to the file and ends the stream.  </remarks> 
		</member>
		<member name="M:INI_DeleteTag" syntax="INI_DeleteTag(file, tag[])">
			<stacksize value="40"/>
			<dependency name="E_INI_TAGS_NAME"/>
			<dependency name="E_INI_TAGS_START"/>
			<dependency name="INI_FreeEntry"/>
			<dependency name="INI_GetTag"/>
			<dependency name="INI_SetTag"/>
			<dependency name="YSI_g_sINICurrentTag"/>
			<dependency name="YSI_g_sINITagBuffer"/>
			<dependency name="YSI_g_sINITagBuffer"/>
			<dependency name="YSI_g_sINIWriteFile"/>
			<dependency name="cellmax"/>
			<dependency name="strunpack"/>
			<param name="file">
				<paraminfo>INI </paraminfo>
				INI file handle to write to.
			</param>
			<param name="tag">
				<paraminfo> [] </paraminfo>
				Name of the whole section to delete.
			</param>
			    <remarks>  Removes a [tag] section from a file.  </remarks> 
		</member>
		<member name="M:INI_DoParentTag" syntax="INI_DoParentTag(epos, search[], f, callback[], bExtra, extra, bPassTag, tag[], bFilter, filter[])">
			<stacksize value="53"/>
			<referrer name="INI_ParseFile"/>
			<referrer name="INI_DoParentTag"/>
			<dependency name="Callback_Call"/>
			<dependency name="INI_IdentifyLineType"/>
			<dependency name="YSI_g_sCurLine"/>
			<dependency name="e_INI_LINE_TYPE_DATALESS"/>
			<dependency name="e_INI_LINE_TYPE_INVALID"/>
			<dependency name="e_INI_LINE_TYPE_TAG"/>
			<dependency name="false"/>
			<dependency name="fread"/>
			<dependency name="fseek"/>
			<dependency name="seek_start"/>
			<dependency name="strcat"/>
			<dependency name="strcmp"/>
			<dependency name="strfind"/>
			<dependency name="true"/>
			<param name="epos">
			</param>
			<param name="search">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="f">
				<paraminfo>File </paraminfo>
			</param>
			<param name="callback">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="bExtra">
				<paraminfo>bool </paraminfo>
				Send additional data.
			</param>
			<param name="extra">
				Additional data to send.
			</param>
			<param name="bPassTag">
				<paraminfo>bool </paraminfo>
				Pass the tag as an extra parameter not the function  name.
			</param>
			<param name="tag">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="bFilter">
				<paraminfo>bool </paraminfo>
				Apply the tag name filter to all tags or just prefixed  ones?
			</param>
			<param name="filter">
				<paraminfo> [] </paraminfo>
				Text to use to search for which tags to load.
			</param>
			<param name="filename">The file to load.</param>  <param name="remoteFormat">The format string to generate the remote function  t pass the data to once loaded.</param>  <param name="bFileFirst">The order of the remoteFormat parameters.</param>      <param name="bLocal">Call local functions instead of global ones.</param>        <remarks>  bFileFirst sets the order and inclusion of the possible remoteFormat  parameters.  If true the format will add the filename first then the   current tag, if false the order will be reversed.  This can also be used  to exclude one or the other from the function name by setting the required  parameter to be entered first and then only having one %s in the format  sting.  The default order is tag first for languages compatibility.  </remarks> 
		</member>
		<member name="M:INI_DumpTag" syntax="INI_DumpTag(buffer, curTag)">
			<stacksize value="5"/>
			<referrer name="INI_WriteBuffer"/>
			<dependency name="E_INI_KV_ENTRY_NAME"/>
			<dependency name="E_INI_KV_ENTRY_TEXT"/>
			<dependency name="E_INI_TAGS_START"/>
			<dependency name="INI_FreeEntry"/>
			<dependency name="YSI_g_sINITagBuffer"/>
			<dependency name="YSI_g_sINIWriteBuffer"/>
			<dependency name="YSI_g_sINIWriteBuffer"/>
			<dependency name="fwrite"/>
			<param name="buffer">
				<paraminfo>File </paraminfo>
			</param>
			<param name="curTag">
			</param>
		</member>
		<member name="M:INI_Float" syntax="INI_Float(name[], &amp;variable)">
			<stacksize value="1"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				Name of the INI key.
			</param>
			<param name="variable">
				<paraminfo>Float &amp; </paraminfo>
				Variable to fill with float value.
			</param>
			   
		</member>
		<member name="M:INI_Flush" syntax="INI_Flush()">
			<tagname value="bool"/>
			<stacksize value="39"/>
			<referrer name="INI_SetTag"/>
			<referrer name="INI_AddToBuffer"/>
			<dependency name="E_INI_TAGS_NAME"/>
			<dependency name="INI_SetTag"/>
			<dependency name="INI_WriteBuffer"/>
			<dependency name="YSI_g_sINICurrentTag"/>
			<dependency name="YSI_g_sINITagBuffer"/>
			<dependency name="YSI_g_sINITagBuffer"/>
			<dependency name="YSI_g_sINIWriteFile"/>
			<dependency name="false"/>
			<dependency name="strunpack"/>
			<dependency name="true"/>
		</member>
		<member name="M:INI_FreeEntry" syntax="INI_FreeEntry(slot)">
			<stacksize value="2"/>
			<referrer name="INI_DeleteTag"/>
			<referrer name="INI_DumpTag"/>
			<dependency name="E_INI_KV_ENTRY_NEXT"/>
			<dependency name="YSI_g_sINIWriteBuffer"/>
			<dependency name="YSI_g_sINIWriteBuffer"/>
			<dependency name="YSI_g_sINIWritePos"/>
			<param name="slot">
				Slot to remove.
			</param>
			  <remarks>  </remarks> 
		</member>
		<member name="M:INI_FreeTag" syntax="INI_FreeTag(file, tag)">
			<stacksize value="3"/>
			<referrer name="INI_WriteBuffer"/>
			<dependency name="E_INI_TAGS_NEXT"/>
			<dependency name="YSI_g_sINIStartTag"/>
			<dependency name="YSI_g_sINITagBuffer"/>
			<dependency name="YSI_g_sINITagBuffer"/>
			<dependency name="YSI_g_sINITagPos"/>
			<param name="file">
				<paraminfo>INI </paraminfo>
			</param>
			<param name="tag">
			</param>
		</member>
		<member name="M:INI_GetCallback" syntax="INI_GetCallback(callback, format, tag, input, callbackFormat, remote)">
			<stacksize value="1"/>
			<param name="callback">
				The callback destination.
			</param>
			<param name="format">
				The function name format.
			</param>
			<param name="tag">
				The tag destination.
			</param>
			<param name="input">
				The tag source.
			</param>
			<param name="callbackFormat">
				The callback parameter specifiers.
			</param>
			<param name="remote">
				Use "CallRemoteFunction".
			</param>
			            <returns>  Was the function found?  </returns>  <remarks>  Gets a callback given a partial function name and a tag name.  Also saves  the tag elsewhere.  This might not work as a separate function - it will  need to be in the function called by the function with the inlines in.  </remarks> 
		</member>
		<member name="M:INI_GetTag" syntax="INI_GetTag(file, tag[])">
			<stacksize value="7"/>
			<referrer name="INI_SetTag"/>
			<referrer name="INI_DeleteTag"/>
			<referrer name="INI_WriteBuffer"/>
			<dependency name="E_INI_TAGS_NAME"/>
			<dependency name="E_INI_TAGS_NEXT"/>
			<dependency name="YSI_g_sINIStartTag"/>
			<dependency name="YSI_g_sINITagBuffer"/>
			<dependency name="YSI_g_sINITagBuffer"/>
			<dependency name="strcmp"/>
			<dependency name="true"/>
			<param name="file">
				<paraminfo>INI </paraminfo>
			</param>
			<param name="tag">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:INI_Hex" syntax="INI_Hex(name[], &amp;variable)">
			<stacksize value="1"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				Name of the INI key.
			</param>
			<param name="variable">
				<paraminfo> &amp; </paraminfo>
				Variable to fill with hex value.
			</param>
			   
		</member>
		<member name="M:INI_IdentifyLineType" syntax="INI_IdentifyLineType(str[], &amp;p0s, &amp;p0e, &amp;p1s, &amp;p1e, &amp;p2s, &amp;p2e)">
			<tagname value="e_INI_LINE_TYPE"/>
			<stacksize value="6"/>
			<referrer name="INI_ParseFile"/>
			<referrer name="INI_DoParentTag"/>
			<referrer name="INI_WriteBuffer"/>
			<dependency name="e_INI_LINE_TYPE_DATALESS"/>
			<dependency name="e_INI_LINE_TYPE_ENTRY"/>
			<dependency name="e_INI_LINE_TYPE_INVALID"/>
			<dependency name="e_INI_LINE_TYPE_TAG"/>
			<dependency name="strlen"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string you want to type analyse.
			</param>
			<param name="p0s">
				<paraminfo> &amp; </paraminfo>
				Start of part 0.
			</param>
			<param name="p0e">
				<paraminfo> &amp; </paraminfo>
				End of part 0.
			</param>
			<param name="p1s">
				<paraminfo> &amp; </paraminfo>
				Start of part 1.
			</param>
			<param name="p1e">
				<paraminfo> &amp; </paraminfo>
				End of part 1.
			</param>
			<param name="p2s">
				<paraminfo> &amp; </paraminfo>
				Start of part 2.
			</param>
			<param name="p2e">
				<paraminfo> &amp; </paraminfo>
				End of part 2.
			</param>
			              <param name="cont">Is this a line continuation?</param>  <returns>  e_INI_LINE_TYPE  </returns>  <remarks>  This function's signature is so long that I put it on a separate line.  This  takes a line and determines what it is and where the parts are.  </remarks> 
		</member>
		<member name="M:INI_Int" syntax="INI_Int(name[], &amp;variable)">
			<stacksize value="1"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				Name of the INI key.
			</param>
			<param name="variable">
				<paraminfo> &amp; </paraminfo>
				Variable to fill with integer value.
			</param>
			   
		</member>
		<member name="M:INI_Load" syntax="INI_Load(filename[], bExtra, extra, bLocal)">
			<tagname value="bool"/>
			<stacksize value="13"/>
			<dependency name="INI_ParseFile"/>
			<dependency name="true"/>
			<param name="filename">
				<paraminfo> [] </paraminfo>
				The file to load.
			</param>
			<param name="bExtra">
				<paraminfo>bool </paraminfo>
				Send additional data.
			</param>
			<param name="extra">
				Additional data to send.
			</param>
			<param name="bLocal">
				<paraminfo>bool </paraminfo>
				Call local functions instead of gloabal ones.
			</param>
			        <returns>  INI_ParseFile  </returns>  <remarks>  Wrapper for INI_ParseFile to use standard API features so people can  worry even less.  Designed for use with INI_Parse.  </remarks> 
		</member>
		<member name="M:INI_MakeCallbackFormat" syntax="INI_MakeCallbackFormat(bExtra, bPassTag, callbackFormat[])">
			<stacksize value="1"/>
			<referrer name="INI_ParseFile"/>
			<param name="bExtra">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="bPassTag">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="callbackFormat">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:INI_Open" syntax="INI_Open(filename[])">
			<tagname value="INI"/>
			<stacksize value="6"/>
			<referrer name="SacuvajKorisnike"/>
			<referrer name="OnDialogResponse"/>
			<dependency name="Debug_Print0"/>
			<dependency name="YSI_g_sINICurrentTag"/>
			<dependency name="YSI_g_sINIStartTag"/>
			<dependency name="YSI_g_sINIWriteFile"/>
			<dependency name="YSI_g_sINIWriteFile"/>
			<dependency name="ftouch"/>
			<dependency name="strcat"/>
			<param name="filename">
				<paraminfo> [] </paraminfo>
				INI file to open.
			</param>
			  <returns>  INI - handle to the file or INI_NO_FILE.  </returns>  <remarks>  Doesn't actually open the file, just starts a new buffer if possible.  </remarks> 
		</member>
		<member name="M:INI_ParseFile" syntax="INI_ParseFile(fname[], remoteFormat[], bFileFirst, bExtra, extra, bLocal, bPassTag, bFilter, filter[])">
			<tagname value="bool"/>
			<stacksize value="55"/>
			<referrer name="INI_Load"/>
			<referrer name="SSCANF_OnPlayerConnect"/>
			<referrer name="OnDialogResponse"/>
			<dependency name="Callback_Call"/>
			<dependency name="Callback_Get"/>
			<dependency name="Callback_Release"/>
			<dependency name="Callback_Restore"/>
			<dependency name="Debug_Print0"/>
			<dependency name="E_CALLBACK_DATA"/>
			<dependency name="INI_DoParentTag"/>
			<dependency name="INI_IdentifyLineType"/>
			<dependency name="INI_MakeCallbackFormat"/>
			<dependency name="INI_SetupCallbackName"/>
			<dependency name="Inline_Reset"/>
			<dependency name="YSI_g_sCurLine"/>
			<dependency name="e_INI_LINE_TYPE_DATALESS"/>
			<dependency name="e_INI_LINE_TYPE_INVALID"/>
			<dependency name="e_INI_LINE_TYPE_TAG"/>
			<dependency name="false"/>
			<dependency name="fclose"/>
			<dependency name="fopen"/>
			<dependency name="format"/>
			<dependency name="fread"/>
			<dependency name="fseek"/>
			<dependency name="io_read"/>
			<dependency name="seek_start"/>
			<dependency name="strcat"/>
			<dependency name="strcmp"/>
			<dependency name="strfind"/>
			<dependency name="true"/>
			<param name="fname">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="remoteFormat">
				<paraminfo> [] </paraminfo>
				The format string to generate the remote function to  pass the data to once loaded.
			</param>
			<param name="bFileFirst">
				<paraminfo>bool </paraminfo>
				The order of the remoteFormat parameters.
			</param>
			<param name="bExtra">
				<paraminfo>bool </paraminfo>
				Send additional data.
			</param>
			<param name="extra">
				Additional data to send.
			</param>
			<param name="bLocal">
				<paraminfo>bool </paraminfo>
				Call local functions instead of global ones.
			</param>
			<param name="bPassTag">
				<paraminfo>bool </paraminfo>
				Pass the tag as an extra parameter not the function  name.
			</param>
			<param name="bFilter">
				<paraminfo>bool </paraminfo>
				Apply the tag name filter to all tags or just prefixed  ones?
			</param>
			<param name="filter">
				<paraminfo> [] </paraminfo>
				Text to use to search for which tags to load.
			</param>
			<param name="filename">The file to load.</param>                  <remarks>  bFileFirst sets the order and inclusion of the possible remoteFormat  parameters.  If true the format will add the filename first then the   current tag, if false the order will be reversed.  This can also be used  to exclude one or the other from the function name by setting the required  parameter to be entered first and then only having one %s in the format  sting.  The default order is tag first for languages compatibility.  This function is now EXTENSIVELY documented here:  <a href="http://forum.sa-mp.com/showthread.php?t=485611" />  </remarks> 
		</member>
		<member name="M:INI_RemoveEntry" syntax="INI_RemoveEntry(file, name[])">
			<stacksize value="6"/>
			<dependency name="INI_AddToBuffer"/>
			<dependency name="NULL"/>
			<param name="file">
				<paraminfo>INI </paraminfo>
				File to write to.
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
				Item to remove.
			</param>
			    <remarks>  Wrapper for INI_AddToBuffer for removing data.  </remarks> 
		</member>
		<member name="M:INI_SetTag" syntax="INI_SetTag(file, tag[])">
			<stacksize value="6"/>
			<referrer name="INI_DeleteTag"/>
			<referrer name="INI_AddToBuffer"/>
			<referrer name="INI_Flush"/>
			<referrer name="SacuvajKorisnike"/>
			<referrer name="OnDialogResponse"/>
			<dependency name="E_INI_TAGS_NAME"/>
			<dependency name="E_INI_TAGS_NEXT"/>
			<dependency name="E_INI_TAGS_START"/>
			<dependency name="INI_Flush"/>
			<dependency name="INI_GetTag"/>
			<dependency name="YSI_g_sINICurrentTag"/>
			<dependency name="YSI_g_sINIStartTag"/>
			<dependency name="YSI_g_sINITagBuffer"/>
			<dependency name="YSI_g_sINITagBuffer"/>
			<dependency name="YSI_g_sINITagPos"/>
			<dependency name="YSI_g_sINIWriteFile"/>
			<dependency name="strpack"/>
			<param name="file">
				<paraminfo>INI </paraminfo>
				INI file handle to write to.
			</param>
			<param name="tag">
				<paraminfo> [] </paraminfo>
				Name of the new file subsection for subsequent data to write to.
			</param>
			    <remarks>  Sets a new [tag] section header.  Subsequent data is written under this  header.  Uses lists for constant tag switching and checks the tag doesn't  already exist.  </remarks> 
		</member>
		<member name="M:INI_SetupCallbackName" syntax="INI_SetupCallbackName(fmat[], remoteFormat[], filename[], bFileFirst)">
			<stacksize value="11"/>
			<referrer name="INI_ParseFile"/>
			<dependency name="IsWindows"/>
			<dependency name="false"/>
			<dependency name="format"/>
			<dependency name="strcat"/>
			<dependency name="strfind"/>
			<dependency name="strins"/>
			<param name="fmat">
				<paraminfo> [32] </paraminfo>
				The format destination.
			</param>
			<param name="remoteFormat">
				<paraminfo> [] </paraminfo>
				The source format.
			</param>
			<param name="filename">
				<paraminfo> [] </paraminfo>
				The file we are currently parsing.
			</param>
			<param name="bFileFirst">
				<paraminfo>bool </paraminfo>
				The format parameter ordering.
			</param>
			        <remarks>  Generates a partial function name for processing callbacks.  Includes the  filename and a placeholder for the tag name.  This now takes extra  characters in to account and strips or converts bits:  some/dir/file name.ext  Becomes:  file_name  Before being formatted in to the specified remote format.  The filename  also takes in to account "/" directory separators and "\\" ones on Windows.  Because the	majority of this function is concerned with formatting just part  of the function name correctly, it short-circuits if it detects that there  is no place for the function name to go.  This is quite a complex function, but is only called once per file parse.  </remarks> 
		</member>
		<member name="M:INI_String" syntax="INI_String(name[], variable[])">
			<stacksize value="1"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				Name of the INI key.
			</param>
			<param name="variable">
				<paraminfo> [] </paraminfo>
				Variable to fill with string value.
			</param>
			    <param name="len">Optional string length.</param>  <remarks>  The old version of "INI_String" didn't like not having a length.  It gave a  very odd error message too.  This has now been corrected by making the  length parameter optional.  </remarks> 
		</member>
		<member name="M:INI_WriteBin" syntax="INI_WriteBin(file, name[], data)">
			<stacksize value="7"/>
			<dependency name="INI_AddToBuffer"/>
			<dependency name="YSI_g_sINITmpBuffer"/>
			<dependency name="format"/>
			<param name="file">
				<paraminfo>INI </paraminfo>
				File to write to.
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
				Data name.
			</param>
			<param name="data">
				Binary data.
			</param>
			      <remarks>  Wrapper for INI_AddToBuffer for integers to be written as binary values.  </remarks> 
		</member>
		<member name="M:INI_WriteBool" syntax="INI_WriteBool(file, name[], data)">
			<stacksize value="6"/>
			<dependency name="INI_AddToBuffer"/>
			<param name="file">
				<paraminfo>INI </paraminfo>
				File to write to.
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
				Data name.
			</param>
			<param name="data">
				<paraminfo>bool </paraminfo>
				Boolean data.
			</param>
			      <remarks>  Wrapper for INI_AddToBuffer for booleans.  </remarks> 
		</member>
		<member name="M:INI_WriteBuffer" syntax="INI_WriteBuffer(file)">
			<tagname value="bool"/>
			<stacksize value="47"/>
			<referrer name="INI_Close"/>
			<referrer name="INI_Flush"/>
			<dependency name="Debug_Print0"/>
			<dependency name="E_INI_KV_ENTRY_NAME"/>
			<dependency name="E_INI_KV_ENTRY_NEXT"/>
			<dependency name="E_INI_KV_ENTRY_TEXT"/>
			<dependency name="E_INI_TAGS_NAME"/>
			<dependency name="E_INI_TAGS_START"/>
			<dependency name="INI_DumpTag"/>
			<dependency name="INI_FreeTag"/>
			<dependency name="INI_GetTag"/>
			<dependency name="INI_IdentifyLineType"/>
			<dependency name="NULL"/>
			<dependency name="YSI_g_sINIStartTag"/>
			<dependency name="YSI_g_sINITagBuffer"/>
			<dependency name="YSI_g_sINITagBuffer"/>
			<dependency name="YSI_g_sINIWriteBuffer"/>
			<dependency name="YSI_g_sINIWriteBuffer"/>
			<dependency name="YSI_g_sINIWriteFile"/>
			<dependency name="YSI_g_sINIWriteFile"/>
			<dependency name="YSI_g_sINIWritePos"/>
			<dependency name="cellmax"/>
			<dependency name="e_INI_LINE_TYPE_DATALESS"/>
			<dependency name="e_INI_LINE_TYPE_INVALID"/>
			<dependency name="e_INI_LINE_TYPE_TAG"/>
			<dependency name="false"/>
			<dependency name="fclose"/>
			<dependency name="fopen"/>
			<dependency name="fread"/>
			<dependency name="fremove"/>
			<dependency name="fseek"/>
			<dependency name="ftemp"/>
			<dependency name="fwrite"/>
			<dependency name="io_read"/>
			<dependency name="io_write"/>
			<dependency name="strcmp"/>
			<dependency name="strunpack"/>
			<dependency name="true"/>
			<param name="file">
				<paraminfo>INI </paraminfo>
				INI stream to write to file.
			</param>
			  <returns>  Success/fail.  </returns>  <remarks>  Opens the required file for reading and a temp file for read/writing.  Goes  through the entire file reading all contained data.  If it reaches a tag  line ([tag_name]) it dumps any unwritten data from the last tag (if there  was one) and starts processing the new tag.  While a tag is being processed  every line is compared against the UNWRITTEN new data for that tag in the  buffer, if they're the same it writes the new data instead (it also writes  any comments which were after the data in the original line back), else it  writes the original line back.  Once all the new data is written to the temp file any tags which haven't  been processed at all (i.e. were not found in the original file) are  written to the temp file along with all their data.  The original file is  then destroyed and reopend and all the data copied out from the temp file  to the newly opened original file, closed and saved.  </remarks> 
		</member>
		<member name="M:INI_WriteFloat" syntax="INI_WriteFloat(file, name[], data, accuracy)">
			<stacksize value="7"/>
			<dependency name="INI_AddToBuffer"/>
			<dependency name="YSI_g_sINITmpBuffer"/>
			<dependency name="format"/>
			<param name="file">
				<paraminfo>INI </paraminfo>
				File to write to.
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
				Data name.
			</param>
			<param name="data">
				<paraminfo>Float </paraminfo>
				Float data.
			</param>
			<param name="accuracy">
				number of decimal places to write.
			</param>
			        <remarks>  Wrapper for INI_AddToBuffer for floats.  </remarks> 
		</member>
		<member name="M:INI_WriteHex" syntax="INI_WriteHex(file, name[], data)">
			<stacksize value="9"/>
			<dependency name="INI_AddToBuffer"/>
			<dependency name="YSI_g_sINITmpBuffer"/>
			<dependency name="format"/>
			<param name="file">
				<paraminfo>INI </paraminfo>
				File to write to.
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
				Data name.
			</param>
			<param name="data">
				Hex data.
			</param>
			      <remarks>  Wrapper for INI_AddToBuffer for integers to be written as hex values.  </remarks> 
		</member>
		<member name="M:INI_WriteInt" syntax="INI_WriteInt(file, name[], data)">
			<stacksize value="6"/>
			<referrer name="SacuvajKorisnike"/>
			<referrer name="OnDialogResponse"/>
			<dependency name="INI_AddToBuffer"/>
			<dependency name="YSI_g_sINITmpBuffer"/>
			<dependency name="cellmin"/>
			<dependency name="format"/>
			<param name="file">
				<paraminfo>INI </paraminfo>
				File to write to.
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
				Data name.
			</param>
			<param name="data">
				Integer data.
			</param>
			      <remarks>  Wrapper for INI_AddToBuffer for integers.  Fixed for very large numbers  based on code by Slice from "fixes.inc" for "valstr".  </remarks> 
		</member>
		<member name="M:INI_WriteString" syntax="INI_WriteString(file, name[], data[])">
			<stacksize value="6"/>
			<dependency name="INI_AddToBuffer"/>
			<param name="file">
				<paraminfo>INI </paraminfo>
				File to write to.
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
				Data name.
			</param>
			<param name="data">
				<paraminfo> [] </paraminfo>
				Data.
			</param>
			      <remarks>  Wrapper for INI_AddToBuffer for strings.  </remarks> 
		</member>
		<member name="M:IPToInt" syntax="IPToInt(ip[])">
			<stacksize value="5"/>
			<referrer name="OnPlayerConnect"/>
			<dependency name="strval"/>
			<param name="ip">
				<paraminfo> [] </paraminfo>
				Dot notation IP to convert to an integer.
			</param>
			 
		</member>
		<member name="M:IS_IN_RANGE" syntax="IS_IN_RANGE(lower, value, upper)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="lower">
				The lower limit.
			</param>
			<param name="value">
				The number to compare.
			</param>
			<param name="upper">
				The upper limit.
			</param>
			      <returns>  Is the value in the given range.  </returns>  <remarks>  Equivalent to:  <code>		(%1) &lt;= (%0) &lt; (%2)</code>  </remarks> 
		</member>
		<member name="M:ImeIgraca" syntax="ImeIgraca(playerid)">
			<stacksize value="29"/>
			<referrer name="@_yCdajnovac"/>
			<dependency name="GetPlayerName"/>
			<dependency name="ImeIgraca"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:InitOpcodeTable" syntax="InitOpcodeTable()">
			<stacksize value="5"/>
			<referrer name="RelocateOpcode"/>
			<referrer name="UnrelocateOpcode"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="RelocateOpcodeNow"/>
			<dependency name="opcode_table"/>
			<dependency name="opcode_table_is_ready"/>
			<dependency name="true"/>
		</member>
		<member name="M:Inline_DecodeComplex" syntax="Inline_DecodeComplex(from[], &amp;at, &amp;len)">
			<stacksize value="3"/>
			<param name="from">
				<paraminfo> [] </paraminfo>
				Array of variable types.
			</param>
			<param name="at">
				<paraminfo> &amp; </paraminfo>
				Type slot.
			</param>
			<param name="len">
				<paraminfo> &amp; </paraminfo>
				Return for array sizes.
			</param>
			      <returns>  The next variable type stored in the bit array, and the length of arrays.  </returns>  <remarks>  Returns data from a bit array when the parameter could be basic (variable or  reference), or an array with a length (includes strings).  This requries far  more complex code to decode as the lengths may span multiple cells, types  can't because they are always 2 bits and always start on an even bit.  </remarks> 
		</member>
		<member name="M:Inline_DecodeSimple" syntax="Inline_DecodeSimple(from[], at)">
			<stacksize value="1"/>
			<param name="from">
				<paraminfo> [] </paraminfo>
				Array of variable types.
			</param>
			<param name="at">
				Type slot.
			</param>
			    <returns>  The next variable type stored in the bit array.  </returns>  <remarks>  Returns data from a bit array when it is known that only basic types are  stored (i.e. no arrays with length parameters).  </remarks> 
		</member>
		<member name="M:Inline_EncodeFormatString" syntax="Inline_EncodeFormatString(str[], ret[])">
			<stacksize value="8"/>
			<referrer name="Callback_Get"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="ret">
				<paraminfo> [2] </paraminfo>
			</param>
		</member>
		<member name="M:Inline_OnAsmError" syntax="Inline_OnAsmError(ctx[], error)">
			<attribute name="public"/>
			<stacksize value="6"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_REAL_ADDRESS"/>
			<dependency name="AMX_Write"/>
			<dependency name="ASM_ERROR_OPCODE"/>
			<dependency name="ASM_ERROR_OPERAND"/>
			<dependency name="ASM_ERROR_SPACE"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_buffer_size"/>
			<dependency name="AsmEmitJump"/>
			<dependency name="AsmEmitNop"/>
			<dependency name="AsmGetError"/>
			<dependency name="AsmGetPreviousWriteOffset"/>
			<dependency name="Debug_Print0"/>
			<dependency name="YSI_g_sCurInlineCode"/>
			<dependency name="YSI_g_sJumpAddress"/>
			<dependency name="YSI_g_sRequiredSpace"/>
			<dependency name="cellmax"/>
			<dependency name="numargs"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="error">
				<paraminfo>AsmError </paraminfo>
			</param>
		</member>
		<member name="M:Inline_Reset" syntax="Inline_Reset(callback[])">
			<stacksize value="1"/>
			<referrer name="Callback_Get"/>
			<referrer name="INI_ParseFile"/>
			<dependency name="E_CALLBACK_DATA_ALLOC"/>
			<dependency name="E_CALLBACK_DATA_FORMAT"/>
			<dependency name="E_CALLBACK_DATA_OFFSET"/>
			<dependency name="E_CALLBACK_DATA_POINTER"/>
			<param name="callback">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:InterpolateColour" syntax="InterpolateColour(startcolor, endcolor, value, maxvalue, minvalue)">
			<stacksize value="3"/>
			<param name="startcolor">
				One of the two colours.
			</param>
			<param name="endcolor">
				The other of the two colours.
			</param>
			<param name="value">
				The interpolation value between the endpoints.
			</param>
			<param name="maxvalue">
				One of the two numbers.
			</param>
			<param name="minvalue">
				The other of the two numbers.
			</param>
			<summary>  InterpolateColour(startcolor, endcolor, value, maxvalue, minvalue = 0);  </summary>            <remarks>  This function takes two endpoint values (minvalue and maxvalue, with  minvalue defaulting to 0), along with a third value (value) whose distance  between the two endpoints is calculated (as a percentage).  This percentage  value is then applied to the two colours given to find a third colour at  some point between those two colours.  For example, if the endpoints given are "0" and "10", and the value given is  "3", then that is "30%" of the way between the two endpoints.  We therefore  want to find a colour that is 30% of the way between the two given colours.  </remarks> 
		</member>
		<member name="M:IsLinux" syntax="IsLinux()">
			<tagname value="bool"/>
			<stacksize value="3"/>
			<dependency name="GetOS"/>
			<dependency name="OS_LINUX"/>
		</member>
		<member name="M:IsOpcodeValid" syntax="IsOpcodeValid(opcode)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="AsmEmitPadding"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:IsPlayerAdmin" syntax="IsPlayerAdmin(playerid)">
			<attribute name="native"/>
			<referrer name="@_yCmakestaff"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:IsPlayerConnected" syntax="IsPlayerConnected(playerid)">
			<attribute name="native"/>
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="Iter_OPDCInternal"/>
			<referrer name="Iter_Func@PA"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="SSCANF_RunInit"/>
			<referrer name="@_yCmakestaff"/>
			<referrer name="@yH_OnDialogResponse@029"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:IsPlayerInAnyVehicle" syntax="IsPlayerInAnyVehicle(playerid)">
			<attribute name="native"/>
			<referrer name="@yH_OnPlayerKeyStateChange@016"/>
			<referrer name="@_yCxgoto"/>
			<referrer name="@yH_OnPlayerKeyStateChange@028"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:IsPlayerInRangeOfPoint" syntax="IsPlayerInRangeOfPoint(playerid, range, x, y, z)">
			<attribute name="native"/>
			<referrer name="@yH_OnPlayerKeyStateChange@028"/>
			<referrer name="@_yCotvoriracun"/>
			<referrer name="@_yCbanka"/>
			<param name="playerid">
			</param>
			<param name="range">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:IsPlayerNPC" syntax="IsPlayerNPC(playerid)">
			<attribute name="native"/>
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="@yH_OnPlayerConnect@004"/>
			<referrer name="Iter_OPDCInternal"/>
			<referrer name="SSCANF_RunInit"/>
			<referrer name="_y_utils_OnPlayerConnect"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:IsPrintableAscii" syntax="IsPrintableAscii(c)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="ToPrintableAscii"/>
			<param name="c">
			</param>
		</member>
		<member name="M:IsTagIDEmpty" syntax="IsTagIDEmpty(tag)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagIDStrong" syntax="IsTagIDStrong(tag)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="IsTagIndexStrong"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagIDWeak" syntax="IsTagIDWeak(tag)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="IsTagIndexWeak"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagIndexEmpty" syntax="IsTagIndexEmpty(tag)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagIndexStrong" syntax="IsTagIndexStrong(tag)">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetTagInfo"/>
			<dependency name="IsTagIDStrong"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagIndexWeak" syntax="IsTagIndexWeak(tag)">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetTagInfo"/>
			<dependency name="IsTagIDWeak"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagNameEmpty" syntax="IsTagNameEmpty(tag[])">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="tag">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:IsTagNameStrong" syntax="IsTagNameStrong(tag[])">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="tag">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:IsTagNameWeak" syntax="IsTagNameWeak(tag[])">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="tag">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:IsValidActor" syntax="IsValidActor(actorid)">
			<attribute name="native"/>
			<referrer name="@yH_OnScriptInit@004"/>
			<param name="actorid">
				The ID of the actor to check
			</param>
			<summary>Checks if an actor ID is valid.</summary>  <remarks>This function was added in <b>SA-MP 0.3.7</b> and will not work in earlier versions!</remarks> <returns><b><c>1</c></b> if the actor is valid, <b><c>0</c></b> if not.</returns>
		</member>
		<member name="M:IsWindows" syntax="IsWindows()">
			<tagname value="bool"/>
			<stacksize value="3"/>
			<referrer name="INI_SetupCallbackName"/>
			<dependency name="GetOS"/>
			<dependency name="OS_WINDOWS"/>
		</member>
		<member name="M:Iter_ActorDo" syntax="Iter_ActorDo(add, actorid)">
			<stacksize value="7"/>
			<referrer name="Iter_ActorDo_"/>
			<referrer name="Iter_ActorDo@"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_Remove_InternalC"/>
			<dependency name="Iter_Single@Actor"/>
			<dependency name="Iterator@Actor"/>
			<param name="add">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="actorid">
			</param>
		</member>
		<member name="M:Iter_ActorDo@" syntax="Iter_ActorDo@(add, actorid, __m)">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="Iter_ActorDo"/>
			<dependency name="_@"/>
			<param name="add">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="actorid">
			</param>
			<param name="__m">
			</param>
		</member>
		<member name="M:Iter_ActorDo_" syntax="Iter_ActorDo_(add, actorid)">
			<stacksize value="7"/>
			<referrer name="Iter_CreateActor"/>
			<referrer name="Iter_DestroyActor"/>
			<dependency name="I@"/>
			<dependency name="Iter_ActorDo"/>
			<dependency name="J@"/>
			<dependency name="W@"/>
			<param name="add">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="actorid">
			</param>
		</member>
		<member name="M:Iter_Add" syntax="Iter_Add(iter[], value)">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to add the data to.
			</param>
			<param name="value">
				Value to add to the iterator.
			</param>
			    <remarks>  Wrapper for Iter_AddInternal.  native Iter_Add(Iterator:Name&lt;&gt;, value);  </remarks> 
		</member>
		<member name="M:Iter_AddStaticVehicle" syntax="Iter_AddStaticVehicle(modelid, spawn_x, spawn_y, spawn_z, angle, color1, color2)">
			<stacksize value="10"/>
			<dependency name="AddStaticVehicle"/>
			<dependency name="I@"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_Single@LocalVehicle"/>
			<dependency name="Iter_VehicleDo_"/>
			<dependency name="Iterator@LocalVehicle"/>
			<dependency name="J@"/>
			<dependency name="true"/>
			<param name="modelid">
			</param>
			<param name="spawn_x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="angle">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="color1">
			</param>
			<param name="color2">
			</param>
		</member>
		<member name="M:Iter_AddStaticVehicleEx" syntax="Iter_AddStaticVehicleEx(modelid, spawn_x, spawn_y, spawn_z, angle, color1, color2, respawn_delay, addsiren)">
			<stacksize value="12"/>
			<dependency name="AddStaticVehicleEx"/>
			<dependency name="I@"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_Single@LocalVehicle"/>
			<dependency name="Iter_VehicleDo_"/>
			<dependency name="Iterator@LocalVehicle"/>
			<dependency name="J@"/>
			<dependency name="true"/>
			<param name="modelid">
			</param>
			<param name="spawn_x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="angle">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="color1">
			</param>
			<param name="color2">
			</param>
			<param name="respawn_delay">
			</param>
			<param name="addsiren">
			</param>
		</member>
		<member name="M:Iter_Add_InternalC" syntax="Iter_Add_InternalC(&amp;count, array[], size, value)">
			<stacksize value="3"/>
			<referrer name="Iter_RandomAdd_InternalC"/>
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="@yH_OnPlayerConnect@004"/>
			<referrer name="Iter_ActorDo"/>
			<referrer name="Iter_CreateActor"/>
			<referrer name="Iter_VehicleDo"/>
			<referrer name="Iter_CreateVehicle"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<referrer name="Group_SetCommandDefault"/>
			<dependency name="cellmin"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="size">
				Array start index.
			</param>
			<param name="value">
				Item to add.
			</param>
			        <remarks>  Adds a value to a given iterator set.  Now detects when you try and add the  last item multiple times, as well as all the other items.  Now simplified  even further with the new internal representation.  The modulo code is for  iterator reversal.  </remarks> 
		</member>
		<member name="M:Iter_Add_InternalD" syntax="Iter_Add_InternalD(&amp;count, array[], start, size, value)">
			<stacksize value="3"/>
			<referrer name="Iter_RandomAdd_InternalD"/>
			<dependency name="cellmin"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="size">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:Iter_All_Internal" syntax="Iter_All_Internal(array[], size, value)">
			<stacksize value="1"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:Iter_Alloc" syntax="Iter_Alloc(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the first free slot in.
			</param>
			  <remarks>  Finds an empty slot in an iterator, adds that slot to the iterator, and  returns the now added slot.  native Iter_Alloc(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:Iter_Alloc_InternalC" syntax="Iter_Alloc_InternalC(&amp;count, array[], size)">
			<stacksize value="4"/>
			<dependency name="cellmin"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="size">
				Array start index.
			</param>
			      <remarks>  Finds the first free slot in the iterator and add it.  </remarks> 
		</member>
		<member name="M:Iter_Alloc_InternalD" syntax="Iter_Alloc_InternalD(&amp;count, array[], start, size)">
			<stacksize value="4"/>
			<dependency name="cellmin"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Iter_Begin" syntax="Iter_Begin(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the start of.
			</param>
			  <remarks>  Gets a point BEFORE the start of the iterator (the theoretical beginning).  </remarks> 
		</member>
		<member name="M:Iter_Clear" syntax="Iter_Clear(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to empty.
			</param>
			  <remarks>  Wrapper for Iter_Clear_Internal.  Although it doesn't fit my normal strict spacing, the end of "B" is correct,  namely: "_:F@s(%0),%2)".  This uses the "_:%0,)" macro to consume  a trailing comma when nothing is given in "%2", so I can't have a leading  space sadly.  "- 2" in place of the normal "- 1" is CORRECT!  native Iter_Clear(IteratorArray:Name[]&lt;&gt;);  </remarks> 
		</member>
		<member name="M:Iter_Clear_InternalC" syntax="Iter_Clear_InternalC(array[], size, entries, lst, ...)">
			<stacksize value="5"/>
			<referrer name="@yH_OnScriptInit@004"/>
			<dependency name="setarg"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="size">
				Size of base array.
			</param>
			<param name="entries">
				Size of the count data.
			</param>
			<param name="lst">
				Last valid index in the iterator array.
			</param>
			<param name="...">
			</param>
			      <param name="count">Number of items in the iterator.</param>  <param name="elems">Number of iterator elements.</param>    <param name="start">Optional single multi-iterator to clear.</param>  <remarks>  Resets an iterator.  </remarks> 
		</member>
		<member name="M:Iter_Clear_InternalD" syntax="Iter_Clear_InternalD(array[], size, entries, elems, counts[], start)">
			<stacksize value="1"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="entries">
			</param>
			<param name="elems">
			</param>
			<param name="counts">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
		</member>
		<member name="M:Iter_Contains" syntax="Iter_Contains(iter[], value)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to check membership of.
			</param>
			<param name="value">
				Value to check.
			</param>
			    <remarks>  Checks if the given value is in the given iterator.  native Iter_Contains(Iterator:Name&lt;&gt;, value);  </remarks> 
		</member>
		<member name="M:Iter_Contains_InternalC" syntax="Iter_Contains_InternalC(array[], size, value)">
			<stacksize value="1"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="size">
				Size of the iterator.
			</param>
			<param name="value">
				Item to check.
			</param>
			      <remarks>  Checks if this item is in the iterator.  </remarks> 
		</member>
		<member name="M:Iter_Contains_InternalD" syntax="Iter_Contains_InternalD(count, array[], size, start, value)">
			<stacksize value="1"/>
			<param name="count">
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="start">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:Iter_Count" syntax="Iter_Count(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get a random slot from.
			</param>
			  <remarks>  Returns the number of items in this iterator.  native Iter_Count(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:Iter_CreateActor" syntax="Iter_CreateActor(modelid, X, Y, Z, Rotation)">
			<stacksize value="8"/>
			<dependency name="CreateActor"/>
			<dependency name="I@"/>
			<dependency name="Iter_ActorDo_"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_Single@LocalActor"/>
			<dependency name="Iterator@LocalActor"/>
			<dependency name="J@"/>
			<dependency name="true"/>
			<param name="modelid">
			</param>
			<param name="X">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="Y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="Z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="Rotation">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:Iter_CreateVehicle" syntax="Iter_CreateVehicle(modelid, x, y, z, angle, color1, color2, respawn_delay, addsiren)">
			<stacksize value="12"/>
			<referrer name="@_yCstaffvehicle"/>
			<dependency name="CreateVehicle"/>
			<dependency name="I@"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_Single@LocalVehicle"/>
			<dependency name="Iter_VehicleDo_"/>
			<dependency name="Iterator@LocalVehicle"/>
			<dependency name="J@"/>
			<dependency name="true"/>
			<param name="modelid">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="angle">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="color1">
			</param>
			<param name="color2">
			</param>
			<param name="respawn_delay">
			</param>
			<param name="addsiren">
			</param>
		</member>
		<member name="M:Iter_DestroyActor" syntax="Iter_DestroyActor(actorid)">
			<stacksize value="7"/>
			<dependency name="DestroyActor"/>
			<dependency name="I@"/>
			<dependency name="Iter_ActorDo_"/>
			<dependency name="Iter_Remove_InternalC"/>
			<dependency name="Iter_Single@LocalActor"/>
			<dependency name="Iterator@LocalActor"/>
			<dependency name="J@"/>
			<dependency name="false"/>
			<param name="actorid">
			</param>
		</member>
		<member name="M:Iter_DestroyVehicle" syntax="Iter_DestroyVehicle(vehicleid)">
			<stacksize value="7"/>
			<referrer name="@yH_OnPlayerDisconnect@023"/>
			<referrer name="@_yCstaffvehicle"/>
			<dependency name="DestroyVehicle"/>
			<dependency name="I@"/>
			<dependency name="Iter_Remove_InternalC"/>
			<dependency name="Iter_Single@LocalVehicle"/>
			<dependency name="Iter_VehicleDo_"/>
			<dependency name="Iterator@LocalVehicle"/>
			<dependency name="J@"/>
			<dependency name="false"/>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:Iter_End" syntax="Iter_End(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the end of.
			</param>
			  <remarks>  Gets a point AFTER the end of the iterator (think "MAX_PLAYERS").  </remarks> 
		</member>
		<member name="M:Iter_FastClear" syntax="Iter_FastClear(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to empty.
			</param>
			  <remarks>  Uses a static array copy to blank the iterator instead of a loop.  BROKEN!  native Iter_FastClear(IteratorArray:Name[]&lt;&gt;);  </remarks> 
		</member>
		<member name="M:Iter_First" syntax="Iter_First(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the first valid element in.
			</param>
			  <remarks>  Gets the first element in an iterator.  </remarks> 
		</member>
		<member name="M:Iter_Free" syntax="Iter_Free(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the first free slot in.
			</param>
			  <remarks>  Wrapper for Iter_Free_Internal.  Returns a slot NOT in the current  iterator.  native Iter_Free(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:Iter_FreeMulti" syntax="Iter_FreeMulti(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the multi-iterator to get the first free slot in.
			</param>
			  <remarks>  Wrapper for Iter_FreeMulti_Internal.  Returns a slot NOT in the current  multi-iterator.  native Iter_FreeMulti(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:Iter_FreeMulti_Internal" syntax="Iter_FreeMulti_Internal(array[], trueSize, start)">
			<stacksize value="2"/>
			<dependency name="cellmin"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
				multi-iterator data.
			</param>
			<param name="trueSize">
				Size of the multi-iterator.
			</param>
			<param name="start">
				End [?, since start points are backwards] of the multi-iterator.
			</param>
			      <remarks>  Finds the first free multi index in the multi-iterator.  </remarks> 
		</member>
		<member name="M:Iter_Free_Internal" syntax="Iter_Free_Internal(array[], size)">
			<stacksize value="2"/>
			<dependency name="cellmin"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="size">
				Size of the iterator.
			</param>
			    <remarks>  Finds the first free slot in the iterator.  </remarks> 
		</member>
		<member name="M:Iter_Func@Bits" syntax="Iter_Func@Bits(start, data[], size)">
			<stacksize value="6"/>
			<dependency name="Cell_GetLowestBit"/>
			<dependency name="cellbits"/>
			<param name="start">
			</param>
			<param name="data">
				<paraminfo>Bit [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Iter_Func@Blanks" syntax="Iter_Func@Blanks(start, data[], size)">
			<stacksize value="6"/>
			<dependency name="Cell_GetLowestBit"/>
			<dependency name="cellbits"/>
			<param name="start">
			</param>
			<param name="data">
				<paraminfo>Bit [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Iter_Func@Command" syntax="Iter_Func@Command(start)">
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Iter_Func@Command@"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sHighestID"/>
			<param name="start">
				Last value.
			</param>
			  <returns>  The next command.  </returns>  <remarks>  Internal implementation of the "Command()" iterator for "foreach".  Returns  all the commands that exist.  Normally iterator functions take two  parameters, but this needs only one.  Really quite simple, but probably  faster this way as it has access to internal information.  </remarks> 
		</member>
		<member name="M:Iter_Func@Command@" syntax="Iter_Func@Command@(start)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Iter_Func@Command"/>
			<dependency name="X@"/>
			<param name="start">
			</param>
		</member>
		<member name="M:Iter_Func@Fib" syntax="Iter_Func@Fib(&amp;iterstart, cur)">
			<stacksize value="1"/>
			<param name="iterstart">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="cur">
			</param>
		</member>
		<member name="M:Iter_Func@Filter" syntax="Iter_Func@Filter(cur, val, arr[], size)">
			<stacksize value="1"/>
			<param name="cur">
			</param>
			<param name="val">
			</param>
			<param name="arr">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Iter_Func@NonNull" syntax="Iter_Func@NonNull(cur, arr[], size)">
			<stacksize value="1"/>
			<param name="cur">
			</param>
			<param name="arr">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Iter_Func@Null" syntax="Iter_Func@Null(cur, arr[], size)">
			<stacksize value="1"/>
			<param name="cur">
			</param>
			<param name="arr">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Iter_Func@PA" syntax="Iter_Func@PA(start, data[])">
			<stacksize value="7"/>
			<dependency name="Cell_GetLowestBit"/>
			<dependency name="IsPlayerConnected"/>
			<dependency name="cellbits"/>
			<param name="start">
			</param>
			<param name="data">
				<paraminfo>Bit [] </paraminfo>
			</param>
		</member>
		<member name="M:Iter_Func@PlayerCommand" syntax="Iter_Func@PlayerCommand(start, pid)">
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Iter_Func@PlayerCommand@"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="E_COMMAND_USERS"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sHighestID"/>
			<dependency name="cellbits"/>
			<param name="start">
				Last value.
			</param>
			<param name="pid">
				Player to check for.
			</param>
			    <returns>  The next command.  </returns>  <remarks>  Internal implementation of the "PlayerCommand()" iterator for "foreach".  Returns all the commands this player can use.  This is similar to "Command_GetNext", but returns an ID not a string - I  actually think this way is slightly better.  </remarks> 
		</member>
		<member name="M:Iter_Func@PlayerCommand@" syntax="Iter_Func@PlayerCommand@(start, pid)">
			<attribute name="public"/>
			<stacksize value="5"/>
			<automaton name="@_"/>
			<dependency name="Iter_Func@PlayerCommand"/>
			<dependency name="X@"/>
			<param name="start">
			</param>
			<param name="pid">
			</param>
		</member>
		<member name="M:Iter_Func@Powers" syntax="Iter_Func@Powers(&amp;iterstart, cur, base)">
			<stacksize value="1"/>
			<param name="iterstart">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="cur">
			</param>
			<param name="base">
			</param>
		</member>
		<member name="M:Iter_Func@Random" syntax="Iter_Func@Random(&amp;iterstart, cur, count, min, max)">
			<stacksize value="3"/>
			<dependency name="cellmin"/>
			<dependency name="random"/>
			<param name="iterstart">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="cur">
			</param>
			<param name="count">
			</param>
			<param name="min">
			</param>
			<param name="max">
			</param>
		</member>
		<member name="M:Iter_Func@Range" syntax="Iter_Func@Range(cur, min, max, step)">
			<stacksize value="1"/>
			<dependency name="cellmin"/>
			<param name="cur">
			</param>
			<param name="min">
			</param>
			<param name="max">
			</param>
			<param name="step">
			</param>
		</member>
		<member name="M:Iter_Func@Until" syntax="Iter_Func@Until(cur, val, arr[], size)">
			<stacksize value="1"/>
			<param name="cur">
			</param>
			<param name="val">
			</param>
			<param name="arr">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Iter_GetMulti" syntax="Iter_GetMulti(iter[], value)">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to check membership of.
			</param>
			<param name="value">
				Value to check.
			</param>
			    <returns>  Index in which the value is contained in the multi-iterator.  </returns>  <remarks>  Checks if the given value is in the given iterator, and if it is return which index it is contained.  native Iter_GetMulti(Iterator:Name&lt;&gt;, value);  </remarks> 
		</member>
		<member name="M:Iter_GetMulti_Internal" syntax="Iter_GetMulti_Internal(array[], trueSize, size, value)">
			<stacksize value="1"/>
			<dependency name="cellmin"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
				multi-iterator data.
			</param>
			<param name="trueSize">
				Size of the multi-iterator per index.
			</param>
			<param name="size">
				Size of the multi-iterator.
			</param>
			<param name="value">
				Item to check.
			</param>
			        <returns>  INVALID_ITERATOR_SLOT on failure.  Index of the multi-iterator the value is contained.  </returns>  <remarks>  Checks if this item is in the multi-iterator at all, and if it is returns which index it is in.  </remarks> 
		</member>
		<member name="M:Iter_Index" syntax="Iter_Index(iter[], index, wrap)">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get a slot in by index.
			</param>
			<param name="index">
				Index.
			</param>
			<param name="wrap">
				<paraminfo>bool </paraminfo>
				Keep going around until a value is found?
			</param>
			      <remarks>  Wrapper for Iter_Index_Internal.  Returns the Nth value in the iterator  (requires looping due to the way iterators are stored and optimised for  loops not direct access).  native Iter_Index(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:Iter_Index_Internal" syntax="Iter_Index_Internal(count, array[], start, size, index, wrap)">
			<stacksize value="1"/>
			<dependency name="cellmin"/>
			<param name="count">
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="start">
				Array start index.
			</param>
			<param name="size">
				Array size.
			</param>
			<param name="index">
				Index to find Nth value.
			</param>
			<param name="wrap">
				<paraminfo>bool </paraminfo>
				Keep going around until a value is found?
			</param>
			            <remarks>  Allows you to find the Nth value in the iterator.  DO NOT call this in a  loop to get all values - that totally defeats the purpose of "foreach", just  use a normal "foreach" loop with an index counter for that case.  </remarks> 
		</member>
		<member name="M:Iter_Init" syntax="Iter_Init(iter[][])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [][] </paraminfo>
				Name of the iterator array to initialise.
			</param>
			  <remarks>  Wrapper for Iter_Init_Internal.  When <c>__COMPILER_NESTED_ELLIPSIS</c> is  set, this isn't needed because multi-dimensional iterators can be  initialised with the new <c>{{0, 1, ...), ...}</c> feature.  In that case  <c>I@ = 0</c> is called as a <c>void</c> function that does nothing but ends  in a semi-colon (<c>I@</c> is used a lot in YSI as a <c>do nothing</c>  enabler).  <code>native Iter_Init(IteratorArray:Name[]&lt;&gt;);</code>  </remarks> 
		</member>
		<member name="M:Iter_Init_Internal" syntax="Iter_Init_Internal(arr[][], first[], s0, s1, entries)">
			<stacksize value="9"/>
			<dependency name="memcpy"/>
			<param name="arr">
				<paraminfo> [][] </paraminfo>
			</param>
			<param name="first">
				<paraminfo> [] </paraminfo>
				First iterator slot.
			</param>
			<param name="s0">
				Size of first dimension.
			</param>
			<param name="s1">
				Size of second dimension.
			</param>
			<param name="entries">
				Number of start points.
			</param>
			<param name="array">Iterator array to initialise.</param>          <remarks>  Multi-dimensional arrays can't be initialised at compile time, so need to be  done at run time, which is slightly annoying.  </remarks> 
		</member>
		<member name="M:Iter_Last" syntax="Iter_Last(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to
			</param>
			  <remarks>  Gets the last element in an iterator.  Works by getting the previous item  from the one BEFORE the first element (i.e. the one before the sentinel).  </remarks> 
		</member>
		<member name="M:Iter_Next" syntax="Iter_Next(iter[], cur)">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the next element in.
			</param>
			<param name="cur">
				The current element.
			</param>
			    <remarks>  Gets the element in an iterator after the current one.  </remarks> 
		</member>
		<member name="M:Iter_None_Internal" syntax="Iter_None_Internal(array[], size, value)">
			<stacksize value="1"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:Iter_OPDCInternal" syntax="Iter_OPDCInternal(playerid)">
			<attribute name="public"/>
			<stacksize value="7"/>
			<dependency name="IsPlayerConnected"/>
			<dependency name="IsPlayerNPC"/>
			<dependency name="Iter_Remove_InternalC"/>
			<dependency name="Iter_Single@Bot"/>
			<dependency name="Iter_Single@Character"/>
			<dependency name="Iter_Single@Player"/>
			<dependency name="Iterator@Bot"/>
			<dependency name="Iterator@Character"/>
			<dependency name="Iterator@Player"/>
			<param name="playerid">
				Player who left.
			</param>
			  <remarks>  Called AFTER "OnPlayerDisconnect" so that using "Kick" inside a  "foreach" loop doesn't crash the server due to an OOB error.  </remarks> 
		</member>
		<member name="M:Iter_Prev" syntax="Iter_Prev(iter[], cur)">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the previous element in.
			</param>
			<param name="cur">
				The current element.
			</param>
			    <remarks>  Gets the element in an iterator before the current one.  Slow.  </remarks> 
		</member>
		<member name="M:Iter_Prev_Internal" syntax="Iter_Prev_Internal(array[], elems, size, slot)">
			<stacksize value="2"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="elems">
				Number of elements in the iterator.
			</param>
			<param name="size">
				Size of the iterator.
			</param>
			<param name="slot">
				The current slot.
			</param>
			        <remarks>  Gets the element in an iterator that points to the current element.  </remarks> 
		</member>
		<member name="M:Iter_Random" syntax="Iter_Random(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get a random slot from.
			</param>
			  <remarks>  Wrapper for Iter_RandomInternal.  native Iter_Random(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:Iter_RandomAdd" syntax="Iter_RandomAdd(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to add a random slot to.
			</param>
			  <remarks>  Wrapper for Iter_RandomAddInternal.  native Iter_RandomAdd(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:Iter_RandomAdd_InternalC" syntax="Iter_RandomAdd_InternalC(&amp;count, array[], start)">
			<stacksize value="9"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_RandomFree_InternalC"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="start">
				Size of the iterator.
			</param>
			      <param name="slots">Number of multi-iterator values.</param>  <remarks>  Returns a random unused value from an iterator.  </remarks> 
		</member>
		<member name="M:Iter_RandomAdd_InternalD" syntax="Iter_RandomAdd_InternalD(counts[], array[], size, slots, start, slot)">
			<stacksize value="11"/>
			<dependency name="Iter_Add_InternalD"/>
			<dependency name="Iter_RandomFree_InternalD"/>
			<param name="counts">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="slots">
			</param>
			<param name="start">
			</param>
			<param name="slot">
			</param>
		</member>
		<member name="M:Iter_RandomFree" syntax="Iter_RandomFree(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get a random unused slot for.
			</param>
			  <remarks>  Wrapper for Iter_RandomFree_Internal.  native Iter_RandomFree(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:Iter_RandomFree_InternalC" syntax="Iter_RandomFree_InternalC(count, array[], start)">
			<stacksize value="3"/>
			<referrer name="Iter_RandomAdd_InternalC"/>
			<referrer name="Iter_RandomFree_InternalD"/>
			<dependency name="cellmin"/>
			<dependency name="random"/>
			<param name="count">
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="start">
				Size of the iterator.
			</param>
			      <param name="slots">Number of multi-iterator values.</param>  <remarks>  Returns a random unused value from an iterator.  </remarks> 
		</member>
		<member name="M:Iter_RandomFree_InternalD" syntax="Iter_RandomFree_InternalD(counts[], array[], start, slots)">
			<stacksize value="7"/>
			<referrer name="Iter_RandomAdd_InternalD"/>
			<dependency name="Iter_RandomFree_InternalC"/>
			<param name="counts">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="slots">
			</param>
		</member>
		<member name="M:Iter_RandomRemove" syntax="Iter_RandomRemove(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to remove a random slot from.
			</param>
			  <remarks>  Wrapper for Iter_RandomRemoveInternal.  native Iter_RandomRemove(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:Iter_RandomRemove_InternalC" syntax="Iter_RandomRemove_InternalC(&amp;count, array[], start)">
			<stacksize value="9"/>
			<dependency name="Iter_Random_Internal"/>
			<dependency name="Iter_Remove_InternalC"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="start">
				Size of the iterator.
			</param>
			      <param name="slots">Number of multi-iterator values.</param>  <remarks>  Returns a random unused value from an iterator.  </remarks> 
		</member>
		<member name="M:Iter_RandomRemove_InternalD" syntax="Iter_RandomRemove_InternalD(&amp;count, array[], size, start)">
			<stacksize value="10"/>
			<dependency name="Iter_Random_Internal"/>
			<dependency name="Iter_Remove_InternalD"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="start">
			</param>
		</member>
		<member name="M:Iter_Random_Internal" syntax="Iter_Random_Internal(count, array[], start)">
			<stacksize value="3"/>
			<referrer name="Iter_RandomRemove_InternalC"/>
			<referrer name="Iter_RandomRemove_InternalD"/>
			<dependency name="cellmin"/>
			<dependency name="random"/>
			<param name="count">
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="start">
				Size of the iterator.
			</param>
			      <remarks>  Returns a random value from an iterator.  </remarks> 
		</member>
		<member name="M:Iter_Remove" syntax="Iter_Remove(iter[], value)">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to remove data from.
			</param>
			<param name="value">
				Data to remove.
			</param>
			    <remarks>  Wrapper for Iter_RemoveInternal.  native Iter_Remove(Iterator:Name&lt;&gt;, value);  </remarks> 
		</member>
		<member name="M:Iter_Remove_InternalC" syntax="Iter_Remove_InternalC(&amp;count, array[], size, value)">
			<stacksize value="9"/>
			<referrer name="Iter_RandomRemove_InternalC"/>
			<referrer name="Iter_OPDCInternal"/>
			<referrer name="Iter_ActorDo"/>
			<referrer name="Iter_DestroyActor"/>
			<referrer name="Iter_VehicleDo"/>
			<referrer name="Iter_DestroyVehicle"/>
			<dependency name="Iter_SafeRemove_InternalC"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="size">
				Number of iterator elements.
			</param>
			<param name="value">
				Item to remove.
			</param>
			        <remarks>  Removes a value from an iterator.  </remarks> 
		</member>
		<member name="M:Iter_Remove_InternalD" syntax="Iter_Remove_InternalD(&amp;count, array[], start, size, value)">
			<stacksize value="10"/>
			<referrer name="Iter_RandomRemove_InternalD"/>
			<dependency name="Iter_SafeRemove_InternalD"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="size">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:Iter_SafeRemove" syntax="Iter_SafeRemove(iter[], value, &amp;next)">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to remove data from.
			</param>
			<param name="value">
				Data to remove.
			</param>
			<param name="next">
				<paraminfo> &amp; </paraminfo>
				Container for the pointer to the next element.
			</param>
			      <remarks>  Wrapper for Iter_SafeRemoveInternal.  Common use:  Iter_SafeRemove(iter, i, i);  native Iter_SafeRemove(Iterator:Name&lt;&gt;, value, &amp;next);  </remarks> 
		</member>
		<member name="M:Iter_SafeRemove_InternalC" syntax="Iter_SafeRemove_InternalC(&amp;count, array[], size, value, &amp;last)">
			<stacksize value="1"/>
			<referrer name="Iter_Remove_InternalC"/>
			<dependency name="cellmin"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				Iterator data.
			</param>
			<param name="size">
				Number of iterator elements.
			</param>
			<param name="value">
				Item to remove.
			</param>
			<param name="last">
				<paraminfo> &amp; </paraminfo>
				Pointer in which to store the last pointer.
			</param>
			          <remarks>  Removes a value from an iterator safely.  </remarks> 
		</member>
		<member name="M:Iter_SafeRemove_InternalD" syntax="Iter_SafeRemove_InternalD(&amp;count, array[], start, size, value, &amp;last)">
			<stacksize value="1"/>
			<referrer name="Iter_Remove_InternalD"/>
			<dependency name="cellmin"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="size">
			</param>
			<param name="value">
			</param>
			<param name="last">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:Iter_Size" syntax="Iter_Size(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the size of.
			</param>
			  <remarks>  Accesses the size of an iterator.  </remarks> 
		</member>
		<member name="M:Iter_Starts" syntax="Iter_Starts(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the true starts of.
			</param>
			  <remarks>  Accesses the number of starts in a multi-iterator.  </remarks> 
		</member>
		<member name="M:Iter_TrueArray" syntax="Iter_TrueArray(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the true array of.
			</param>
			  <remarks>  Accesses the internal array of an iterator.  </remarks> 
		</member>
		<member name="M:Iter_TrueCount" syntax="Iter_TrueCount(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the true count of.
			</param>
			  <remarks>  Accesses the internal count of an iterator.  </remarks> 
		</member>
		<member name="M:Iter_TrueMulti" syntax="Iter_TrueMulti(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Multi iterator to get the true count of.
			</param>
			  <remarks>  Accesses the internal count of a multi-iterator.  </remarks> 
		</member>
		<member name="M:Iter_TrueSize" syntax="Iter_TrueSize(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the true size of.
			</param>
			  <remarks>  Accesses the internal size of an iterator.  </remarks> 
		</member>
		<member name="M:Iter_VehicleDo" syntax="Iter_VehicleDo(add, vehicleid)">
			<stacksize value="7"/>
			<referrer name="Iter_VehicleDo_"/>
			<referrer name="Iter_VehicleDo@"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_Remove_InternalC"/>
			<dependency name="Iter_Single@Vehicle"/>
			<dependency name="Iterator@Vehicle"/>
			<param name="add">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:Iter_VehicleDo@" syntax="Iter_VehicleDo@(add, vehicleid, __m)">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="Iter_VehicleDo"/>
			<dependency name="_@"/>
			<param name="add">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="vehicleid">
			</param>
			<param name="__m">
			</param>
		</member>
		<member name="M:Iter_VehicleDo_" syntax="Iter_VehicleDo_(add, vehicleid)">
			<stacksize value="7"/>
			<referrer name="Iter_CreateVehicle"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<referrer name="Iter_DestroyVehicle"/>
			<dependency name="I@"/>
			<dependency name="Iter_VehicleDo"/>
			<dependency name="J@"/>
			<dependency name="W@"/>
			<param name="add">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:Iter_YieldEnter" syntax="Iter_YieldEnter()">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="Debug_Print0"/>
			<dependency name="YSI_gIteratorDepth"/>
			<dependency name="YSI_g_sIteratorStack"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<remarks>  </remarks> 
		</member>
		<member name="M:Iter_YieldLoop" syntax="Iter_YieldLoop()">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="E_ITER_YIELD_FIRST"/>
			<dependency name="E_ITER_YIELD_STACK_SIZE"/>
			<dependency name="YSI_gIteratorDepth"/>
			<dependency name="YSI_g_sIteratorStack"/>
			<dependency name="YSI_g_sIteratorStack"/>
			<dependency name="YSI_g_sPtr"/>
			<dependency name="YSI_g_sStackPtr"/>
			<dependency name="false"/>
			<dependency name="memcpy"/>
			<dependency name="true"/>
		</member>
		<member name="M:Iter_YieldReturn" syntax="Iter_YieldReturn(value)">
			<stacksize value="1"/>
			<dependency name="I@"/>
			<dependency name="YSI_gIteratorDepth"/>
			<dependency name="YSI_g_sIteratorStack"/>
			<dependency name="YSI_g_sPtr"/>
			<dependency name="YSI_g_sStackPtr"/>
			<dependency name="memcpy"/>
			<param name="value">
			</param>
		</member>
		<member name="M:Iterator" syntax="Iterator(name)">
			<tagname value="Iterator"/>
			<stacksize value="1"/>
			<param name="name">
			</param>
			<remarks>  Creates a new iterator start/array pair.  </remarks> 
		</member>
		<member name="M:Iterator@Reverse" syntax="Iterator@Reverse(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Iterator to run backwards.
			</param>
			  <remarks>  Run an iterator backwards.  </remarks> 
		</member>
		<member name="M:Kick" syntax="Kick(playerid)">
			<attribute name="native"/>
			<referrer name="OnDialogResponse"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:KillTimer" syntax="KillTimer(timerid)">
			<attribute name="native"/>
			<referrer name="_Timer_I"/>
			<referrer name="_Timer_D"/>
			<referrer name="_Timer_F"/>
			<param name="timerid">
			</param>
		</member>
		<member name="M:KreirajObjekte" syntax="KreirajObjekte()">
			<stacksize value="20"/>
			<referrer name="SSCANF_OnGameModeInit"/>
			<dependency name="CreateDynamicObject"/>
			<dependency name="CreateDynamicObjectEx"/>
			<dependency name="CreateObject"/>
			<dependency name="SetDynamicObjectMaterial"/>
			<dependency name="SetDynamicObjectMaterialText"/>
			<dependency name="SetObjectMaterial"/>
			<dependency name="object_int"/>
			<dependency name="object_world"/>
			<dependency name="tmpobjid"/>
		</member>
		<member name="M:LimitGlobalChatRadius" syntax="LimitGlobalChatRadius(chat_radius)">
			<attribute name="native"/>
			<referrer name="SSCANF_OnGameModeInit"/>
			<param name="chat_radius">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:LoadUser_data" syntax="LoadUser_data(playerid, name[], value[])">
			<attribute name="public"/>
			<stacksize value="6"/>
			<dependency name="PlayerInfo"/>
			<dependency name="PlayerInfo"/>
			<dependency name="player_accountbank"/>
			<dependency name="player_bankmoney"/>
			<dependency name="player_level"/>
			<dependency name="player_money"/>
			<dependency name="player_password"/>
			<dependency name="player_skin"/>
			<dependency name="player_staff"/>
			<dependency name="strcmp"/>
			<dependency name="strval"/>
			<dependency name="true"/>
			<param name="playerid">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="value">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Malloc_Allocate" syntax="Malloc_Allocate(size, clear)">
			<tagname value="Alloc"/>
			<stacksize value="10"/>
			<referrer name="Malloc_NewS"/>
			<referrer name="calloc"/>
			<referrer name="Callback_Get"/>
			<referrer name="Remote_RawStrpack"/>
			<referrer name="Timer_GetSingleSlot"/>
			<dependency name="YSI_gMallocMemory"/>
			<dependency name="__YSI_g_sHeapStart"/>
			<dependency name="__YSI_g_sUnusedStart"/>
			<dependency name="memset"/>
			<param name="size">
				Ammount of memory to allocate IN CELLS.
			</param>
			<param name="clear">
				<paraminfo>bool </paraminfo>
			</param>
			  <param name="cleat">Blank the memory?</param>  <returns>  Memory identifier.  </returns>  <remarks>  The size check should never fail, if there's only 1 cell  extra somewhere just sneak it onto the end of an array,  if the user does proper bounds checking it shouldn't  matter.  Implementation code for <symbolref name="malloc" />.  This code will find an area in memory with sufficient  space to store the given data and   </remarks> 
		</member>
		<member name="M:Malloc_DoPlayerConnect" syntax="Malloc_DoPlayerConnect(playerid)">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="Malloc_TrySetup"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sHeapSetup"/>
			<param name="playerid">
				Player that just connected.
			</param>
			  <remarks>  This is the only callback that can be called before our timers when the mode  starts.  Make sure the heap is set up correctly.  </remarks> 
		</member>
		<member name="M:Malloc_FindStackTop" syntax="Malloc_FindStackTop()">
			<stacksize value="5"/>
			<referrer name="Malloc_TrySetup"/>
			<dependency name="GetFrameReturn"/>
			<remarks>  Loop back up through the stack and find the start of the current stack.  If  it doesn't equal the top of the true stack then we've been called via  "CallLocalFunction" at some point and thus MAY get some memory corruption.  Based on ZeeX's GetStackTrace, but gets frames instead of returns.  </remarks> 
		</member>
		<member name="M:Malloc_Free" syntax="Malloc_Free(slot)">
			<stacksize value="5"/>
			<referrer name="Callback_Release"/>
			<referrer name="_Timer_F"/>
			<dependency name="YSI_gMallocMemory"/>
			<dependency name="__YSI_g_sHeapStart"/>
			<dependency name="__YSI_g_sUnusedStart"/>
			<param name="slot">
				<paraminfo>Alloc </paraminfo>
				Memory allocation unit to release
			</param>
			  <remarks>  Implementation code for <symbolref name="free" />.  </remarks> 
		</member>
		<member name="M:Malloc_Get" syntax="Malloc_Get(array, index)">
			<stacksize value="1"/>
			<param name="array">
				<paraminfo>Alloc </paraminfo>
				Data unit to get information from.
			</param>
			<param name="index">
				Index in the unit.
			</param>
			    <returns>  Data.  </returns>  <remarks>  Displays errors in secure mode.  </remarks> 
		</member>
		<member name="M:Malloc_GetA" syntax="Malloc_GetA(target[], length, array, index)">
			<stacksize value="8"/>
			<dependency name="YSI_gMallocMemory"/>
			<dependency name="memcpy"/>
			<param name="target">
				<paraminfo> [] </paraminfo>
				Target for the array.
			</param>
			<param name="length">
				Length of the target.
			</param>
			<param name="array">
				<paraminfo>Alloc </paraminfo>
				Data unit to put information in.
			</param>
			<param name="index">
				Index in the unit.
			</param>
			        <remarks>  Displays errors in secure mode.  Gets an array.  </remarks> 
		</member>
		<member name="M:Malloc_GetData" syntax="Malloc_GetData(slot, index)">
			<stacksize value="1"/>
			<param name="slot">
				<paraminfo>Alloc </paraminfo>
				The allocation unit to get data from.
			</param>
			<param name="index">
				The location in the unit to get.
			</param>
			    <returns>  The data  </returns>  <remarks>  Basically like <symbolref name="Malloc_Get" /> but used internally.  </remarks> 
		</member>
		<member name="M:Malloc_GetS" syntax="Malloc_GetS(target[], length, array, index, pack)">
			<stacksize value="5"/>
			<dependency name="YSI_gMallocMemory"/>
			<dependency name="strpack"/>
			<dependency name="strunpack"/>
			<param name="target">
				<paraminfo> [] </paraminfo>
				Target for the string.
			</param>
			<param name="length">
				Length of the target.
			</param>
			<param name="array">
				<paraminfo>Alloc </paraminfo>
				Data unit to put information in.
			</param>
			<param name="index">
				Index in the unit.
			</param>
			<param name="pack">
				<paraminfo>bool </paraminfo>
				Return the string packed?
			</param>
			          <remarks>  Displays errors in secure mode.  Gets a string.  </remarks> 
		</member>
		<member name="M:Malloc_GetSlotSize" syntax="Malloc_GetSlotSize(slot)">
			<stacksize value="1"/>
			<param name="slot">
				<paraminfo>Alloc </paraminfo>
				Allocation unit to get the size of.
			</param>
			  <returns>  The size.  </returns> 
		</member>
		<member name="M:Malloc_NewS" syntax="Malloc_NewS(string[], pack)">
			<tagname value="Alloc"/>
			<stacksize value="7"/>
			<dependency name="Malloc_Allocate"/>
			<dependency name="YSI_gMallocMemory"/>
			<dependency name="false"/>
			<dependency name="strlen"/>
			<dependency name="strpack"/>
			<dependency name="strunpack"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				The string to store.
			</param>
			<param name="pack">
				<paraminfo>bool </paraminfo>
				Whether or not the string will be packed.
			</param>
			    <returns>  0 on fail or a data handle on sucess.  </returns>  <remarks>  Allocates a new piece of memory with enough space to store the given string.  </remarks> 
		</member>
		<member name="M:Malloc_NextSlot" syntax="Malloc_NextSlot(slot)">
			<stacksize value="1"/>
			<param name="slot">
				The unit to get the one after of.
			</param>
			  <remarks>  Gets the next free block of memory after the current one.  </remarks> 
		</member>
		<member name="M:Malloc_OnScriptInit" syntax="Malloc_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="9"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="CallFunction"/>
			<dependency name="HookChain_OnScriptInit"/>
			<dependency name="Hooks_DoAllHooks"/>
			<dependency name="Hooks_InvalidateName"/>
			<dependency name="Hooks_SortReplacements"/>
			<remarks>  Call the main hook run code, then advance the ALS chain.  </remarks>  <transition keep="true" target="_ALS : _ALS_go"/>  <transition target="_ALS_go"/>

		</member>
		<member name="M:Malloc_Reconcile" syntax="Malloc_Reconcile(addr)">
			<tagname value="Alloc"/>
			<stacksize value="1"/>
			<dependency name="YSI_gMallocMemory"/>
			<param name="addr">
				<paraminfo>ResolvedAlloc </paraminfo>
				Memory address to find
			</param>
			  <remarks>  Transforms a memory address in to a memory slot.  </remarks> 
		</member>
		<member name="M:Malloc_Resolve" syntax="Malloc_Resolve(slot)">
			<tagname value="ResolvedAlloc"/>
			<stacksize value="1"/>
			<referrer name="Callback_Get"/>
			<dependency name="YSI_gMallocMemory"/>
			<param name="slot">
				<paraminfo>Alloc </paraminfo>
				Memory allocation unit to find
			</param>
			  <remarks>  Transforms a memory slot in to a memory address.  </remarks> 
		</member>
		<member name="M:Malloc_Set" syntax="Malloc_Set(array, index, value)">
			<stacksize value="1"/>
			<param name="array">
				<paraminfo>Alloc </paraminfo>
				Data unit to put information in.
			</param>
			<param name="index">
				Index in the unit.
			</param>
			<param name="value">
				Value to insert
			</param>
			      <remarks>  Displays errors in secure mode.  </remarks> 
		</member>
		<member name="M:Malloc_SetA" syntax="Malloc_SetA(array, index, str[], len)">
			<stacksize value="8"/>
			<referrer name="_Timer_A"/>
			<dependency name="YSI_gMallocMemory"/>
			<dependency name="memcpy"/>
			<param name="array">
				<paraminfo>Alloc </paraminfo>
				Data unit to put information in.
			</param>
			<param name="index">
				Index in the unit.
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Array to insert.
			</param>
			<param name="len">
				Length of the array.
			</param>
			        <remarks>  Displays errors in secure mode.  Inserts an array.  </remarks> 
		</member>
		<member name="M:Malloc_SetData" syntax="Malloc_SetData(slot, index, value)">
			<stacksize value="1"/>
			<param name="slot">
				<paraminfo>Alloc </paraminfo>
				The allocation unit to set in.
			</param>
			<param name="index">
				Where in the unit to set.
			</param>
			<param name="value">
				The value to save.
			</param>
			     
		</member>
		<member name="M:Malloc_SetS" syntax="Malloc_SetS(array, index, str[], pack)">
			<stacksize value="6"/>
			<referrer name="_Timer_S"/>
			<dependency name="YSI_gMallocMemory"/>
			<dependency name="cellmax"/>
			<dependency name="strlen"/>
			<dependency name="strpack"/>
			<dependency name="strunpack"/>
			<param name="array">
				<paraminfo>Alloc </paraminfo>
				Data unit to put information in.
			</param>
			<param name="index">
				Index in the unit.
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to insert
			</param>
			<param name="pack">
				<paraminfo>bool </paraminfo>
				Should the string be packed in?
			</param>
			        <remarks>  Displays errors in secure mode.  Inserts a string.  </remarks> 
		</member>
		<member name="M:Malloc_SetSlotSize" syntax="Malloc_SetSlotSize(slot, size)">
			<stacksize value="1"/>
			<param name="slot">
				The allocation unit to set the size of.
			</param>
			<param name="size">
				The size to set it to.
			</param>
			   
		</member>
		<member name="M:Malloc_SetVAA" syntax="Malloc_SetVAA(array, index, arg)">
			<stacksize value="2"/>
			<dependency name="YSI_gMallocMemory"/>
			<dependency name="memcpy"/>
			<param name="array">
				<paraminfo>Alloc </paraminfo>
				Data unit to put information in.
			</param>
			<param name="index">
				Index in the unit.
			</param>
			<param name="arg">
				Offset in the stack of the array to store.
			</param>
			      <remarks>  Inserts an array by stack offset for use in vararg functions.  </remarks> 
		</member>
		<member name="M:Malloc_SetVAS" syntax="Malloc_SetVAS(array, index, arg)">
			<stacksize value="2"/>
			<dependency name="YSI_gMallocMemory"/>
			<dependency name="strcat"/>
			<dependency name="strlen"/>
			<param name="array">
				<paraminfo>Alloc </paraminfo>
				Data unit to put information in.
			</param>
			<param name="index">
				Index in the unit.
			</param>
			<param name="arg">
				Offset in the stack of the string to store.
			</param>
			      <remarks>  Inserts a string by stack offset for use in vararg functions.  </remarks> 
		</member>
		<member name="M:Malloc_SlotSize" syntax="Malloc_SlotSize(slot)">
			<stacksize value="1"/>
			<param name="slot">
				<paraminfo>Alloc </paraminfo>
				Allocation unit to get the size of.
			</param>
			  <returns>  The size.  </returns> 
		</member>
		<member name="M:Malloc_SolidifyHeap" syntax="Malloc_SolidifyHeap()">
			<stacksize value="1"/>
			<referrer name="OnRuntimeError"/>
			<referrer name="Malloc_SolidifyTimer"/>
			<dependency name="YSI_g_sHeapSetup"/>
			<dependency name="heapspace"/>
		</member>
		<member name="M:Malloc_SolidifyTimer" syntax="Malloc_SolidifyTimer()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="Malloc_SolidifyHeap"/>
			<dependency name="Malloc_TrySetup"/>
		</member>
		<member name="M:Malloc_TrySetup" syntax="Malloc_TrySetup()">
			<stacksize value="7"/>
			<referrer name="main"/>
			<referrer name="AMX_OnScriptInit"/>
			<referrer name="Malloc_SolidifyTimer"/>
			<referrer name="Malloc_DoPlayerConnect"/>
			<dependency name="AMX_HEADER_HEA"/>
			<dependency name="Debug_Print0"/>
			<dependency name="Malloc_FindStackTop"/>
			<dependency name="YSI_gMallocMemory"/>
			<dependency name="__YSI_g_sHeapStart"/>
			<dependency name="__YSI_g_sUnusedStart"/>
			<dependency name="cellbits"/>
			<dependency name="memset"/>
			<remarks>  Move the heap pointer up a load.  This is called multiple times at the start  of the mode because we need to beat protections added in by the virtual  machine to steal away its heap area.  </remarks> 
		</member>
		<member name="M:Malloc_main" syntax="Malloc_main()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="print"/>
		</member>
		<member name="M:Master_GetCurrentMaster" syntax="Master_GetCurrentMaster()">
			<stacksize value="5"/>
			<referrer name="@_OnScriptInit"/>
			<referrer name="@a"/>
			<dependency name="_E_YCM@n"/>
			<dependency name="_E_YCM@y"/>
			<dependency name="_Master_Get"/>
			<dependency name="_YCM_g@a"/>
			<dependency name="false"/>
			<transition keep="true" target="_YCM : y" />  <transition keep="true" target="_YCM : u" />  <transition keep="true" target="_YCM : y" />  <transition keep="true" target="_YCM : n" /> 
		</member>
		<member name="M:Master_GetCurrentMaster" syntax="Master_GetCurrentMaster()">
			<stacksize value="5"/>
			<referrer name="YSIM_OnMasterSystemInit"/>
			<referrer name="@_"/>
			<dependency name="_E_YCM@n"/>
			<dependency name="_E_YCM@y"/>
			<dependency name="_Master_Get"/>
			<dependency name="_YCM_g@_"/>
			<dependency name="false"/>
			<transition keep="true" target="_YCM : y" />  <transition keep="true" target="_YCM : u" />  <transition keep="true" target="_YCM : y" />  <transition keep="true" target="_YCM : n" /> 
		</member>
		<member name="M:Master_GetNext" syntax="Master_GetNext()">
			<stacksize value="8"/>
			<dependency name="getproperty"/>
			<returns>  Next master ID to be assigned.  </returns> 
		</member>
		<member name="M:Master_OnScriptExit" syntax="Master_OnScriptExit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_ALS"/>
			<referrer name="ScriptInit_OnScriptExit"/>
		</member>
		<member name="M:Master_OnScriptInit" syntax="Master_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="_ALS"/>
			<referrer name="HookChain_OnScriptInit"/>
			<dependency name="SSCANF_OnScriptInit"/>
			<dependency name="SSCANF_RunInit"/>
			<dependency name="SSCANF_gInit"/>
			<library>sscanf</library>  <remarks>  Called for earlier initialisation by YSI.  </remarks> 
		</member>
		<member name="M:Master_Reassert" syntax="Master_Reassert()">
			<attribute name="public"/>
			<stacksize value="11"/>
			<dependency name="U@"/>
			<dependency name="YSI_g_sMasterCount"/>
			<dependency name="YSI_g_sMasterData"/>
			<dependency name="_@"/>
			<dependency name="getproperty"/>
			<dependency name="setproperty"/>
			<remarks>  Rebuilds the collection of master data whenever a script is restarted.  </remarks> 
		</member>
		<member name="M:Mean" syntax="Mean(arr[], num)">
			<stacksize value="5"/>
			<dependency name="Sum"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array whose values need averaging.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <returns>  The mathematical mean value of the array.  </returns> 
		</member>
		<member name="M:Median" syntax="Median(arr[], num)">
			<stacksize value="5"/>
			<dependency name="Utils_PreSort"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array whose values need averaging.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <returns>  The mathematical median value of the array.  </returns> 
		</member>
		<member name="M:Mode" syntax="Mode(arr[], num)">
			<stacksize value="6"/>
			<dependency name="Utils_PreSort"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array whose values need averaging.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <returns>  The mathematical modal value of the array.  </returns> 
		</member>
		<member name="M:NOT_IN_RANGE" syntax="NOT_IN_RANGE(lower, value, upper)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="lower">
				The lower limit.
			</param>
			<param name="value">
				The number to compare.
			</param>
			<param name="upper">
				The upper limit.
			</param>
			      <returns>  Is the value outside the given range.  </returns>  <remarks>  Equivalent to:  <code>		(%1) &lt;= (%0) &lt; (%2)</code>  </remarks> 
		</member>
		<member name="M:NijeDzampo" syntax="NijeDzampo(playerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<dependency name="BunnyHop"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:NtCompare" syntax="NtCompare(s1, s2[])">
			<stacksize value="8"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetTagIndexFromName"/>
			<dependency name="ReadAmxMemory"/>
			<param name="s1">
			</param>
			<param name="s2">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:NtCopy" syntax="NtCopy(src, dest[], size)">
			<stacksize value="6"/>
			<referrer name="GetPublicNameFromIndex"/>
			<referrer name="GetNativeNameFromIndex"/>
			<referrer name="GetPubVarNameFromIndex"/>
			<referrer name="GetTagNameFromIndex"/>
			<dependency name="ReadAmxMemory"/>
			<param name="src">
			</param>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:O@A_" syntax="O@A_()">
			<tagname value="bool"/>
			<stacksize value="28"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmGetOperandReloc"/>
			<dependency name="DisasmInit"/>
			<dependency name="DisasmNext"/>
			<dependency name="GetCurrentFrameReturn"/>
			<dependency name="O@V_"/>
			<dependency name="OP_CALL"/>
			<dependency name="false"/>
		</member>
		<member name="M:ObrisiObjekte" syntax="ObrisiObjekte(playerid)">
			<stacksize value="8"/>
			<referrer name="SSCANF_OnPlayerConnect"/>
			<dependency name="RemoveBuildingForPlayer"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnActorStreamIn" syntax="OnActorStreamIn(actorid, forplayerid)">
			<stacksize value="1"/>
			<param name="actorid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:OnActorStreamOut" syntax="OnActorStreamOut(actorid, forplayerid)">
			<stacksize value="1"/>
			<param name="actorid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:OnCachedInit" syntax="OnCachedInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="SSCANF_OnCachedInit"/>
			<dependency name="SSCANF_RunInit"/>
			<library>sscanf</library>  <remarks>  Called when the script starts if it is (legacy) YSI cached mode.  </remarks> 
		</member>
		<member name="M:OnDialogResponse" syntax="OnDialogResponse(playerid, dialogid, response, listitem, inputtext[])">
			<attribute name="public"/>
			<stacksize value="141"/>
			<dependency name="GivePlayerMoney"/>
			<dependency name="INI_Close"/>
			<dependency name="INI_Open"/>
			<dependency name="INI_ParseFile"/>
			<dependency name="INI_SetTag"/>
			<dependency name="INI_WriteInt"/>
			<dependency name="Kick"/>
			<dependency name="PlayerInfo"/>
			<dependency name="PlayerInfo"/>
			<dependency name="SetCameraBehindPlayer"/>
			<dependency name="ShowPlayerDialog"/>
			<dependency name="UserPath"/>
			<dependency name="UserPath"/>
			<dependency name="d_login"/>
			<dependency name="d_register"/>
			<dependency name="player_money"/>
			<dependency name="player_password"/>
			<dependency name="strlen"/>
			<dependency name="true"/>
			<dependency name="udb_hash"/>
			<param name="playerid">
			</param>
			<param name="dialogid">
			</param>
			<param name="response">
			</param>
			<param name="listitem">
			</param>
			<param name="inputtext">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:OnDynamicActorStreamIn" syntax="OnDynamicActorStreamIn(actorid, forplayerid)">
			<stacksize value="1"/>
			<param name="actorid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:OnDynamicActorStreamOut" syntax="OnDynamicActorStreamOut(actorid, forplayerid)">
			<stacksize value="1"/>
			<param name="actorid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:OnDynamicObjectMoved" syntax="OnDynamicObjectMoved(objectid)">
			<stacksize value="1"/>
			<param name="objectid">
			</param>
		</member>
		<member name="M:OnEnterExitModShop" syntax="OnEnterExitModShop(playerid, enterexit, interiorid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="enterexit">
			</param>
			<param name="interiorid">
			</param>
		</member>
		<member name="M:OnFilterScriptExit" syntax="OnFilterScriptExit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="ScriptInit_OnFilterScriptExit"/>
			<dependency name="ScriptInit_OnScriptExit"/>
			<dependency name="YSI_FILTERSCRIPT"/>
		</member>
		<member name="M:OnFilterScriptInit" syntax="OnFilterScriptInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="ScriptInit_OnFilterScriptInit"/>
			<dependency name="YSI_FILTERSCRIPT"/>
			<dependency name="true"/>
			<transition keep="true" target="_script_init_fix_state : true"/>  <transition keep="true" target="_ALS : _ALS_go"/> 
		</member>
		<member name="M:OnGameModeExit" syntax="OnGameModeExit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="ScriptInit_OnGameModeExit"/>
			<dependency name="ScriptInit_OnScriptExit"/>
			<dependency name="YSI_FILTERSCRIPT"/>
		</member>
		<member name="M:OnGameModeInit" syntax="OnGameModeInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="ScriptInit_OnGameModeInit"/>
			<dependency name="YSI_FILTERSCRIPT"/>
			<transition keep="true" target="_script_init_fix_state : false"/>  <transition keep="true" target="_ALS : _ALS_go"/> 
		</member>
		<member name="M:OnIncomingConnection" syntax="OnIncomingConnection(playerid, ip_address[], port)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="ip_address">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="port">
			</param>
		</member>
		<member name="M:OnObjectMoved" syntax="OnObjectMoved(objectid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="objectid">
			</param>
		</member>
		<member name="M:OnPlayerClickMap" syntax="OnPlayerClickMap(playerid, fX, fY, fZ)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="fX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fZ">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerClickPlayer" syntax="OnPlayerClickPlayer(playerid, clickedplayerid, source)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="clickedplayerid">
			</param>
			<param name="source">
			</param>
		</member>
		<member name="M:OnPlayerClickPlayerTextDraw" syntax="OnPlayerClickPlayerTextDraw(playerid, playertextid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="playertextid">
				<paraminfo>PlayerText </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerClickTextDraw" syntax="OnPlayerClickTextDraw(playerid, clickedid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="clickedid">
				<paraminfo>Text </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerCommandPerformed" syntax="OnPlayerCommandPerformed(playerid, cmdtext[], success)">
			<tagname value="e_COMMAND_ERRORS"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="cmdtext">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="success">
				<paraminfo>e_COMMAND_ERRORS </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerCommandReceived" syntax="OnPlayerCommandReceived(playerid, cmdtext[], success)">
			<tagname value="e_COMMAND_ERRORS"/>
			<attribute name="public"/>
			<stacksize value="263"/>
			<dependency name="COMMAND_OK"/>
			<dependency name="PlayerPlaySound"/>
			<dependency name="SendClientMessage"/>
			<dependency name="format"/>
			<param name="playerid">
			</param>
			<param name="cmdtext">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="success">
				<paraminfo>e_COMMAND_ERRORS </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerCommandText" syntax="OnPlayerCommandText(playerid, cmdtext[])">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="cmdtext">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerConnect" syntax="OnPlayerConnect(playerid)">
			<attribute name="public"/>
			<stacksize value="21"/>
			<dependency name="GetPlayerIp"/>
			<dependency name="IPToInt"/>
			<dependency name="YSI_gPlayerIP"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerDeath" syntax="OnPlayerDeath(playerid, killerid, reason)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="killerid">
			</param>
			<param name="reason">
			</param>
		</member>
		<member name="M:OnPlayerDisconnect" syntax="OnPlayerDisconnect(playerid, reason)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<dependency name="YSI_gPlayerIP"/>
			<param name="playerid">
			</param>
			<param name="reason">
			</param>
		</member>
		<member name="M:OnPlayerEditAttachedObject" syntax="OnPlayerEditAttachedObject(playerid, response, index, modelid, boneid, fOffsetX, fOffsetY, fOffsetZ, fRotX, fRotY, fRotZ, fScaleX, fScaleY, fScaleZ)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="response">
			</param>
			<param name="index">
			</param>
			<param name="modelid">
			</param>
			<param name="boneid">
			</param>
			<param name="fOffsetX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fOffsetY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fOffsetZ">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fRotX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fRotY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fRotZ">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fScaleX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fScaleY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fScaleZ">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerEditDynamicObject" syntax="OnPlayerEditDynamicObject(playerid, objectid, response, x, y, z, rx, ry, rz)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="objectid">
			</param>
			<param name="response">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="rx">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="ry">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="rz">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerEditObject" syntax="OnPlayerEditObject(playerid, playerobject, objectid, response, fX, fY, fZ, fRotX, fRotY, fRotZ)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="playerobject">
			</param>
			<param name="objectid">
			</param>
			<param name="response">
			</param>
			<param name="fX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fZ">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fRotX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fRotY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fRotZ">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerEnterCheckpoint" syntax="OnPlayerEnterCheckpoint(playerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerEnterDynamicArea" syntax="OnPlayerEnterDynamicArea(playerid, areaid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="areaid">
			</param>
		</member>
		<member name="M:OnPlayerEnterDynamicCP" syntax="OnPlayerEnterDynamicCP(playerid, checkpointid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="checkpointid">
			</param>
		</member>
		<member name="M:OnPlayerEnterDynamicRaceCP" syntax="OnPlayerEnterDynamicRaceCP(playerid, checkpointid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="checkpointid">
			</param>
		</member>
		<member name="M:OnPlayerEnterRaceCheckpoint" syntax="OnPlayerEnterRaceCheckpoint(playerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerEnterVehicle" syntax="OnPlayerEnterVehicle(playerid, vehicleid, ispassenger)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
			<param name="ispassenger">
			</param>
		</member>
		<member name="M:OnPlayerExitVehicle" syntax="OnPlayerExitVehicle(playerid, vehicleid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:OnPlayerExitedMenu" syntax="OnPlayerExitedMenu(playerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerGiveDamage" syntax="OnPlayerGiveDamage(playerid, damagedid, amount, weaponid, bodypart)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="damagedid">
			</param>
			<param name="amount">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="weaponid">
			</param>
			<param name="bodypart">
			</param>
		</member>
		<member name="M:OnPlayerGiveDamageActor" syntax="OnPlayerGiveDamageActor(playerid, damaged_actorid, amount, weaponid, bodypart)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="damaged_actorid">
			</param>
			<param name="amount">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="weaponid">
			</param>
			<param name="bodypart">
			</param>
		</member>
		<member name="M:OnPlayerGiveDamageDynamicActor" syntax="OnPlayerGiveDamageDynamicActor(playerid, actorid, amount, weaponid, bodypart)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="actorid">
			</param>
			<param name="amount">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="weaponid">
			</param>
			<param name="bodypart">
			</param>
		</member>
		<member name="M:OnPlayerInteriorChange" syntax="OnPlayerInteriorChange(playerid, newinteriorid, oldinteriorid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="newinteriorid">
			</param>
			<param name="oldinteriorid">
			</param>
		</member>
		<member name="M:OnPlayerKeyStateChange" syntax="OnPlayerKeyStateChange(playerid, newkeys, oldkeys)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="newkeys">
			</param>
			<param name="oldkeys">
			</param>
		</member>
		<member name="M:OnPlayerLeaveCheckpoint" syntax="OnPlayerLeaveCheckpoint(playerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerLeaveDynamicArea" syntax="OnPlayerLeaveDynamicArea(playerid, areaid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="areaid">
			</param>
		</member>
		<member name="M:OnPlayerLeaveDynamicCP" syntax="OnPlayerLeaveDynamicCP(playerid, checkpointid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="checkpointid">
			</param>
		</member>
		<member name="M:OnPlayerLeaveDynamicRaceCP" syntax="OnPlayerLeaveDynamicRaceCP(playerid, checkpointid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="checkpointid">
			</param>
		</member>
		<member name="M:OnPlayerLeaveRaceCheckpoint" syntax="OnPlayerLeaveRaceCheckpoint(playerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerObjectMoved" syntax="OnPlayerObjectMoved(playerid, objectid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="objectid">
			</param>
		</member>
		<member name="M:OnPlayerPickUpDynamicPickup" syntax="OnPlayerPickUpDynamicPickup(playerid, pickupid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="pickupid">
			</param>
		</member>
		<member name="M:OnPlayerPickUpPickup" syntax="OnPlayerPickUpPickup(playerid, pickupid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="pickupid">
			</param>
		</member>
		<member name="M:OnPlayerRequestClass" syntax="OnPlayerRequestClass(playerid, classid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="classid">
			</param>
		</member>
		<member name="M:OnPlayerRequestSpawn" syntax="OnPlayerRequestSpawn(playerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerSelectDynamicObject" syntax="OnPlayerSelectDynamicObject(playerid, objectid, modelid, x, y, z)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="objectid">
			</param>
			<param name="modelid">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerSelectObject" syntax="OnPlayerSelectObject(playerid, type, objectid, modelid, fX, fY, fZ)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="type">
			</param>
			<param name="objectid">
			</param>
			<param name="modelid">
			</param>
			<param name="fX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fZ">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerSelectedMenuRow" syntax="OnPlayerSelectedMenuRow(playerid, row)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="row">
			</param>
		</member>
		<member name="M:OnPlayerShootDynamicObject" syntax="OnPlayerShootDynamicObject(playerid, weaponid, objectid, x, y, z)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="weaponid">
			</param>
			<param name="objectid">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerSpawn" syntax="OnPlayerSpawn(playerid)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<dependency name="PlayerInfo"/>
			<dependency name="PlayerInfo"/>
			<dependency name="SetPlayerColor"/>
			<dependency name="SetPlayerScore"/>
			<dependency name="SetPlayerSkin"/>
			<dependency name="Ulogovan"/>
			<dependency name="player_level"/>
			<dependency name="player_skin"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerStateChange" syntax="OnPlayerStateChange(playerid, newstate, oldstate)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="newstate">
			</param>
			<param name="oldstate">
			</param>
		</member>
		<member name="M:OnPlayerStreamIn" syntax="OnPlayerStreamIn(playerid, forplayerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:OnPlayerStreamOut" syntax="OnPlayerStreamOut(playerid, forplayerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:OnPlayerTakeDamage" syntax="OnPlayerTakeDamage(playerid, issuerid, amount, weaponid, bodypart)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="issuerid">
			</param>
			<param name="amount">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="weaponid">
			</param>
			<param name="bodypart">
			</param>
		</member>
		<member name="M:OnPlayerText" syntax="OnPlayerText(playerid, text[])">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerUpdate" syntax="OnPlayerUpdate(playerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerWeaponShot" syntax="OnPlayerWeaponShot(playerid, weaponid, hittype, hitid, fX, fY, fZ)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="weaponid">
			</param>
			<param name="hittype">
			</param>
			<param name="hitid">
			</param>
			<param name="fX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fZ">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnRconCommand" syntax="OnRconCommand(cmd[])">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="cmd">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:OnRconLoginAttempt" syntax="OnRconLoginAttempt(ip[], password[], success)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="ip">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="password">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="success">
			</param>
		</member>
		<member name="M:OnRuntimeError" syntax="OnRuntimeError(code, &amp;suppress)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<dependency name="Debug_Print0"/>
			<dependency name="Malloc_SolidifyHeap"/>
			<dependency name="YSI_g_scErrorMessage1"/>
			<dependency name="YSI_g_scErrorMessage2"/>
			<dependency name="YSI_g_scErrorMessage3"/>
			<param name="code">
			</param>
			<param name="suppress">
				<paraminfo>bool &amp; </paraminfo>
			</param>
		</member>
		<member name="M:OnScriptInit" syntax="OnScriptInit()">
			<stacksize value="1"/>
		</member>
		<member name="M:OnTrailerUpdate" syntax="OnTrailerUpdate(playerid, vehicleid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:OnUnoccupiedVehicleUpdate" syntax="OnUnoccupiedVehicleUpdate(vehicleid, playerid, passenger_seat, new_x, new_y, new_z, vel_x, vel_y, vel_z)">
			<stacksize value="1"/>
			<param name="vehicleid">
			</param>
			<param name="playerid">
			</param>
			<param name="passenger_seat">
			</param>
			<param name="new_x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="new_y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="new_z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="vel_x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="vel_y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="vel_z">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnVehicleDamageStatusUpdate" syntax="OnVehicleDamageStatusUpdate(vehicleid, playerid)">
			<stacksize value="1"/>
			<param name="vehicleid">
			</param>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnVehicleDeath" syntax="OnVehicleDeath(vehicleid, killerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="vehicleid">
			</param>
			<param name="killerid">
			</param>
		</member>
		<member name="M:OnVehicleMod" syntax="OnVehicleMod(playerid, vehicleid, componentid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
			<param name="componentid">
			</param>
		</member>
		<member name="M:OnVehiclePaintjob" syntax="OnVehiclePaintjob(playerid, vehicleid, paintjobid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
			<param name="paintjobid">
			</param>
		</member>
		<member name="M:OnVehicleRespray" syntax="OnVehicleRespray(playerid, vehicleid, color1, color2)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
			<param name="color1">
			</param>
			<param name="color2">
			</param>
		</member>
		<member name="M:OnVehicleSirenStateChange" syntax="OnVehicleSirenStateChange(playerid, vehicleid, newstate)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
			<param name="newstate">
			</param>
		</member>
		<member name="M:OnVehicleSpawn" syntax="OnVehicleSpawn(vehicleid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:OnVehicleStreamIn" syntax="OnVehicleStreamIn(vehicleid, forplayerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="vehicleid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:OnVehicleStreamOut" syntax="OnVehicleStreamOut(vehicleid, forplayerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="vehicleid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:PA_Init" syntax="PA_Init(a[], init, s)">
			<stacksize value="2"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_Add"/>
			<param name="a">
				<paraminfo>Bit [] </paraminfo>
			</param>
			<param name="init">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="s">
			</param>
		</member>
		<member name="M:PA_Set" syntax="PA_Set(d[], slot, set)">
			<stacksize value="1"/>
			<referrer name="Command_SetPlayerDisabled"/>
			<referrer name="Command_SetPlayer"/>
			<dependency name="cellbits"/>
			<param name="d">
				<paraminfo>Bit [] </paraminfo>
			</param>
			<param name="slot">
			</param>
			<param name="set">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:PlayerPlaySound" syntax="PlayerPlaySound(playerid, soundid, x, y, z)">
			<attribute name="native"/>
			<referrer name="OnPlayerCommandReceived"/>
			<referrer name="@yH_OnPlayerKeyStateChange@015"/>
			<referrer name="@yH_OnPlayerKeyStateChange@016"/>
			<param name="playerid">
			</param>
			<param name="soundid">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:PlayerTextDrawAlignment" syntax="PlayerTextDrawAlignment(playerid, text, alignment)">
			<attribute name="native"/>
			<referrer name="CreatePTextDraws"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo>PlayerText </paraminfo>
			</param>
			<param name="alignment">
			</param>
		</member>
		<member name="M:PlayerTextDrawBackgroundColor" syntax="PlayerTextDrawBackgroundColor(playerid, text, color)">
			<attribute name="native"/>
			<referrer name="CreatePTextDraws"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo>PlayerText </paraminfo>
			</param>
			<param name="color">
			</param>
		</member>
		<member name="M:PlayerTextDrawColor" syntax="PlayerTextDrawColor(playerid, text, color)">
			<attribute name="native"/>
			<referrer name="CreatePTextDraws"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo>PlayerText </paraminfo>
			</param>
			<param name="color">
			</param>
		</member>
		<member name="M:PlayerTextDrawFont" syntax="PlayerTextDrawFont(playerid, text, font)">
			<attribute name="native"/>
			<referrer name="CreatePTextDraws"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo>PlayerText </paraminfo>
			</param>
			<param name="font">
			</param>
		</member>
		<member name="M:PlayerTextDrawLetterSize" syntax="PlayerTextDrawLetterSize(playerid, text, x, y)">
			<attribute name="native"/>
			<referrer name="CreatePTextDraws"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo>PlayerText </paraminfo>
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:PlayerTextDrawSetProportional" syntax="PlayerTextDrawSetProportional(playerid, text, set)">
			<attribute name="native"/>
			<referrer name="CreatePTextDraws"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo>PlayerText </paraminfo>
			</param>
			<param name="set">
			</param>
		</member>
		<member name="M:PlayerTextDrawSetShadow" syntax="PlayerTextDrawSetShadow(playerid, text, size)">
			<attribute name="native"/>
			<referrer name="CreatePTextDraws"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo>PlayerText </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:PlayerTextDrawSetString" syntax="PlayerTextDrawSetString(playerid, text, string[])">
			<attribute name="native"/>
			<referrer name="GlobalTimer"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo>PlayerText </paraminfo>
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:PlayerTextDrawShow" syntax="PlayerTextDrawShow(playerid, text)">
			<attribute name="native"/>
			<referrer name="@yH_OnPlayerSpawn@019"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo>PlayerText </paraminfo>
			</param>
		</member>
		<member name="M:PlayerTextDrawTextSize" syntax="PlayerTextDrawTextSize(playerid, text, x, y)">
			<attribute name="native"/>
			<referrer name="CreatePTextDraws"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo>PlayerText </paraminfo>
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:Pop" syntax="Pop(&amp;arg)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="false"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<dependency name="true"/>
			<param name="arg">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:PrintAmxHeader" syntax="PrintAmxHeader()">
			<stacksize value="4"/>
			<dependency name="AMX_HDR_AMX_VERSION"/>
			<dependency name="AMX_HDR_CIP"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_FILE_VERSION"/>
			<dependency name="AMX_HDR_FLAGS"/>
			<dependency name="AMX_HDR_HEA"/>
			<dependency name="AMX_HDR_LIBRARIES"/>
			<dependency name="AMX_HDR_MAGIC"/>
			<dependency name="AMX_HDR_NAMETABLE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="AMX_HDR_SIZE"/>
			<dependency name="AMX_HDR_STP"/>
			<dependency name="AMX_HDR_TAGS"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="printf"/>
		</member>
		<member name="M:PrintStackTrace" syntax="PrintStackTrace(trace[], max)">
			<stacksize value="40"/>
			<dependency name="GetFunctionFromReturnAddress"/>
			<dependency name="GetPublicNameFromAddress"/>
			<dependency name="print"/>
			<dependency name="printf"/>
			<param name="trace">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="max">
			</param>
		</member>
		<member name="M:ProfilerInit" syntax="ProfilerInit()">
			<stacksize value="31"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="HookPublic"/>
			<dependency name="g_num_publics"/>
			<dependency name="g_pecs"/>
			<dependency name="g_publics"/>
			<dependency name="g_publics"/>
			<dependency name="new_pec"/>
			<dependency name="ppi_child_time"/>
			<dependency name="ppi_num_calls"/>
			<dependency name="ppi_total_time"/>
			<dependency name="printf"/>
		</member>
		<member name="M:ProfilerWriteData" syntax="ProfilerWriteData(filename[])">
			<tagname value="bool"/>
			<stacksize value="144"/>
			<dependency name="GetPublicNameFromIndex"/>
			<dependency name="false"/>
			<dependency name="fclose"/>
			<dependency name="fopen"/>
			<dependency name="format"/>
			<dependency name="fwrite"/>
			<dependency name="g_num_publics"/>
			<dependency name="g_publics"/>
			<dependency name="g_publics"/>
			<dependency name="io_write"/>
			<dependency name="ppi_child_time"/>
			<dependency name="ppi_num_calls"/>
			<dependency name="ppi_total_time"/>
			<dependency name="true"/>
			<param name="filename">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Proxara" syntax="Proxara(radi, playerid, string[], col1, col2, col3, col4, col5)">
			<stacksize value="16"/>
			<referrer name="@_yCdo"/>
			<referrer name="@_yCb"/>
			<referrer name="@_yCme"/>
			<dependency name="operator/(Float:,_:)"/>
			<dependency name="operator-(Float:)"/>
			<dependency name="operator-(Float:,Float:)"/>
			<dependency name="operator&gt;(Float:,Float:)"/>
			<dependency name="operator&lt;(Float:,Float:)"/>
			<dependency name="GetPlayerPos"/>
			<dependency name="GetPlayerVirtualWorld"/>
			<dependency name="Iterator@Player"/>
			<dependency name="SendClientMessage"/>
			<dependency name="Ulogovan"/>
			<param name="radi">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="playerid">
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="col1">
			</param>
			<param name="col2">
			</param>
			<param name="col3">
			</param>
			<param name="col4">
			</param>
			<param name="col5">
			</param>
		</member>
		<member name="M:Puny_Adapt" syntax="Puny_Adapt(delta, length, firstTime)">
			<stacksize value="2"/>
			<referrer name="Puny_Decode"/>
			<referrer name="Puny_Encode"/>
			<referrer name="Puny_EncodeHash"/>
			<dependency name="PUNY_DAMP"/>
			<dependency name="PUNY_SKEW"/>
			<dependency name="PUNY_TMAX"/>
			<dependency name="PUNY_TMIN"/>
			<param name="delta">
				Part of the state machine.
			</param>
			<param name="length">
				Written string size.
			</param>
			<param name="firstTime">
				<paraminfo>bool </paraminfo>
				Have special characters already been written?
			</param>
			      <remarks>  This is part of how the punycode algorithm encodes numbers as very clever  strings, but honestly I don't fully understand it!  </remarks> 
		</member>
		<member name="M:Puny_Decode" syntax="Puny_Decode(dst[], src[], wlen, delimiter)">
			<stacksize value="14"/>
			<dependency name="PUNY_BIAS"/>
			<dependency name="PUNY_INIT"/>
			<dependency name="PUNY_TMAX"/>
			<dependency name="PUNY_TMIN"/>
			<dependency name="Puny_Adapt"/>
			<dependency name="YSI_gscDecoder"/>
			<dependency name="cellmax"/>
			<dependency name="strcat"/>
			<dependency name="strins"/>
			<dependency name="strlen"/>
			<param name="dst">
				<paraminfo> [] </paraminfo>
				Where to store the converted string.
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
				The string to convert.
			</param>
			<param name="wlen">
				The length of the destination.
			</param>
			<param name="delimiter">
				What character is between the parts.
			</param>
			        <remarks>  Takes a punycode string and converts it to unicode.  </remarks> 
		</member>
		<member name="M:Puny_Encode" syntax="Puny_Encode(dst[], src[], wlen, delimiter)">
			<stacksize value="16"/>
			<dependency name="PUNY_BIAS"/>
			<dependency name="PUNY_INIT"/>
			<dependency name="Puny_Adapt"/>
			<dependency name="Puny_EncodeVar"/>
			<dependency name="cellmax"/>
			<dependency name="strlen"/>
			<param name="dst">
				<paraminfo> [] </paraminfo>
				Where to store the converted string.
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
				The string to convert.
			</param>
			<param name="wlen">
				The length of the destination.
			</param>
			<param name="delimiter">
				What character to place between the parts.
			</param>
			        <remarks>  Takes a unicode string and converts it to punycode.  </remarks> 
		</member>
		<member name="M:Puny_EncodeHash" syntax="Puny_EncodeHash(dst[], src[], &amp;hash, wlen, delimiter)">
			<stacksize value="149"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="Command_Find"/>
			<dependency name="PUNY_BIAS"/>
			<dependency name="PUNY_INIT"/>
			<dependency name="Puny_Adapt"/>
			<dependency name="Puny_EncodeVarHash"/>
			<dependency name="cellmax"/>
			<dependency name="false"/>
			<dependency name="ispacked"/>
			<dependency name="strcat"/>
			<dependency name="strpack"/>
			<dependency name="strunpack"/>
			<dependency name="tolower"/>
			<dependency name="true"/>
			<param name="dst">
				<paraminfo> [] </paraminfo>
				Where to store the converted string.
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
				The string to convert.
			</param>
			<param name="hash">
				<paraminfo> &amp; </paraminfo>
				Store the hash value.
			</param>
			<param name="wlen">
				The length of the destination.
			</param>
			<param name="delimiter">
				What character to place between the parts.
			</param>
			          <returns>  The length of string read.  </returns>  <remarks>  Takes a unicode string and converts it to punycode, while at the same time  generating a Bernstein hash of the string.  CASE INSENSITIVE.  </remarks> 
		</member>
		<member name="M:Puny_EncodeVar" syntax="Puny_EncodeVar(bias, delta, dst[], wlen)">
			<stacksize value="5"/>
			<referrer name="Puny_Encode"/>
			<dependency name="PUNY_TMAX"/>
			<dependency name="PUNY_TMIN"/>
			<param name="bias">
				Part of the state machine.
			</param>
			<param name="delta">
				Part of the state machine.
			</param>
			<param name="dst">
				<paraminfo> [] </paraminfo>
				Array to write to.
			</param>
			<param name="wlen">
				Size of the array.
			</param>
			        <remarks>  This is part of how the punycode algorithm encodes numbers as very clever  strings, but honestly I don't fully understand it!  </remarks> 
		</member>
		<member name="M:Puny_EncodeVarHash" syntax="Puny_EncodeVarHash(bias, delta, dst[], wlen, &amp;hash)">
			<stacksize value="5"/>
			<referrer name="Puny_EncodeHash"/>
			<dependency name="PUNY_TMAX"/>
			<dependency name="PUNY_TMIN"/>
			<param name="bias">
				Part of the state machine.
			</param>
			<param name="delta">
				Part of the state machine.
			</param>
			<param name="dst">
				<paraminfo> [] </paraminfo>
				Array to write to.
			</param>
			<param name="wlen">
				Size of the array.
			</param>
			<param name="hash">
				<paraminfo> &amp; </paraminfo>
				Hashed string.
			</param>
			          <remarks>  This is part of how the punycode algorithm encodes numbers as very clever  strings, but honestly I don't fully understand it!  </remarks> 
		</member>
		<member name="M:Push" syntax="Push(arg)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="PushString"/>
			<dependency name="false"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<dependency name="true"/>
			<param name="arg">
			</param>
		</member>
		<member name="M:PushString" syntax="PushString(string[])">
			<tagname value="bool"/>
			<stacksize value="5"/>
			<dependency name="Push"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:PutPlayerInVehicle" syntax="PutPlayerInVehicle(playerid, vehicleid, seatid)">
			<attribute name="native"/>
			<referrer name="@_yCstaffvehicle"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
			<param name="seatid">
			</param>
		</member>
		<member name="M:R@" syntax="R@(buffer[])">
			<stacksize value="6"/>
			<referrer name="Command_GetName@"/>
			<referrer name="Command_GetDisplay@"/>
			<referrer name="Command_GetDisplayNamed@"/>
			<referrer name="Command_GetNext@"/>
			<dependency name="setproperty"/>
			<param name="buffer">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Random" syntax="Random(min, max)">
			<stacksize value="3"/>
			<dependency name="cellmin"/>
			<dependency name="random"/>
			<param name="min">
			</param>
			<param name="max">
				Upper bound.
			</param>
			<param name="minmax">Lower bound, or upper bound when only parameter.</param>    <remarks>  Generate a random float between the given numbers (min &lt;= n &lt; max).  Default minimum is 0 (changes the parameter order).  </remarks> 
		</member>
		<member name="M:RandomFloat" syntax="RandomFloat(min, max, dp)">
			<tagname value="Float"/>
			<stacksize value="5"/>
			<dependency name="operator!=(Float:,Float:)"/>
			<dependency name="operator-(Float:)"/>
			<dependency name="operator-(Float:,Float:)"/>
			<dependency name="operator+(Float:,Float:)"/>
			<dependency name="operator/(Float:,Float:)"/>
			<dependency name="operator*(Float:,Float:)"/>
			<dependency name="operator&lt;(Float:,Float:)"/>
			<dependency name="float"/>
			<dependency name="floatpower"/>
			<dependency name="floatround"/>
			<dependency name="random"/>
			<param name="min">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="max">
				<paraminfo>Float </paraminfo>
				Upper bound.
			</param>
			<param name="dp">
				How small to make the differences
			</param>
			<param name="minmax">Lower bound, or upper bound when only parameter.</param>      <remarks>  Generate a random float between the given numbers (min &lt;= n &lt; max).  Default  minimum is 0.0 (changes the parameter order).  </remarks> 
		</member>
		<member name="M:Range" syntax="Range(arr[], num)">
			<stacksize value="4"/>
			<dependency name="cellmax"/>
			<dependency name="cellmin"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array whose values need averaging.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <returns>  The mathematical range of the values of the array.  </returns> 
		</member>
		<member name="M:ReadAmxCell" syntax="ReadAmxCell(offset)">
			<stacksize value="5"/>
			<dependency name="GetAmxAddress"/>
			<dependency name="ReadPhysMemoryCell"/>
			<param name="offset">
			</param>
		</member>
		<member name="M:ReadAmxMemory" syntax="ReadAmxMemory(address)">
			<stacksize value="1"/>
			<referrer name="ReadAmxMemoryArray"/>
			<referrer name="GetRawAmxHeader"/>
			<referrer name="NtCompare"/>
			<referrer name="NtCopy"/>
			<referrer name="GetPublicIndexFromAddress"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="HookPublic"/>
			<referrer name="GetNativeIndexFromAddress"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="HookNative"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetPubVarIndexFromAddress"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagIndexFromName"/>
			<referrer name="GetTagIndexFromID"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="DisasmGetOperand"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DisasmWriteDataRowChar"/>
			<referrer name="DisasmWriteDataRowHex"/>
			<referrer name="CodeScanCheckJumpTarget"/>
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="DumpStack"/>
			<referrer name="YVA2_FoundCall"/>
			<param name="address">
			</param>
		</member>
		<member name="M:ReadAmxMemoryArray" syntax="ReadAmxMemoryArray(address, values[], size)">
			<stacksize value="5"/>
			<dependency name="ReadAmxMemory"/>
			<param name="address">
			</param>
			<param name="values">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:ReadOpcodeNearThis" syntax="ReadOpcodeNearThis(offset)">
			<tagname value="Opcode"/>
			<stacksize value="2"/>
			<referrer name="HaveToRelocateOpcodes"/>
			<referrer name="RelocateOpcodeNow"/>
			<dependency name="OP_NONE"/>
			<param name="offset">
			</param>
		</member>
		<member name="M:ReadPhysMemory" syntax="ReadPhysMemory(address, dest[], num)">
			<stacksize value="5"/>
			<dependency name="AbsToRel"/>
			<param name="address">
			</param>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:ReadPhysMemoryCell" syntax="ReadPhysMemoryCell(address)">
			<stacksize value="5"/>
			<referrer name="ReadAmxCell"/>
			<dependency name="AbsToRel"/>
			<param name="address">
			</param>
		</member>
		<member name="M:RelToAbs" syntax="RelToAbs(address)">
			<stacksize value="3"/>
			<referrer name="refabs"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetDat"/>
			<param name="address">
			</param>
		</member>
		<member name="M:RelocateOpcode" syntax="RelocateOpcode(opcode)">
			<tagname value="Opcode"/>
			<stacksize value="3"/>
			<referrer name="SysreqC"/>
			<referrer name="SysreqD"/>
			<referrer name="SysreqCN"/>
			<referrer name="SysreqDN"/>
			<referrer name="CallNative"/>
			<referrer name="CallNativeByAddress"/>
			<referrer name="AsmEmitOpcode"/>
			<referrer name="AsmEmitPadding"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="GetOS"/>
			<referrer name="new_pec"/>
			<referrer name="YVA2_CodeGenShiftCode"/>
			<referrer name="AMX_OnScriptInit"/>
			<referrer name="CGen_SetupCodeSpace"/>
			<referrer name="I@E"/>
			<referrer name="StoredF_IsHooked"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<dependency name="InitOpcodeTable"/>
			<dependency name="opcode_table"/>
			<dependency name="opcode_table_is_ready"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:RelocateOpcodeNow" syntax="RelocateOpcodeNow(opcode)">
			<tagname value="Opcode"/>
			<stacksize value="5"/>
			<referrer name="RelocateOpcodeNow"/>
			<referrer name="InitOpcodeTable"/>
			<dependency name="HaveToRelocateOpcodes"/>
			<dependency name="OP_ADD"/>
			<dependency name="OP_ADDR_ALT"/>
			<dependency name="OP_ADDR_PRI"/>
			<dependency name="OP_ADD_C"/>
			<dependency name="OP_ALIGN_ALT"/>
			<dependency name="OP_ALIGN_PRI"/>
			<dependency name="OP_AND"/>
			<dependency name="OP_BOUNDS"/>
			<dependency name="OP_BREAK"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_CMPS"/>
			<dependency name="OP_CONST_ALT"/>
			<dependency name="OP_CONST_PRI"/>
			<dependency name="OP_DEC"/>
			<dependency name="OP_DEC_ALT"/>
			<dependency name="OP_DEC_I"/>
			<dependency name="OP_DEC_PRI"/>
			<dependency name="OP_DEC_S"/>
			<dependency name="OP_EQ"/>
			<dependency name="OP_EQ_C_ALT"/>
			<dependency name="OP_EQ_C_PRI"/>
			<dependency name="OP_FILL"/>
			<dependency name="OP_GEQ"/>
			<dependency name="OP_GRTR"/>
			<dependency name="OP_HALT"/>
			<dependency name="OP_HEAP"/>
			<dependency name="OP_IDXADDR"/>
			<dependency name="OP_IDXADDR_B"/>
			<dependency name="OP_INC"/>
			<dependency name="OP_INC_ALT"/>
			<dependency name="OP_INC_I"/>
			<dependency name="OP_INC_PRI"/>
			<dependency name="OP_INC_S"/>
			<dependency name="OP_INVERT"/>
			<dependency name="OP_JEQ"/>
			<dependency name="OP_JGEQ"/>
			<dependency name="OP_JGRTR"/>
			<dependency name="OP_JLEQ"/>
			<dependency name="OP_JLESS"/>
			<dependency name="OP_JNEQ"/>
			<dependency name="OP_JNZ"/>
			<dependency name="OP_JSGEQ"/>
			<dependency name="OP_JSGRTR"/>
			<dependency name="OP_JSLEQ"/>
			<dependency name="OP_JSLESS"/>
			<dependency name="OP_JUMP"/>
			<dependency name="OP_JZER"/>
			<dependency name="OP_LCTRL"/>
			<dependency name="OP_LEQ"/>
			<dependency name="OP_LESS"/>
			<dependency name="OP_LIDX"/>
			<dependency name="OP_LIDX_B"/>
			<dependency name="OP_LOAD_ALT"/>
			<dependency name="OP_LOAD_I"/>
			<dependency name="OP_LOAD_PRI"/>
			<dependency name="OP_LOAD_S_ALT"/>
			<dependency name="OP_LOAD_S_PRI"/>
			<dependency name="OP_LODB_I"/>
			<dependency name="OP_LREF_ALT"/>
			<dependency name="OP_LREF_PRI"/>
			<dependency name="OP_LREF_S_ALT"/>
			<dependency name="OP_LREF_S_PRI"/>
			<dependency name="OP_MOVE_ALT"/>
			<dependency name="OP_MOVE_PRI"/>
			<dependency name="OP_MOVS"/>
			<dependency name="OP_NEG"/>
			<dependency name="OP_NEQ"/>
			<dependency name="OP_NOP"/>
			<dependency name="OP_NOT"/>
			<dependency name="OP_OR"/>
			<dependency name="OP_POP_ALT"/>
			<dependency name="OP_POP_PRI"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_PUSH"/>
			<dependency name="OP_PUSH_ADR"/>
			<dependency name="OP_PUSH_ALT"/>
			<dependency name="OP_PUSH_C"/>
			<dependency name="OP_PUSH_PRI"/>
			<dependency name="OP_PUSH_S"/>
			<dependency name="OP_RET"/>
			<dependency name="OP_RETN"/>
			<dependency name="OP_SCTRL"/>
			<dependency name="OP_SDIV"/>
			<dependency name="OP_SDIV_ALT"/>
			<dependency name="OP_SGEQ"/>
			<dependency name="OP_SGRTR"/>
			<dependency name="OP_SHL"/>
			<dependency name="OP_SHL_C_ALT"/>
			<dependency name="OP_SHL_C_PRI"/>
			<dependency name="OP_SHR"/>
			<dependency name="OP_SHR_C_ALT"/>
			<dependency name="OP_SHR_C_PRI"/>
			<dependency name="OP_SIGN_ALT"/>
			<dependency name="OP_SIGN_PRI"/>
			<dependency name="OP_SLEQ"/>
			<dependency name="OP_SLESS"/>
			<dependency name="OP_SMUL"/>
			<dependency name="OP_SMUL_C"/>
			<dependency name="OP_SREF_ALT"/>
			<dependency name="OP_SREF_PRI"/>
			<dependency name="OP_SREF_S_ALT"/>
			<dependency name="OP_SREF_S_PRI"/>
			<dependency name="OP_SSHR"/>
			<dependency name="OP_STACK"/>
			<dependency name="OP_STOR_ALT"/>
			<dependency name="OP_STOR_I"/>
			<dependency name="OP_STOR_PRI"/>
			<dependency name="OP_STOR_S_ALT"/>
			<dependency name="OP_STOR_S_PRI"/>
			<dependency name="OP_STRB_I"/>
			<dependency name="OP_SUB"/>
			<dependency name="OP_SUB_ALT"/>
			<dependency name="OP_SWAP_ALT"/>
			<dependency name="OP_SWAP_PRI"/>
			<dependency name="OP_SWITCH"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="OP_UDIV"/>
			<dependency name="OP_UDIV_ALT"/>
			<dependency name="OP_UMUL"/>
			<dependency name="OP_XCHG"/>
			<dependency name="OP_XOR"/>
			<dependency name="OP_ZERO"/>
			<dependency name="OP_ZERO_ALT"/>
			<dependency name="OP_ZERO_PRI"/>
			<dependency name="OP_ZERO_S"/>
			<dependency name="ReadOpcodeNearThis"/>
			<dependency name="debug"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:Remote_DoSearch" syntax="Remote_DoSearch(str[], ptr)">
			<stacksize value="2"/>
			<referrer name="GetRemoteFunction"/>
			<dependency name="strcmp"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to find.
			</param>
			<param name="ptr">
				Start of the linked list.
			</param>
			    <remarks>  Finds a given string in a given list.  </remarks> 
		</member>
		<member name="M:Remote_RawStrpack" syntax="Remote_RawStrpack(dest, src[])">
			<stacksize value="6"/>
			<referrer name="Remote_WriteJustSpec"/>
			<referrer name="Remote_WriteSpecAndFunc"/>
			<dependency name="Malloc_Allocate"/>
			<dependency name="YSI_gMallocMemory"/>
			<dependency name="strlen"/>
			<dependency name="strpack"/>
			<param name="dest">
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Remote_WriteJustSpec" syntax="Remote_WriteJustSpec(sptr, spec[])">
			<stacksize value="6"/>
			<referrer name="GetRemoteFunction"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="CGen_AddCodeSpace"/>
			<dependency name="CGen_GetCodeSpace"/>
			<dependency name="Remote_RawStrpack"/>
			<param name="sptr">
			</param>
			<param name="spec">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Remote_WriteSpecAndFunc" syntax="Remote_WriteSpecAndFunc(fptr, func[], sptr, spec[])">
			<stacksize value="30"/>
			<referrer name="GetRemoteFunction"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmEmitConstAlt"/>
			<dependency name="AsmEmitConstPri"/>
			<dependency name="AsmEmitJnzRel"/>
			<dependency name="AsmEmitJump"/>
			<dependency name="AsmEmitLrefSPri"/>
			<dependency name="AsmEmitStorSAlt"/>
			<dependency name="CGen_AddCodeSpace"/>
			<dependency name="CGen_GetCodeSpace"/>
			<dependency name="CGen_UseCodeSpace"/>
			<dependency name="NULL"/>
			<dependency name="Remote_RawStrpack"/>
			<dependency name="YSI_g_sRemoteStub"/>
			<dependency name="ref"/>
			<dependency name="strlen"/>
			<param name="fptr">
				Pointer in which to store the function.
			</param>
			<param name="func">
				<paraminfo> [] </paraminfo>
				Name of the function.
			</param>
			<param name="sptr">
				Pointer to the stored specifier string.
			</param>
			<param name="spec">
				<paraminfo> [] </paraminfo>
				Usable specifier string.
			</param>
			        <returns>  A pointer to the start of the newly generated code.  </returns>  <remarks>  Generates a tiny function-specific stub that sets the values for the  function and specifier strings to pass to "CallRemoteFunction", and checks  for any empty strings - converting them to "NULL" instead.  </remarks> 
		</member>
		<member name="M:Remote_WriteStubCode" syntax="Remote_WriteStubCode()">
			<stacksize value="28"/>
			<referrer name="GetRemoteFunction"/>
			<referrer name="Remote_WriteStubCode"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_REAL_DATA"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmEmitAddC"/>
			<dependency name="AsmEmitJump"/>
			<dependency name="AsmEmitLoadSPri"/>
			<dependency name="AsmEmitPopPri"/>
			<dependency name="AsmEmitSctrl"/>
			<dependency name="AsmEmitStack"/>
			<dependency name="AsmEmitStorPri"/>
			<dependency name="AsmEmitStorSAlt"/>
			<dependency name="AsmEmitStorSPri"/>
			<dependency name="AsmEmitSwapPri"/>
			<dependency name="AsmEmitSysreq"/>
			<dependency name="AsmInitPtr"/>
			<remarks>  This rewrites itself to be the bulk of the call to "CallRemoteFunction".  It  modifies the stack so that the parameters already pushed are the parameters  passed to the native function.  </remarks> 
		</member>
		<member name="M:RemoveBuildingForPlayer" syntax="RemoveBuildingForPlayer(playerid, modelid, fX, fY, fZ, fRadius)">
			<attribute name="native"/>
			<referrer name="ObrisiObjekte"/>
			<param name="playerid">
			</param>
			<param name="modelid">
			</param>
			<param name="fX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fZ">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fRadius">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:ResetPlayerMoney" syntax="ResetPlayerMoney(playerid)">
			<attribute name="native"/>
			<referrer name="DajIgracuNovac"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:ResetStaticAmxHeader" syntax="ResetStaticAmxHeader()">
			<stacksize value="4"/>
			<referrer name="GetAmxHeader"/>
			<referrer name="GetAmxHeaderComponent"/>
			<referrer name="PrintAmxHeader"/>
			<referrer name="GetPublicIndexFromAddress"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="HookPublic"/>
			<referrer name="GetNativeIndexFromAddress"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="HookNative"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetPubVarIndexFromAddress"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagIndexFromName"/>
			<referrer name="GetTagIndexFromID"/>
			<referrer name="Hooks_SortPublics"/>
			<dependency name="GetAmxHeaderNow"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="true"/>
		</member>
		<member name="M:ResolveJITAddress" syntax="ResolveJITAddress(addr)">
			<stacksize value="1"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:ReturnPlayerName" syntax="ReturnPlayerName(playerid)">
			<stacksize value="29"/>
			<dependency name="GetPlayerName"/>
			<dependency name="ReturnPlayerName"/>
			<param name="playerid">
				Player whose name you want to get.
			</param>
			<summary>  ReturnPlayerName  </summary>    <remarks>  Now uses a global array to avoid repeated function calls.  Actually doesn't  because that causes issues with multiple scripts.  </remarks> 
		</member>
		<member name="M:RunShellcode" syntax="RunShellcode(code_ptr, align)">
			<stacksize value="5"/>
			<referrer name="GetAmxAddress"/>
			<dependency name="SysreqD"/>
			<param name="code_ptr">
			</param>
			<param name="align">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:S@" syntax="S@(v)">
			<stacksize value="6"/>
			<dependency name="Q@"/>
			<dependency name="getproperty"/>
			<dependency name="setproperty"/>
			<dependency name="strunpack"/>
			<param name="v">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:SCMF" syntax="SCMF(playerid, colour, format[], ...)">
			<stacksize value="399"/>
			<referrer name="@yH_OnDialogResponse@029"/>
			<dependency name="SendClientMessage"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_format"/>
			<param name="playerid">
			</param>
			<param name="colour">
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:SSCANF_GetClosestString" syntax="SSCANF_GetClosestString(input[], candidates[][], threshold, count)">
			<stacksize value="6"/>
			<referrer name="SSCANF_GetClosestValue"/>
			<dependency name="SSCANF_Levenshtein"/>
			<dependency name="cellmin"/>
			<param name="input">
				<paraminfo> [] </paraminfo>
				The first string to compare.
			</param>
			<param name="candidates">
				<paraminfo> [][] </paraminfo>
				A list of other strings to compare against.
			</param>
			<param name="threshold">
				How similar the strings must be to be considered a match.
			</param>
			<param name="count">
				The number of candidates.
			</param>
			<library>sscanf</library>          <remarks>  Takes an input string and an array of string possibilities (candidates) and  returns the index of the string closest to the input string.  If no valid  match is found, <c>-1</c> is returned.  Note that this will always return the  closest, even if the closest is not that close; which is why an optional  <c>threshold</c> parameter is available.  When this parameter is provided the  closest match must be closer in Levenshtein distance than the threshold,  otherwise again <c>-1</c> is returned.  </remarks> 
		</member>
		<member name="M:SSCANF_GetClosestValue" syntax="SSCANF_GetClosestValue(input[], candidates[][], results[], fail, threshold, count, check)">
			<stacksize value="8"/>
			<dependency name="SSCANF_GetClosestString"/>
			<dependency name="cellmin"/>
			<param name="input">
				<paraminfo> [] </paraminfo>
				The first string to compare.
			</param>
			<param name="candidates">
				<paraminfo> [][] </paraminfo>
				A list of other strings to compare against.
			</param>
			<param name="results">
				<paraminfo> [] </paraminfo>
				The values to return when the corresponding candidate (by index) is the closest  match.
			</param>
			<param name="fail">
				The value to return when there is no good match.
			</param>
			<param name="threshold">
				How similar the strings must be to be considered a match.
			</param>
			<param name="count">
				The number of candidates (must match <c>check</c>).
			</param>
			<param name="check">
				The number of results (must match <c>count</c>).
			</param>
			<library>sscanf</library>                <remarks>  Similar to <c>SSCANF_GetClosestString</c> in that it searches the  <c>candidates</c> array for the string most closely matching the <c>input</c>  and bounded by <c>threshold</c>.  But instead of returning the index this  function returns the value in the second <c>results</c> array at that index;  and instead of returning <c>-1</c> on failure it returns the value of  <c>fail</c>.  The two arrays must match in size and an <c>assert</c> in the  function checks for this.  </remarks> 
		</member>
		<member name="M:SSCANF_GetSimilarString" syntax="SSCANF_GetSimilarString(input[], candidates[][], threshold, count)">
			<stacksize value="6"/>
			<referrer name="SSCANF_GetSimilarValue"/>
			<dependency name="operator&gt;=(Float:,Float:)"/>
			<dependency name="SSCANF_TextSimilarity"/>
			<dependency name="cellmin"/>
			<param name="input">
				<paraminfo> [] </paraminfo>
				The first string to compare.
			</param>
			<param name="candidates">
				<paraminfo> [][] </paraminfo>
				A list of other strings to compare against.
			</param>
			<param name="threshold">
				<paraminfo>Float </paraminfo>
				How similar the strings must be to be considered a match.
			</param>
			<param name="count">
				The number of candidates.
			</param>
			<library>sscanf</library>          <remarks>  Takes an input string and an array of string possibilities (candidates) and  returns the index of the string closest to the input string.  If no valid  match is found, <c>-1</c> is returned.  Note that this will always return the  closest, even if the closest is not that close; which is why an optional  <c>threshold</c> parameter is available.  When this parameter is provided the  closest match must be closer in Levenshtein distance than the threshold,  otherwise again <c>-1</c> is returned.  </remarks> 
		</member>
		<member name="M:SSCANF_GetSimilarValue" syntax="SSCANF_GetSimilarValue(input[], candidates[][], results[], fail, threshold, count, check)">
			<stacksize value="8"/>
			<referrer name="sscanf_weapon"/>
			<referrer name="sscanf_vehicle"/>
			<dependency name="SSCANF_GetSimilarString"/>
			<dependency name="cellmin"/>
			<param name="input">
				<paraminfo> [] </paraminfo>
				The first string to compare.
			</param>
			<param name="candidates">
				<paraminfo> [][] </paraminfo>
				A list of other strings to compare against.
			</param>
			<param name="results">
				<paraminfo> [] </paraminfo>
				The values to return when the corresponding candidate (by index) is the closest  match.
			</param>
			<param name="fail">
				The value to return when there is no good match.
			</param>
			<param name="threshold">
				<paraminfo>Float </paraminfo>
				How similar the strings must be to be considered a match.
			</param>
			<param name="count">
				The number of candidates (must match <c>check</c>).
			</param>
			<param name="check">
				The number of results (must match <c>count</c>).
			</param>
			<library>sscanf</library>                <remarks>  Similar to <c>SSCANF_GetClosestString</c> in that it searches the  <c>candidates</c> array for the string most closely matching the <c>input</c>  and bounded by <c>threshold</c>.  But instead of returning the index this  function returns the value in the second <c>results</c> array at that index;  and instead of returning <c>-1</c> on failure it returns the value of  <c>fail</c>.  The two arrays must match in size and an <c>assert</c> in the  function checks for this.  </remarks> 
		</member>
		<member name="M:SSCANF_Init" syntax="SSCANF_Init(players, invalid, len)">
			<attribute name="native"/>
			<referrer name="SSCANF_RunInit"/>
			<param name="players">
				The maximum players on the server.
			</param>
			<param name="invalid">
				The invalid player ID.
			</param>
			<param name="len">
				<c>MAX_PLAYER_NAME</c>.
			</param>
			<library>sscanf</library>        <remarks>  Initialise the plugin with real server information.  </remarks> 
		</member>
		<member name="M:SSCANF_IsConnected" syntax="SSCANF_IsConnected(playerid)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="SSCANF_RunInit"/>
			<param name="playerid">
				The ID of the player.
			</param>
			<library>sscanf</library>    <remarks>  Checks if the plugin knows about a given player ID.  Used when modes restart  to re-add players.  </remarks> 
		</member>
		<member name="M:SSCANF_Join" syntax="SSCANF_Join(playerid, name[], npc)">
			<attribute name="native"/>
			<referrer name="SSCANF_RunInit"/>
			<referrer name="_y_utils_OnPlayerConnect"/>
			<param name="playerid">
				The ID of the player.
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The name of the player.
			</param>
			<param name="npc">
				<paraminfo>bool </paraminfo>
				Is this player an NPC?
			</param>
			<library>sscanf</library>        <remarks>  Called when a player joins to inform the plugin of the connection.  </remarks> 
		</member>
		<member name="M:SSCANF_Leave" syntax="SSCANF_Leave(playerid)">
			<attribute name="native"/>
			<referrer name="_y_utils_OnPlayerDisconnect"/>
			<param name="playerid">
				The ID of the player.
			</param>
			<library>sscanf</library>    <remarks>  Called when a player leaves to inform the plugin of the disconnection.  </remarks> 
		</member>
		<member name="M:SSCANF_Levenshtein" syntax="SSCANF_Levenshtein(string1[], string2[])">
			<attribute name="native"/>
			<referrer name="SSCANF_GetClosestString"/>
			<param name="string1">
				<paraminfo> [] </paraminfo>
				The first string to compare.
			</param>
			<param name="string2">
				<paraminfo> [] </paraminfo>
				The second string to compare.
			</param>
			<library>sscanf</library>      <remarks>  Computes the <a href="https://en.wikipedia.org/wiki/Levenshtein_distance">  Levenshtein Distance</a> between two strings.  This is simlar to  <c>strcmp</c> in usage, but is slightly more "fuzzy".  Distances are used to  work out which string is the most similar to another one, though they may not  be identical.  Useful in <c>k</c> callback functions to determine if the  entered string is close to a possible string.  </remarks> 
		</member>
		<member name="M:SSCANF_OnCachedInit" syntax="SSCANF_OnCachedInit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_ALS"/>
			<referrer name="OnCachedInit"/>
		</member>
		<member name="M:SSCANF_OnFilterScriptInit" syntax="SSCANF_OnFilterScriptInit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_ALS"/>
			<referrer name="ScriptInit_OnFilterScriptInit"/>
		</member>
		<member name="M:SSCANF_OnGameModeInit" syntax="SSCANF_OnGameModeInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="_ALS"/>
			<referrer name="ScriptInit_OnGameModeInit"/>
			<dependency name="CreateGTextDraws"/>
			<dependency name="DisableInteriorEnterExits"/>
			<dependency name="KreirajObjekte"/>
			<dependency name="LimitGlobalChatRadius"/>
			<dependency name="SendRconCommand"/>
			<dependency name="SetGameModeText"/>
			<dependency name="SetNameTagDrawDistance"/>
			<dependency name="Ucitaj_Pickups"/>
			<dependency name="Ucitaj_TextLabel"/>
		</member>
		<member name="M:SSCANF_OnPlayerConnect" syntax="SSCANF_OnPlayerConnect(playerid)">
			<attribute name="public"/>
			<stacksize value="141"/>
			<automaton name="_ALS"/>
			<referrer name="_y_utils_OnPlayerConnect"/>
			<dependency name="INI_ParseFile"/>
			<dependency name="IgracKojimSaljes"/>
			<dependency name="ObrisiObjekte"/>
			<dependency name="ShowPlayerDialog"/>
			<dependency name="TogglePlayerSpectating"/>
			<dependency name="Ulogovan"/>
			<dependency name="UserPath"/>
			<dependency name="UserPath"/>
			<dependency name="d_login"/>
			<dependency name="d_register"/>
			<dependency name="fexist"/>
			<dependency name="true"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:SSCANF_OnPlayerDisconnect" syntax="SSCANF_OnPlayerDisconnect(playerid, reason)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="_ALS"/>
			<referrer name="_y_utils_OnPlayerDisconnect"/>
			<dependency name="SacuvajKorisnike"/>
			<param name="playerid">
			</param>
			<param name="reason">
			</param>
		</member>
		<member name="M:SSCANF_OnScriptInit" syntax="SSCANF_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_ALS"/>
			<referrer name="Master_OnScriptInit"/>
		</member>
		<member name="M:SSCANF_Option" syntax="SSCANF_Option(name[], value)">
			<stacksize value="1"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The sscanf option to get or set.  For example <c>SSCANF_ARGB</c>.
			</param>
			<param name="value">
				<paraminfo> {_,Float} </paraminfo>
				The optional value to use when setting the option.
			</param>
			<library>sscanf</library>      <remarks>  Backwards-compatibility with <c>SSCANF_Option</c>.  Usage:  <code>  SSCANF_Option(SSCANF_QUIET, 1);           <br />  new quiet = SSCANF_Option(SSCANF_QUIET);  </code>  This doesn't actually use a default parameter because a user may want to set  the option to whatever that parameter is.  Instead this is a macro that calls  <c>SSCANF_GetOption__</c> when called with one parameter (just a name), or  instead calls <c>SSCANF_SetOption__</c> when called with two - a name and a  value.  </remarks> 
		</member>
		<member name="M:SSCANF_RunInit" syntax="SSCANF_RunInit()">
			<stacksize value="31"/>
			<referrer name="Master_OnScriptInit"/>
			<referrer name="ScriptInit_OnFilterScriptInit"/>
			<referrer name="ScriptInit_OnGameModeInit"/>
			<referrer name="OnCachedInit"/>
			<dependency name="GetMaxPlayers"/>
			<dependency name="GetPlayerName"/>
			<dependency name="IsPlayerConnected"/>
			<dependency name="IsPlayerNPC"/>
			<dependency name="SSCANF_Init"/>
			<dependency name="SSCANF_IsConnected"/>
			<dependency name="SSCANF_Join"/>
			<dependency name="SSCANF_gInit"/>
			<library>sscanf</library> <remarks> Generic initialisation code called from a range of different init publics. </remarks> <!-- <p/> <p/> There's a bug in the old compiler with the pawndoc generation for functions containing <c>state</c>.  This little trick starts an XML comment at the end of the documentation <c>SSCANF_RunInit</c> and immediately closes it again in a dedicated function <c>SSCANF_RunInit0</c>, which is sorted next lexicographically. --> <transition target="_ALS_go"/>

		</member>
		<member name="M:SSCANF_TextSimilarity" syntax="SSCANF_TextSimilarity(string1[], string2[])">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="SSCANF_GetSimilarString"/>
			<param name="string1">
				<paraminfo> [] </paraminfo>
				The first string to compare.
			</param>
			<param name="string2">
				<paraminfo> [] </paraminfo>
				The second string to compare.
			</param>
			<library>sscanf</library>      <remarks>  This works out the similarity between two strings.  The Levenshtein distance  often produces results that seem weird to people, for example by that measure  <c>NRG</c> is closer to <c>TUG</c> than <c>NRG-500</c>.  Instead this  function compares all pairs of letters between the two strings to work out  what percentage of each string is in the other string, then multiplies the  results to get the final similarity.  This algorithm produces much more human  sane results, and can handle things like <c>ls police<c> matching  <c>Police Car (LSPD)</c>.  It ignores all punctuation and case as well.  </remarks> 
		</member>
		<member name="M:SSCANF_Version" syntax="SSCANF_Version(version[], size)">
			<stacksize value="1"/>
			<dependency name="SSCANF_VERSION_BCD"/>
			<param name="version">
				<paraminfo> [] </paraminfo>
				Pass-by-reference return value.
			</param>
			<param name="size">
				The size of the destination array.
			</param>
			<library>sscanf</library>      <remarks>  Get the SSCANF plugin version as a string (e.g. <c>"2.11.2"</c>) <em>or</em>  a BCD-encoded value (e.g. <c>0x021102</c>).  This function returns a string  (by reference) when called with parameters, or a number (directly) when not.  </remarks> 
		</member>
		<member name="M:SSCANF__" syntax="SSCANF__(file[], line, data[], format[], ...)">
			<attribute name="native"/>
			<referrer name="@_yCdo"/>
			<referrer name="@_yCb"/>
			<referrer name="@_yCme"/>
			<referrer name="@_yCmakestaff"/>
			<referrer name="@_yCxgoto"/>
			<referrer name="@_yCdajnovac"/>
			<param name="file">
				<paraminfo> [] </paraminfo>
				The file in which this call is found.
			</param>
			<param name="line">
				The line at which this call is found.
			</param>
			<param name="data">
				<paraminfo> [] </paraminfo>
				The input string containing the data to parse out.
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
				The format description of what the input data should contain.
			</param>
			<param name="...">
				<paraminfo> {T_WEAPON,Float,_} </paraminfo>
			</param>
			<library>sscanf</library>          <remarks>  The current true implementation of <c>sscanf</c> in the plugin.  This is  wrapped by macros to provide <c>sscanf</c> enhanced with filenames and line  numbers so that errors have more information.  The plugin also contains a  native function called <c>sscanf</c> which is only for backwards-  compatibility with older versions of this include.  </remarks> 
		</member>
		<member name="M:SacuvajKorisnike" syntax="SacuvajKorisnike(playerid)">
			<stacksize value="134"/>
			<referrer name="DajIgracuNovac"/>
			<referrer name="@_yCmakestaff"/>
			<referrer name="@_yCstaffon"/>
			<referrer name="@_yCclearchat"/>
			<referrer name="@_yCotvoriracun"/>
			<referrer name="SSCANF_OnPlayerDisconnect"/>
			<dependency name="GetPlayerMoney"/>
			<dependency name="INI_Close"/>
			<dependency name="INI_Open"/>
			<dependency name="INI_SetTag"/>
			<dependency name="INI_WriteInt"/>
			<dependency name="PlayerInfo"/>
			<dependency name="PlayerInfo"/>
			<dependency name="Ulogovan"/>
			<dependency name="UserPath"/>
			<dependency name="UserPath"/>
			<dependency name="player_accountbank"/>
			<dependency name="player_bankmoney"/>
			<dependency name="player_level"/>
			<dependency name="player_skin"/>
			<dependency name="player_staff"/>
			<dependency name="true"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:ScriptInit_OnFilterScriptExit" syntax="ScriptInit_OnFilterScriptExit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_ALS"/>
			<referrer name="OnFilterScriptExit"/>
		</member>
		<member name="M:ScriptInit_OnFilterScriptInit" syntax="ScriptInit_OnFilterScriptInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="_ALS"/>
			<referrer name="OnFilterScriptInit"/>
			<dependency name="SSCANF_OnFilterScriptInit"/>
			<dependency name="SSCANF_RunInit"/>
			<dependency name="SSCANF_gInit"/>
			<library>sscanf</library>  <remarks>  Called when the script starts if it is a filterscript, sets up the system,  then calls the "real" OnFilterScriptInit (using the new ALS 2 hook method).  </remarks> 
		</member>
		<member name="M:ScriptInit_OnGameModeExit" syntax="ScriptInit_OnGameModeExit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_ALS"/>
			<referrer name="OnGameModeExit"/>
		</member>
		<member name="M:ScriptInit_OnGameModeInit" syntax="ScriptInit_OnGameModeInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="_ALS"/>
			<referrer name="OnGameModeInit"/>
			<dependency name="SSCANF_OnGameModeInit"/>
			<dependency name="SSCANF_RunInit"/>
			<dependency name="SSCANF_gInit"/>
			<library>sscanf</library>  <remarks>  Called when the script starts if it is a gamemode.  This callback is also  called in filterscripts so we don't want to reinitialise the system in that  case.  </remarks> 
		</member>
		<member name="M:ScriptInit_OnScriptExit" syntax="ScriptInit_OnScriptExit()">
			<attribute name="public"/>
			<stacksize value="13"/>
			<automaton name="_ALS"/>
			<referrer name="OnFilterScriptExit"/>
			<referrer name="OnGameModeExit"/>
			<dependency name="CallLocalFunction"/>
			<dependency name="CallRemoteFunction"/>
			<dependency name="Master_OnScriptExit"/>
			<dependency name="YSI_g_sMasterCount"/>
			<dependency name="YSI_g_sMasterData"/>
			<dependency name="_@"/>
			<dependency name="getproperty"/>
			<dependency name="setproperty"/>
			<returns>  OnGameModeExit  </returns>  <remarks>  Destructor.  </remarks> 
		</member>
		<member name="M:ScriptInit_OnScriptInit" syntax="ScriptInit_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="print"/>
		</member>
		<member name="M:SendClientMessage" syntax="SendClientMessage(playerid, color, message[])">
			<attribute name="native"/>
			<referrer name="va_SendClientMessage"/>
			<referrer name="SCMF"/>
			<referrer name="SendClientMessageEx"/>
			<referrer name="OnPlayerCommandReceived"/>
			<referrer name="@yH_OnPlayerText@013"/>
			<referrer name="@yH_OnPlayerKeyStateChange@016"/>
			<referrer name="Proxara"/>
			<referrer name="@_yCdo"/>
			<referrer name="@_yCb"/>
			<referrer name="@_yCme"/>
			<referrer name="AntiSpawnkill"/>
			<referrer name="@yH_OnPlayerSpawn@022"/>
			<referrer name="HPdaj"/>
			<referrer name="@_yCmakestaff"/>
			<referrer name="@_yCstaffon"/>
			<referrer name="@_yCclearchat"/>
			<referrer name="@_yCjetpack"/>
			<referrer name="@_yCstaffvehicle"/>
			<referrer name="@_yCxgoto"/>
			<referrer name="@_yCdajnovac"/>
			<referrer name="@_yCotvoriracun"/>
			<referrer name="@_yCbanka"/>
			<referrer name="@yH_OnDialogResponse@029"/>
			<param name="playerid">
			</param>
			<param name="color">
			</param>
			<param name="message">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:SendClientMessageEx" syntax="SendClientMessageEx(playerid, color, str[], ...)">
			<stacksize value="5"/>
			<referrer name="@_yCdajnovac"/>
			<dependency name="SendClientMessage"/>
			<dependency name="format"/>
			<param name="playerid">
			</param>
			<param name="color">
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:SendClientMessageToAll" syntax="SendClientMessageToAll(color, message[])">
			<attribute name="native"/>
			<referrer name="va_SendClientMessageToAll"/>
			<referrer name="@_yCstaffon"/>
			<referrer name="@_yCclearchat"/>
			<param name="color">
			</param>
			<param name="message">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:SendPlayerMessageToAll" syntax="SendPlayerMessageToAll(senderid, message[])">
			<attribute name="native"/>
			<referrer name="va_SendPlayerMessageToAll"/>
			<param name="senderid">
			</param>
			<param name="message">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:SendPlayerMessageToPlayer" syntax="SendPlayerMessageToPlayer(playerid, senderid, message[])">
			<attribute name="native"/>
			<referrer name="va_SendPlayerMessageToPlayer"/>
			<param name="playerid">
			</param>
			<param name="senderid">
			</param>
			<param name="message">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:SendRconCommand" syntax="SendRconCommand(command[])">
			<attribute name="native"/>
			<referrer name="SSCANF_OnGameModeInit"/>
			<param name="command">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:SetAmxFrame" syntax="SetAmxFrame(ptr)">
			<stacksize value="1"/>
			<param name="ptr">
			</param>
		</member>
		<member name="M:SetAmxHeapTop" syntax="SetAmxHeapTop(ptr)">
			<stacksize value="1"/>
			<param name="ptr">
			</param>
		</member>
		<member name="M:SetAmxNextInstructionPointer" syntax="SetAmxNextInstructionPointer(ptr)">
			<stacksize value="1"/>
			<param name="ptr">
			</param>
		</member>
		<member name="M:SetAmxStackBottom" syntax="SetAmxStackBottom(ptr)">
			<stacksize value="1"/>
			<param name="ptr">
			</param>
		</member>
		<member name="M:SetCameraBehindPlayer" syntax="SetCameraBehindPlayer(playerid)">
			<attribute name="native"/>
			<referrer name="OnDialogResponse"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:SetCurrentFramePreviousFrame" syntax="SetCurrentFramePreviousFrame(addr)">
			<stacksize value="5"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="SetFramePreviousFrame"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:SetCurrentFrameReturn" syntax="SetCurrentFrameReturn(addr)">
			<stacksize value="5"/>
			<referrer name="I@L"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="SetFrameReturn"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:SetCurrentParameterCount" syntax="SetCurrentParameterCount(count)">
			<stacksize value="5"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="SetFrameParameterCount"/>
			<param name="count">
			</param>
		</member>
		<member name="M:SetCurrentParameterSize" syntax="SetCurrentParameterSize(size)">
			<stacksize value="5"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="SetFrameParameterSize"/>
			<param name="size">
			</param>
		</member>
		<member name="M:SetDynamicObjectMaterial" syntax="SetDynamicObjectMaterial(objectid, materialindex, modelid, txdname[], texturename[], materialcolor)">
			<attribute name="native"/>
			<referrer name="KreirajObjekte"/>
			<param name="objectid">
			</param>
			<param name="materialindex">
			</param>
			<param name="modelid">
			</param>
			<param name="txdname">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="texturename">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="materialcolor">
			</param>
		</member>
		<member name="M:SetDynamicObjectMaterialText" syntax="SetDynamicObjectMaterialText(objectid, materialindex, text[], materialsize, fontface[], fontsize, bold, fontcolor, backcolor, textalignment)">
			<attribute name="native"/>
			<referrer name="KreirajObjekte"/>
			<param name="objectid">
			</param>
			<param name="materialindex">
			</param>
			<param name="text">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="materialsize">
			</param>
			<param name="fontface">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="fontsize">
			</param>
			<param name="bold">
			</param>
			<param name="fontcolor">
			</param>
			<param name="backcolor">
			</param>
			<param name="textalignment">
			</param>
		</member>
		<member name="M:SetFrameLocal" syntax="SetFrameLocal(frm_addr, param, value)">
			<stacksize value="1"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:SetFrameParameter" syntax="SetFrameParameter(frm_addr, param, value, idx)">
			<stacksize value="1"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
			<param name="value">
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:SetFrameParameterCount" syntax="SetFrameParameterCount(frm_addr, count)">
			<stacksize value="5"/>
			<referrer name="SetCurrentParameterCount"/>
			<dependency name="SetFrameParameterSize"/>
			<param name="frm_addr">
			</param>
			<param name="count">
			</param>
		</member>
		<member name="M:SetFrameParameterSize" syntax="SetFrameParameterSize(frm_addr, size)">
			<stacksize value="1"/>
			<referrer name="SetFrameParameterCount"/>
			<referrer name="SetCurrentParameterSize"/>
			<param name="frm_addr">
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:SetFramePreviousFrame" syntax="SetFramePreviousFrame(frm_addr, addr)">
			<stacksize value="1"/>
			<referrer name="SetCurrentFramePreviousFrame"/>
			<referrer name="Callback_Restore"/>
			<param name="frm_addr">
			</param>
			<param name="addr">
			</param>
		</member>
		<member name="M:SetFrameReturn" syntax="SetFrameReturn(frm_addr, addr)">
			<stacksize value="1"/>
			<referrer name="SetCurrentFrameReturn"/>
			<referrer name="Callback_Restore"/>
			<param name="frm_addr">
			</param>
			<param name="addr">
			</param>
		</member>
		<member name="M:SetFrameVariable" syntax="SetFrameVariable(frm_addr, param, value, idx)">
			<stacksize value="1"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
			<param name="value">
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:SetGameModeText" syntax="SetGameModeText(string[])">
			<attribute name="native"/>
			<referrer name="SSCANF_OnGameModeInit"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:SetNameTagDrawDistance" syntax="SetNameTagDrawDistance(distance)">
			<attribute name="native"/>
			<referrer name="SSCANF_OnGameModeInit"/>
			<param name="distance">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:SetObjectMaterial" syntax="SetObjectMaterial(objectid, materialindex, modelid, txdname[], texturename[], materialcolor)">
			<attribute name="native"/>
			<referrer name="KreirajObjekte"/>
			<param name="objectid">
			</param>
			<param name="materialindex">
			</param>
			<param name="modelid">
			</param>
			<param name="txdname">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="texturename">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="materialcolor">
			</param>
		</member>
		<member name="M:SetPlayerArmour" syntax="SetPlayerArmour(playerid, armour)">
			<attribute name="native"/>
			<referrer name="@_yCstaffon"/>
			<param name="playerid">
			</param>
			<param name="armour">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:SetPlayerChatBubble" syntax="SetPlayerChatBubble(playerid, text[], color, drawdistance, expiretime)">
			<attribute name="native"/>
			<referrer name="@_yCdo"/>
			<referrer name="@_yCme"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="color">
			</param>
			<param name="drawdistance">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="expiretime">
			</param>
		</member>
		<member name="M:SetPlayerColor" syntax="SetPlayerColor(playerid, color)">
			<attribute name="native"/>
			<referrer name="OnPlayerSpawn"/>
			<param name="playerid">
			</param>
			<param name="color">
			</param>
		</member>
		<member name="M:SetPlayerFacingAngle" syntax="SetPlayerFacingAngle(playerid, ang)">
			<attribute name="native"/>
			<referrer name="@yH_OnPlayerKeyStateChange@028"/>
			<param name="playerid">
			</param>
			<param name="ang">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:SetPlayerHealth" syntax="SetPlayerHealth(playerid, health)">
			<attribute name="native"/>
			<referrer name="AntiSpawnkill"/>
			<referrer name="@yH_OnPlayerSpawn@022"/>
			<referrer name="HPdaj"/>
			<referrer name="@_yCstaffon"/>
			<param name="playerid">
			</param>
			<param name="health">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:SetPlayerInterior" syntax="SetPlayerInterior(playerid, interiorid)">
			<attribute name="native"/>
			<referrer name="@yH_OnPlayerKeyStateChange@028"/>
			<param name="playerid">
			</param>
			<param name="interiorid">
			</param>
		</member>
		<member name="M:SetPlayerPos" syntax="SetPlayerPos(playerid, x, y, z)">
			<attribute name="native"/>
			<referrer name="@yH_OnPlayerSpawn@017"/>
			<referrer name="@_yCjetpack"/>
			<referrer name="@_yCxgoto"/>
			<referrer name="@yH_OnPlayerKeyStateChange@028"/>
			<param name="playerid">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:SetPlayerScore" syntax="SetPlayerScore(playerid, score)">
			<attribute name="native"/>
			<referrer name="OnPlayerSpawn"/>
			<param name="playerid">
			</param>
			<param name="score">
			</param>
		</member>
		<member name="M:SetPlayerSkin" syntax="SetPlayerSkin(playerid, skinid)">
			<attribute name="native"/>
			<referrer name="@_yCstaffon"/>
			<referrer name="OnPlayerSpawn"/>
			<param name="playerid">
			</param>
			<param name="skinid">
			</param>
		</member>
		<member name="M:SetPlayerSpecialAction" syntax="SetPlayerSpecialAction(playerid, actionid)">
			<attribute name="native"/>
			<referrer name="@_yCjetpack"/>
			<param name="playerid">
			</param>
			<param name="actionid">
			</param>
		</member>
		<member name="M:SetPlayerVirtualWorld" syntax="SetPlayerVirtualWorld(playerid, worldid)">
			<attribute name="native"/>
			<referrer name="@yH_OnPlayerKeyStateChange@028"/>
			<param name="playerid">
			</param>
			<param name="worldid">
			</param>
		</member>
		<member name="M:SetSpawnInfo" syntax="SetSpawnInfo(playerid, team, skin, x, y, z, rotation, weapon1, weapon1_ammo, weapon2, weapon2_ammo, weapon3, weapon3_ammo)">
			<attribute name="native"/>
			<referrer name="@yH_OnPlayerRequestClass@014"/>
			<param name="playerid">
			</param>
			<param name="team">
			</param>
			<param name="skin">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="rotation">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="weapon1">
			</param>
			<param name="weapon1_ammo">
			</param>
			<param name="weapon2">
			</param>
			<param name="weapon2_ammo">
			</param>
			<param name="weapon3">
			</param>
			<param name="weapon3_ammo">
			</param>
		</member>
		<member name="M:SetTimer" syntax="SetTimer(funcname[], interval, repeating)">
			<attribute name="native"/>
			<referrer name="AMX_OnScriptInit"/>
			<referrer name="_Timer_I"/>
			<referrer name="@yH_OnPlayerSpawn@022"/>
			<referrer name="EnterijerBrojac"/>
			<param name="funcname">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="interval">
			</param>
			<param name="repeating">
			</param>
		</member>
		<member name="M:SetTimerEx" syntax="SetTimerEx(funcname[], interval, repeating, format[], ...)">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="_@_y_cgen_@_0"/>
			<referrer name="@yH_OnPlayerDisconnect@004"/>
			<referrer name="@yH_OnScriptInit@006"/>
			<referrer name="_Timer_D"/>
			<referrer name="@yH_OnPlayerKeyStateChange@016"/>
			<referrer name="@yH_OnPlayerSpawn@024"/>
			<param name="funcname">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="interval">
			</param>
			<param name="repeating">
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:SetVehicleParamsEx" syntax="SetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, boot, objective)">
			<attribute name="native"/>
			<referrer name="@_yCstaffvehicle"/>
			<param name="vehicleid">
			</param>
			<param name="engine">
			</param>
			<param name="lights">
			</param>
			<param name="alarm">
			</param>
			<param name="doors">
			</param>
			<param name="bonnet">
			</param>
			<param name="boot">
			</param>
			<param name="objective">
			</param>
		</member>
		<member name="M:SetVehiclePos" syntax="SetVehiclePos(vehicleid, x, y, z)">
			<attribute name="native"/>
			<referrer name="@_yCxgoto"/>
			<param name="vehicleid">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:ShowPlayerDialog" syntax="ShowPlayerDialog(playerid, dialogid, style, caption[], info[], button1[], button2[])">
			<attribute name="native"/>
			<referrer name="@_yCmakestaff"/>
			<referrer name="@_yCbanka"/>
			<referrer name="@yH_OnDialogResponse@029"/>
			<referrer name="SSCANF_OnPlayerConnect"/>
			<referrer name="OnDialogResponse"/>
			<param name="playerid">
			</param>
			<param name="dialogid">
			</param>
			<param name="style">
			</param>
			<param name="caption">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="info">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="button1">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="button2">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:ShowTextDrawsForPlayer" syntax="ShowTextDrawsForPlayer(playerid)">
			<stacksize value="5"/>
			<referrer name="@yH_OnPlayerSpawn@019"/>
			<dependency name="TextDrawShowForPlayer"/>
			<dependency name="fortz_ptd"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:SkipWhitespace" syntax="SkipWhitespace(str[], pos)">
			<stacksize value="1"/>
			<dependency name="cellmin"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to skip over part of.
			</param>
			<param name="pos">
				The start of the whitespace.
			</param>
			    <returns>  The end of the whitespace.  </returns>  <remarks>  Doesn't skip over NULL terminators.  </remarks> 
		</member>
		<member name="M:SpawnPlayer" syntax="SpawnPlayer(playerid)">
			<attribute name="native"/>
			<referrer name="@yH_OnPlayerRequestClass@014"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:StoredF_IsHooked" syntax="StoredF_IsHooked(addr)">
			<stacksize value="4"/>
			<referrer name="StoredF_WritePublicCode"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_Read"/>
			<dependency name="OP_JUMP"/>
			<dependency name="RelocateOpcode"/>
			<param name="addr">
				Function start address.
			</param>
			  <returns>  Is the function at this address already hooked by us?  </returns> 
		</member>
		<member name="M:StoredF_OnPubGenError" syntax="StoredF_OnPubGenError(ctx[], error)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<dependency name="Debug_Print0"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
				Current code generation context.
			</param>
			<param name="error">
				<paraminfo>AsmError </paraminfo>
				The error given.
			</param>
			    <remarks>  This is a fatal error as there isn't really anything we can do about it.  </remarks> 
		</member>
		<member name="M:StoredF_WritePublicCode" syntax="StoredF_WritePublicCode(fptr, spec[])">
			<stacksize value="29"/>
			<referrer name="GetLocalFunction"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_REAL_DATA"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmEmitAddC"/>
			<dependency name="AsmEmitJump"/>
			<dependency name="AsmEmitLrefSAlt"/>
			<dependency name="AsmEmitPopAlt"/>
			<dependency name="AsmEmitPopPri"/>
			<dependency name="AsmEmitProc"/>
			<dependency name="AsmEmitStorSAlt"/>
			<dependency name="AsmEmitStorSPri"/>
			<dependency name="AsmEmitSwapAlt"/>
			<dependency name="AsmEmitSwapPri"/>
			<dependency name="AsmGetCodeSize"/>
			<dependency name="AsmSetErrorHandler"/>
			<dependency name="CGen_AddCodeSpace"/>
			<dependency name="CGen_GetCodeSpace"/>
			<dependency name="CGen_UseCodeSpace"/>
			<dependency name="GetPublicAddressFromName"/>
			<dependency name="StoredF_IsHooked"/>
			<dependency name="strlen"/>
			<param name="fptr">
				Function start address.
			</param>
			<param name="spec">
				<paraminfo> [] </paraminfo>
				Function parameter types.
			</param>
			    <returns>  the new function pointer.  </returns>  <remarks>  Writes a stub for calling a public function with an alternate method.  Because "CallStoredFunction" (the call entry point) takes all its parameters  by reference and some of the actual function's parameters won't be, we have  to generate the code to convert those that aren't to values only.  Also,  because "CallStoredFunction" takes an extra parameter that's the address of  the function to call, we have to wipe that from the stack and update the  resulting frame header.  </remarks> 
		</member>
		<member name="M:StrToLower" syntax="StrToLower(str[], len)">
			<stacksize value="5"/>
			<dependency name="tolower"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to convert.
			</param>
			<param name="len">
				How much of the string to convert.
			</param>
			   
		</member>
		<member name="M:StrToUpper" syntax="StrToUpper(str[], len)">
			<stacksize value="5"/>
			<dependency name="toupper"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to convert.
			</param>
			<param name="len">
				How much of the string to convert.
			</param>
			   
		</member>
		<member name="M:Streamer_OnItemStreamIn" syntax="Streamer_OnItemStreamIn(type, id, forplayerid)">
			<stacksize value="1"/>
			<param name="type">
			</param>
			<param name="id">
				<paraminfo> {Text3D,_} </paraminfo>
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:Streamer_OnItemStreamOut" syntax="Streamer_OnItemStreamOut(type, id, forplayerid)">
			<stacksize value="1"/>
			<param name="type">
			</param>
			<param name="id">
				<paraminfo> {Text3D,_} </paraminfo>
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:Streamer_OnPluginError" syntax="Streamer_OnPluginError(error[])">
			<stacksize value="1"/>
			<param name="error">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Strip" syntax="Strip(str[])">
			<stacksize value="9"/>
			<dependency name="memcpy"/>
			<dependency name="strlen"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to remove whitespace from the start and end of.
			</param>
			 
		</member>
		<member name="M:StripL" syntax="StripL(str[])">
			<stacksize value="9"/>
			<dependency name="memcpy"/>
			<dependency name="strlen"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to remove whitespace from the start of.
			</param>
			 
		</member>
		<member name="M:StripNL" syntax="StripNL(str[])">
			<stacksize value="4"/>
			<dependency name="strlen"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to remove whitespace from the end of.
			</param>
			  <remarks>  Updated from old versions, should be more efficient  </remarks> 
		</member>
		<member name="M:Sum" syntax="Sum(arr[], num)">
			<stacksize value="2"/>
			<referrer name="Mean"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array whose values need summing.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <returns>  All the values in the array added together.  </returns> 
		</member>
		<member name="M:SysreqC" syntax="SysreqC(index, auto_pop)">
			<stacksize value="9"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="index">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:SysreqCN" syntax="SysreqCN(index, args_to_push, auto_pop)">
			<stacksize value="10"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="index">
			</param>
			<param name="args_to_push">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:SysreqD" syntax="SysreqD(address, auto_pop)">
			<stacksize value="9"/>
			<referrer name="RunShellcode"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="address">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:SysreqDN" syntax="SysreqDN(address, args_to_push, auto_pop)">
			<stacksize value="10"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="address">
			</param>
			<param name="args_to_push">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:TextDrawAlignment" syntax="TextDrawAlignment(text, alignment)">
			<attribute name="native"/>
			<referrer name="CreateGTextDraws"/>
			<param name="text">
				<paraminfo>Text </paraminfo>
			</param>
			<param name="alignment">
			</param>
		</member>
		<member name="M:TextDrawBackgroundColor" syntax="TextDrawBackgroundColor(text, color)">
			<attribute name="native"/>
			<referrer name="CreateGTextDraws"/>
			<param name="text">
				<paraminfo>Text </paraminfo>
			</param>
			<param name="color">
			</param>
		</member>
		<member name="M:TextDrawColor" syntax="TextDrawColor(text, color)">
			<attribute name="native"/>
			<referrer name="CreateGTextDraws"/>
			<param name="text">
				<paraminfo>Text </paraminfo>
			</param>
			<param name="color">
			</param>
		</member>
		<member name="M:TextDrawCreate" syntax="TextDrawCreate(x, y, text[])">
			<tagname value="Text"/>
			<attribute name="native"/>
			<referrer name="va_TextDrawCreate"/>
			<referrer name="CreateGTextDraws"/>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="text">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:TextDrawFont" syntax="TextDrawFont(text, font)">
			<attribute name="native"/>
			<referrer name="CreateGTextDraws"/>
			<param name="text">
				<paraminfo>Text </paraminfo>
			</param>
			<param name="font">
			</param>
		</member>
		<member name="M:TextDrawLetterSize" syntax="TextDrawLetterSize(text, x, y)">
			<attribute name="native"/>
			<referrer name="CreateGTextDraws"/>
			<param name="text">
				<paraminfo>Text </paraminfo>
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:TextDrawSetProportional" syntax="TextDrawSetProportional(text, set)">
			<attribute name="native"/>
			<referrer name="CreateGTextDraws"/>
			<param name="text">
				<paraminfo>Text </paraminfo>
			</param>
			<param name="set">
			</param>
		</member>
		<member name="M:TextDrawSetShadow" syntax="TextDrawSetShadow(text, size)">
			<attribute name="native"/>
			<referrer name="CreateGTextDraws"/>
			<param name="text">
				<paraminfo>Text </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:TextDrawSetString" syntax="TextDrawSetString(text, string[])">
			<attribute name="native"/>
			<referrer name="VremeDatum"/>
			<referrer name="@yH_OnPlayerConnect@019"/>
			<param name="text">
				<paraminfo>Text </paraminfo>
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:TextDrawShowForPlayer" syntax="TextDrawShowForPlayer(playerid, text)">
			<attribute name="native"/>
			<referrer name="ShowTextDrawsForPlayer"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo>Text </paraminfo>
			</param>
		</member>
		<member name="M:Timer_GetSingleSlot" syntax="Timer_GetSingleSlot(len)">
			<tagname value="Alloc"/>
			<stacksize value="6"/>
			<referrer name="_Timer_S"/>
			<referrer name="_Timer_A"/>
			<referrer name="_Timer_C"/>
			<dependency name="Malloc_Allocate"/>
			<dependency name="YSI_gMallocMemory"/>
			<dependency name="YSI_g_sFirstSlot"/>
			<dependency name="YSI_g_sLastSlot"/>
			<param name="len">
			</param>
		</member>
		<member name="M:ToHexStr" syntax="ToHexStr(x)">
			<stacksize value="15"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DisasmWriteDataRowHex"/>
			<referrer name="DisasmWriteData"/>
			<dependency name="ToHexStr"/>
			<param name="x">
			</param>
		</member>
		<member name="M:ToPrintableAscii" syntax="ToPrintableAscii(c)">
			<stacksize value="4"/>
			<referrer name="DisasmWriteDataRowChar"/>
			<dependency name="IsPrintableAscii"/>
			<param name="c">
			</param>
		</member>
		<member name="M:TogglePlayerControllable" syntax="TogglePlayerControllable(playerid, toggle)">
			<attribute name="native"/>
			<referrer name="freezethaw"/>
			<referrer name="@yH_OnPlayerSpawn@024"/>
			<referrer name="EnterijerBrojac"/>
			<referrer name="EnterijerBR2"/>
			<param name="playerid">
			</param>
			<param name="toggle">
			</param>
		</member>
		<member name="M:TogglePlayerSpectating" syntax="TogglePlayerSpectating(playerid, toggle)">
			<attribute name="native"/>
			<referrer name="SSCANF_OnPlayerConnect"/>
			<param name="playerid">
			</param>
			<param name="toggle">
			</param>
		</member>
		<member name="M:Trim" syntax="Trim(str[], &amp;start, &amp;end)">
			<stacksize value="1"/>
			<dependency name="cellmin"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to trim.
			</param>
			<param name="start">
				<paraminfo> &amp; </paraminfo>
				Start of the substring.
			</param>
			<param name="end">
				<paraminfo> &amp; </paraminfo>
				End of the substring.
			</param>
			      <remarks>  Modifies "start" and "end" to be tight on text in "str".  </remarks> 
		</member>
		<member name="M:U@" syntax="U@(id, name[], value, string[])">
			<attribute name="native"/>
			<referrer name="Master_Reassert"/>
			<referrer name="@yC_do"/>
			<referrer name="@yC_b"/>
			<referrer name="@yC_me"/>
			<referrer name="@yC_makestaff"/>
			<referrer name="@yC_staffon"/>
			<referrer name="@yC_clearchat"/>
			<referrer name="@yC_jetpack"/>
			<referrer name="@yC_staffvehicle"/>
			<referrer name="@yC_xgoto"/>
			<referrer name="@yC_dajnovac"/>
			<referrer name="@yC_otvoriracun"/>
			<referrer name="@yC_banka"/>
			<param name="id">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="value">
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:UCMP" syntax="UCMP(value, upper)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="value">
				The unsigned number to compare.
			</param>
			<param name="upper">
				The upper limit.
			</param>
			    <returns>  An unsigned comparison between the two values.  </returns> 
		</member>
		<member name="M:Ucitaj_Pickups" syntax="Ucitaj_Pickups()">
			<stacksize value="13"/>
			<referrer name="SSCANF_OnGameModeInit"/>
			<dependency name="operator-(Float:,Float:)"/>
			<dependency name="CreateDynamicPickup"/>
			<dependency name="CreatePickup"/>
		</member>
		<member name="M:Ucitaj_TextLabel" syntax="Ucitaj_TextLabel()">
			<stacksize value="17"/>
			<referrer name="SSCANF_OnGameModeInit"/>
			<dependency name="Create3DTextLabel"/>
			<dependency name="CreateDynamic3DTextLabel"/>
		</member>
		<member name="M:UnrelocateOpcode" syntax="UnrelocateOpcode(opcode)">
			<tagname value="Opcode"/>
			<stacksize value="3"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="CodeScanAddSwitchTarget"/>
			<dependency name="InitOpcodeTable"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="opcode_table"/>
			<dependency name="opcode_table_is_ready"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:UserPath" syntax="UserPath(playerid)">
			<stacksize value="158"/>
			<referrer name="SacuvajKorisnike"/>
			<referrer name="SSCANF_OnPlayerConnect"/>
			<referrer name="OnDialogResponse"/>
			<dependency name="GetPlayerName"/>
			<dependency name="UserPath"/>
			<dependency name="format"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Utils_PreSort" syntax="Utils_PreSort(arr[], num)">
			<stacksize value="4"/>
			<referrer name="Mode"/>
			<referrer name="Median"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array to sort.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <remarks>  Sorts the array in place.  Uses bubble sort because it is easy and fast for  pre-sorted arrays (which the callers are likely to be).  </remarks> 
		</member>
		<member name="M:V@" syntax="V@(id, name[], value, string[])">
			<attribute name="native"/>
			<referrer name="Command_GetID"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="Command_GetPlayerDisabled"/>
			<referrer name="Command_GetPlayer"/>
			<referrer name="Command_GetPlayerNamed"/>
			<referrer name="Command_Find"/>
			<referrer name="Command_GetDeniedReturn"/>
			<referrer name="Command_GetIllegalReturn"/>
			<referrer name="Command_GetUnknownReturn"/>
			<referrer name="Command_GetDisconnectReturn"/>
			<referrer name="Command_AddAltNamed"/>
			<referrer name="Command_IsValid"/>
			<referrer name="Command_GetCurrent"/>
			<referrer name="Command_GetPlayerCommandCount"/>
			<referrer name="Iter_Func@Command"/>
			<referrer name="Iter_Func@PlayerCommand"/>
			<referrer name="Command_Add"/>
			<param name="id">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="value">
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:VALID_PLAYERID" syntax="VALID_PLAYERID(playerid)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="playerid">
				The player to check.
			</param>
			  <returns>  Is this a valid playerid (NOT, is the player connected).  </returns> 
		</member>
		<member name="M:VremeDatum" syntax="VremeDatum()">
			<attribute name="public"/>
			<stacksize value="79"/>
			<dependency name="TextDrawSetString"/>
			<dependency name="format"/>
			<dependency name="fortz_ptd"/>
			<dependency name="getdate"/>
			<dependency name="gettime"/>
		</member>
		<member name="M:W@" syntax="W@(function[], format[], ...)">
			<attribute name="native"/>
			<referrer name="Malloc_DoPlayerConnect"/>
			<referrer name="Iter_ActorDo_"/>
			<referrer name="Iter_VehicleDo_"/>
			<referrer name="Command_GetID"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="Command_SetPlayerDisabled"/>
			<referrer name="Command_GetPlayerDisabled"/>
			<referrer name="Command_GetPlayer"/>
			<referrer name="Command_GetPlayerNamed"/>
			<referrer name="Command_SetPlayer"/>
			<referrer name="Command_SetPlayerNamed"/>
			<referrer name="Command_Find"/>
			<referrer name="Command_TouchNamed"/>
			<referrer name="Command_Touch"/>
			<referrer name="Command_SetDeniedReturn"/>
			<referrer name="Command_GetDeniedReturn"/>
			<referrer name="Command_SetIllegalReturn"/>
			<referrer name="Command_GetIllegalReturn"/>
			<referrer name="Command_SetUnknownReturn"/>
			<referrer name="Command_GetUnknownReturn"/>
			<referrer name="Command_SetDisconnectReturn"/>
			<referrer name="Command_GetDisconnectReturn"/>
			<referrer name="Command_AddAltNamed"/>
			<referrer name="Command_Remove"/>
			<referrer name="Command_RemoveNamed"/>
			<referrer name="Command_IsValid"/>
			<referrer name="Command_GetCurrent"/>
			<referrer name="Command_GetPlayerCommandCount"/>
			<referrer name="Command_GetName"/>
			<referrer name="Command_GetDisplay"/>
			<referrer name="Command_GetDisplayNamed"/>
			<referrer name="Command_GetNext"/>
			<referrer name="Iter_Func@Command"/>
			<referrer name="Iter_Func@PlayerCommand"/>
			<referrer name="_Command_Rebuild"/>
			<referrer name="Command_IncOPCR"/>
			<referrer name="Command_DecOPCR"/>
			<referrer name="Command_IncOPCP"/>
			<referrer name="Command_DecOPCP"/>
			<referrer name="Command_Add"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:WriteAmxCell" syntax="WriteAmxCell(offset, value)">
			<stacksize value="6"/>
			<dependency name="GetAmxAddress"/>
			<dependency name="WritePhysMemoryCell"/>
			<param name="offset">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:WriteAmxMemory" syntax="WriteAmxMemory(address, value)">
			<stacksize value="1"/>
			<referrer name="WriteAmxMemoryArray"/>
			<referrer name="HookPublic"/>
			<referrer name="HookNative"/>
			<referrer name="AsmEmitCell"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="AsmEmitPadding"/>
			<param name="address">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:WriteAmxMemoryArray" syntax="WriteAmxMemoryArray(address, values[], size)">
			<stacksize value="6"/>
			<dependency name="WriteAmxMemory"/>
			<param name="address">
			</param>
			<param name="values">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:WritePhysMemory" syntax="WritePhysMemory(address, src[], num)">
			<stacksize value="5"/>
			<dependency name="AbsToRel"/>
			<param name="address">
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:WritePhysMemoryCell" syntax="WritePhysMemoryCell(address, what)">
			<stacksize value="5"/>
			<referrer name="WriteAmxCell"/>
			<dependency name="AbsToRel"/>
			<param name="address">
			</param>
			<param name="what">
			</param>
		</member>
		<member name="M:X@" syntax="X@(n)">
			<stacksize value="6"/>
			<referrer name="Command_GetID@"/>
			<referrer name="Command_AddAlt@"/>
			<referrer name="Command_ReProcess@"/>
			<referrer name="Command_GetPlayerDisabled@"/>
			<referrer name="Command_GetPlayer@"/>
			<referrer name="Command_GetPlayerNamed@"/>
			<referrer name="Command_Find@"/>
			<referrer name="Command_GetDeniedReturn@"/>
			<referrer name="Command_GetIllegalReturn@"/>
			<referrer name="Command_GetUnknownReturn@"/>
			<referrer name="Command_GetDisconnectReturn@"/>
			<referrer name="Command_AddAltNamed@"/>
			<referrer name="Command_IsValid@"/>
			<referrer name="Command_GetCurrent@"/>
			<referrer name="Command_GetPlayerCommandCount@"/>
			<referrer name="Iter_Func@Command@"/>
			<referrer name="Iter_Func@PlayerCommand@"/>
			<referrer name="Command_Add@"/>
			<dependency name="setproperty"/>
			<param name="n">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:Y@" syntax="Y@()">
			<stacksize value="6"/>
			<referrer name="Command_Add"/>
			<dependency name="_@"/>
			<dependency name="setproperty"/>
		</member>
		<member name="M:YHash" syntax="YHash(str[], sensitive, type, len, pack)">
			<stacksize value="5"/>
			<referrer name="HashMap_Add"/>
			<referrer name="HashMap_Get"/>
			<referrer name="HashMap_RemoveKey"/>
			<dependency name="hash_bernstein"/>
			<dependency name="hash_fnv1"/>
			<dependency name="hash_fnv1a"/>
			<dependency name="min"/>
			<dependency name="strlen"/>
			<dependency name="toupper"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="sensitive">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="type">
				<paraminfo>e_HASH_TYPE </paraminfo>
			</param>
			<param name="len">
			</param>
			<param name="pack">
			</param>
		</member>
		<member name="M:YSIM_OnMasterSystemInit" syntax="YSIM_OnMasterSystemInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="Master_GetCurrentMaster"/>
		</member>
		<member name="M:YSI_g_sCommandFlags@Dist" syntax="YSI_g_sCommandFlags@Dist(a[], s)">
			<attribute name="public"/>
			<stacksize value="6"/>
			<automaton name="@_"/>
			<dependency name="Distribute_To"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<param name="a">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="s">
			</param>
		</member>
		<member name="M:YSI_g_sCommandFlags_Dist" syntax="YSI_g_sCommandFlags_Dist()">
			<tagname value="DIST_STRIP"/>
			<stacksize value="5"/>
			<referrer name="HANDOFF_SOURCE@_"/>
			<dependency name="Distribute_Do"/>
			<dependency name="YSI_g_sCommandFlags"/>
		</member>
		<member name="M:YSI_g_sCommands@Dist" syntax="YSI_g_sCommands@Dist(i, m, a[], s)">
			<attribute name="public"/>
			<stacksize value="8"/>
			<automaton name="@_"/>
			<dependency name="Distribute_To"/>
			<dependency name="E_COMMAND"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sMasterData"/>
			<param name="i">
			</param>
			<param name="m">
			</param>
			<param name="a">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="s">
			</param>
		</member>
		<member name="M:YSI_g_sCommands_Dist" syntax="YSI_g_sCommands_Dist()">
			<tagname value="DIST_STRIP"/>
			<stacksize value="10"/>
			<referrer name="HANDOFF_SOURCE@_"/>
			<dependency name="Distribute_So"/>
			<dependency name="E_COMMAND"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sMasterData"/>
		</member>
		<member name="M:YSI_g_sDisabledPlayers@Dist" syntax="YSI_g_sDisabledPlayers@Dist(a[], s)">
			<attribute name="public"/>
			<stacksize value="8"/>
			<automaton name="@_"/>
			<dependency name="Distribute_To"/>
			<dependency name="YSI_g_sDisabledPlayers"/>
			<param name="a">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="s">
			</param>
		</member>
		<member name="M:YSI_g_sDisabledPlayers_Dist" syntax="YSI_g_sDisabledPlayers_Dist()">
			<tagname value="DIST_ST2"/>
			<stacksize value="7"/>
			<referrer name="HANDOFF_SOURCE@_"/>
			<dependency name="Distribute_Do"/>
			<dependency name="YSI_g_sDisabledPlayers"/>
		</member>
		<member name="M:YSI_g_sErrorMessages@Dist" syntax="YSI_g_sErrorMessages@Dist(a[], s)">
			<attribute name="public"/>
			<stacksize value="10"/>
			<automaton name="@_"/>
			<dependency name="Distribute_To"/>
			<dependency name="YSI_g_sErrorMessages"/>
			<dependency name="e_COMMAND_ERRORS"/>
			<param name="a">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="s">
			</param>
		</member>
		<member name="M:YSI_g_sErrorMessages_Dist" syntax="YSI_g_sErrorMessages_Dist()">
			<tagname value="DIST_STRIP"/>
			<stacksize value="9"/>
			<referrer name="HANDOFF_SOURCE@_"/>
			<dependency name="Distribute_Do"/>
			<dependency name="YSI_g_sErrorMessages"/>
			<dependency name="e_COMMAND_ERRORS"/>
		</member>
		<member name="M:YVA2_CodeGenDeepCleanup" syntax="YVA2_CodeGenDeepCleanup(ctx[], depth, returningString)">
			<stacksize value="5"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="AsmEmitPopPri"/>
			<dependency name="AsmEmitStack"/>
			<dependency name="cellbits"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="depth">
			</param>
			<param name="returningString">
			</param>
		</member>
		<member name="M:YVA2_CodeGenMainCleanup" syntax="YVA2_CodeGenMainCleanup(ctx[])">
			<stacksize value="5"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="AsmEmitAdd"/>
			<dependency name="AsmEmitLctrl"/>
			<dependency name="AsmEmitLoadPri"/>
			<dependency name="AsmEmitPopAlt"/>
			<dependency name="AsmEmitSctrl"/>
			<dependency name="AsmEmitStorPri"/>
			<dependency name="ref"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:YVA2_CodeGenPushSite" syntax="YVA2_CodeGenPushSite(ctx[], pushedBytes, skippedBytes, offset)">
			<stacksize value="7"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="AsmEmitAddrPri"/>
			<dependency name="AsmEmitCallAbs"/>
			<dependency name="AsmEmitHeap"/>
			<dependency name="AsmEmitPushC"/>
			<dependency name="AsmEmitPushPri"/>
			<dependency name="O@A_"/>
			<dependency name="O@V_"/>
			<dependency name="YVA2_DoPush"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="pushedBytes">
			</param>
			<param name="skippedBytes">
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:YVA2_CodeGenPushVariable" syntax="YVA2_CodeGenPushVariable(ctx[], stack)">
			<stacksize value="5"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="AsmEmitPushS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="stack">
			</param>
		</member>
		<member name="M:YVA2_CodeGenShiftCode" syntax="YVA2_CodeGenShiftCode(dest, src, end)">
			<stacksize value="4"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="OP_NOP"/>
			<dependency name="RelocateOpcode"/>
			<param name="dest">
			</param>
			<param name="src">
			</param>
			<param name="end">
			</param>
		</member>
		<member name="M:YVA2_DoPush" syntax="YVA2_DoPush(skippedBytes, pushedBytes, pushRequirements)">
			<stacksize value="1"/>
			<referrer name="YVA2_DummyPush"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<dependency name="memcpy"/>
			<param name="skippedBytes">
			</param>
			<param name="pushedBytes">
			</param>
			<param name="pushRequirements">
			</param>
		</member>
		<member name="M:YVA2_DummyPush" syntax="YVA2_DummyPush(skippedBytes, pushedBytes, pushRequirements, dummy0, dummy1, dummy2, dummy3, dummy4, dummy5)">
			<stacksize value="6"/>
			<referrer name="YVA2_Initalise"/>
			<referrer name="va_CreatePlayerTextDraw"/>
			<referrer name="va_TextDrawCreate"/>
			<referrer name="va_SendClientMessage"/>
			<referrer name="va_SendClientMessageToAll"/>
			<referrer name="va_SendPlayerMessageToPlayer"/>
			<referrer name="va_SendPlayerMessageToAll"/>
			<referrer name="va_GameTextForPlayer"/>
			<referrer name="va_GameTextForAll"/>
			<referrer name="va_print"/>
			<referrer name="va_fprintf"/>
			<referrer name="SCMF"/>
			<dependency name="Debug_Print0"/>
			<dependency name="TRUE"/>
			<dependency name="YSI_g_sInitialised"/>
			<dependency name="YVA2_DoPush"/>
			<dependency name="YVA2_Initalise"/>
			<param name="skippedBytes">
			</param>
			<param name="pushedBytes">
			</param>
			<param name="pushRequirements">
			</param>
			<param name="dummy0">
			</param>
			<param name="dummy1">
			</param>
			<param name="dummy2">
			</param>
			<param name="dummy3">
			</param>
			<param name="dummy4">
			</param>
			<param name="dummy5">
			</param>
		</member>
		<member name="M:YVA2_FoundCall" syntax="YVA2_FoundCall(m[])">
			<stacksize value="34"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmEmitHeap"/>
			<dependency name="AsmEmitPushAlt"/>
			<dependency name="AsmEmitStack"/>
			<dependency name="CodeScanGetMatchAddressData"/>
			<dependency name="CodeScanGetMatchDisasm"/>
			<dependency name="CodeScanGetMatchHole"/>
			<dependency name="CodeScanGetMatchLength"/>
			<dependency name="CodeScanGetMatchStack"/>
			<dependency name="Debug_Print0"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmNextInsn"/>
			<dependency name="OP_HEAP"/>
			<dependency name="OP_POP_PRI"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="YSI_g_sContexts"/>
			<dependency name="YSI_g_sContexts"/>
			<dependency name="YSI_g_sLength"/>
			<dependency name="YSI_g_sMaxNesting"/>
			<dependency name="YSI_g_sPassthroughNestings"/>
			<dependency name="YSI_g_sSkips"/>
			<dependency name="YSI_g_sStacks"/>
			<dependency name="YVA2_CodeGenDeepCleanup"/>
			<dependency name="YVA2_CodeGenMainCleanup"/>
			<dependency name="YVA2_CodeGenPushSite"/>
			<dependency name="YVA2_CodeGenPushVariable"/>
			<dependency name="YVA2_CodeGenShiftCode"/>
			<dependency name="cellbits"/>
			<dependency name="cellmax"/>
			<dependency name="cellmin"/>
			<param name="m">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:YVA2_FoundPush" syntax="YVA2_FoundPush(m[])">
			<stacksize value="29"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="CodeScanGetMatchAddress"/>
			<dependency name="CodeScanGetMatchAsm"/>
			<dependency name="CodeScanGetMatchDisasm"/>
			<dependency name="CodeScanGetMatchHole"/>
			<dependency name="CodeScanGetMatchLength"/>
			<dependency name="CodeScanGetMatchStack"/>
			<dependency name="Debug_Print0"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmNextInsn"/>
			<dependency name="OP_HEAP"/>
			<dependency name="OP_PUSH_ALT"/>
			<dependency name="YSI_g_sContexts"/>
			<dependency name="YSI_g_sContexts"/>
			<dependency name="YSI_g_sInitialised"/>
			<dependency name="YSI_g_sLength"/>
			<dependency name="YSI_g_sMaxNesting"/>
			<dependency name="YSI_g_sPassthroughNestings"/>
			<dependency name="YSI_g_sSkips"/>
			<dependency name="YSI_g_sStacks"/>
			<dependency name="cellbits"/>
			<dependency name="cellmin"/>
			<dependency name="max"/>
			<param name="m">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:YVA2_Initalise" syntax="YVA2_Initalise()">
			<stacksize value="1138"/>
			<referrer name="YVA2_DummyPush"/>
			<dependency name="CodeScanAddMatcher"/>
			<dependency name="CodeScanInit"/>
			<dependency name="CodeScanMatcher"/>
			<dependency name="CodeScanMatcherInit_"/>
			<dependency name="CodeScanMatcherPattern_"/>
			<dependency name="CodeScanRun"/>
			<dependency name="CodeScanner"/>
			<dependency name="O@A_"/>
			<dependency name="O@V_"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CONST_PRI"/>
			<dependency name="OP_HEAP"/>
			<dependency name="OP_MOVE_PRI"/>
			<dependency name="OP_PUSH_ALT"/>
			<dependency name="OP_PUSH_C"/>
			<dependency name="OP_PUSH_PRI"/>
			<dependency name="OP_STACK"/>
			<dependency name="OP_STOR_I"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="OP_ZERO_PRI"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="YVA2_FoundCall"/>
			<dependency name="YVA2_FoundPush"/>
			<dependency name="gCodeScanCallback_match"/>
		</member>
		<member name="M:YVers_Callback" syntax="YVers_Callback(index, code, data[])">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="false"/>
			<dependency name="print"/>
			<dependency name="printf"/>
			<dependency name="strcmp"/>
			<dependency name="strfind"/>
			<param name="index">
			</param>
			<param name="code">
			</param>
			<param name="data">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:YVers_OnScriptInit" syntax="YVers_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="Debug_Print0"/>
			<dependency name="Debug_SetState"/>
			<dependency name="YSI_FILTERSCRIPT"/>
			<remarks>  Does some strange mangling of <c>YSI_FILTERSCRIPT</c> because at one point I  found a compiler bug where the first automata in the script could conflict  with the first variable in the script.  I don't know what triggered it, and  it has never shown up since I messed about with this file to try mangle some  things.  Never the less, if it ever happens again this code might detect it.  Actually, that's less likely now, since that variable is now very unlikely  to be the first in the script ever.  </remarks> 
		</member>
		<member name="M:Z@" syntax="Z@(v)">
			<stacksize value="7"/>
			<referrer name="Command_Add"/>
			<dependency name="getproperty"/>
			<dependency name="setproperty"/>
			<param name="v">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:ZonaIgraca" syntax="ZonaIgraca(playerid, zonename[])">
			<stacksize value="37"/>
			<referrer name="GlobalTimer"/>
			<dependency name="GetPlayer2DZone"/>
			<dependency name="strfind"/>
			<dependency name="true"/>
			<param name="playerid">
			</param>
			<param name="zonename">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:_@_y_cgen_@_0" syntax="_@_y_cgen_@_0()">
			<attribute name="public"/>
			<stacksize value="60"/>
			<dependency name="SetTimerEx"/>
		</member>
		<member name="M:_@_y_cgen_@_1" syntax="_@_y_cgen_@_1()">
			<attribute name="public"/>
			<stacksize value="1"/>
		</member>
		<member name="M:_@_y_distribute_@_" syntax="_@_y_distribute_@_()">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="CallRemoteFunction"/>
			<dependency name="memcpy"/>
		</member>
		<member name="M:_@_y_funcinc_@_" syntax="_@_y_funcinc_@_()">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="CallLocalFunction"/>
			<dependency name="CallRemoteFunction"/>
			<dependency name="SetTimerEx"/>
			<dependency name="false"/>
			<dependency name="format"/>
			<dependency name="getproperty"/>
			<dependency name="heapspace"/>
			<dependency name="memcpy"/>
			<dependency name="memset"/>
			<dependency name="printf"/>
			<dependency name="setproperty"/>
			<dependency name="strcat"/>
			<dependency name="strcmp"/>
			<dependency name="strfind"/>
			<dependency name="strlen"/>
			<dependency name="strunpack"/>
		</member>
		<member name="M:_@_y_inline_@_" syntax="_@_y_inline_@_()">
			<attribute name="public"/>
			<stacksize value="6"/>
			<dependency name="CallRemoteFunction"/>
			<dependency name="NULL"/>
			<dependency name="strcat"/>
			<dependency name="strcmp"/>
			<dependency name="strfind"/>
			<dependency name="strpack"/>
			<remarks>  Calls functions we call via "SYSREQ.C".  </remarks> 
		</member>
		<member name="M:_Command_GetDisplay" syntax="_Command_GetDisplay(funcid, playerid)">
			<stacksize value="8"/>
			<referrer name="Command_GetDisplay"/>
			<referrer name="Command_GetDisplayNamed"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="E_COMMAND_POINTER"/>
			<dependency name="E_COMMAND_USERS"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sHighestID"/>
			<dependency name="YSI_g_sReturnBuffer"/>
			<dependency name="cellbits"/>
			<dependency name="cellmin"/>
			<dependency name="strunpack"/>
			<param name="funcid">
			</param>
			<param name="playerid">
			</param>
			<param name="f">Command to get the real name of.</param>  <param name="p">Player to get the name for.</param>  <returns>  The name of a command for a single player.  </returns> 
		</member>
		<member name="M:_Command_GetPrefix" syntax="_Command_GetPrefix(c)">
			<stacksize value="1"/>
			<param name="c">
				Command to get.
			</param>
			  <returns>  The prefix for this command.  </returns> 
		</member>
		<member name="M:_Command_GetReal" syntax="_Command_GetReal(&amp;ptr, &amp;idx, name[])">
			<stacksize value="1"/>
			<param name="ptr">
				<paraminfo> &amp; </paraminfo>
				AMX function pointer.
			</param>
			<param name="idx">
				<paraminfo> &amp; </paraminfo>
				Index of the parent command data.
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
				Destination for the parent function name.
			</param>
			      <remarks>  Finds the original version of an alt command.  Updated to not contain long  chains (along with "Command_AddAlt").  </remarks> 
		</member>
		<member name="M:_Command_IsActive" syntax="_Command_IsActive(command)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="command">
				Command to get for.
			</param>
			  <returns>  Is this command ID active?  </returns>  <remarks>  Doesn't do any bounds checks - use "_Command_IsValid" for that.  </remarks> 
		</member>
		<member name="M:_Command_IsAlt" syntax="_Command_IsAlt(idx)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="idx">
				Command to test.
			</param>
			  <remarks>  Tests if the given slot is an alternate command.  </remarks> 
		</member>
		<member name="M:_Command_IsEmptySlot" syntax="_Command_IsEmptySlot(idx)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="idx">
				Command to test.
			</param>
			  <remarks>  Tests if the given slot is empty.  </remarks> 
		</member>
		<member name="M:_Command_Rebuild" syntax="_Command_Rebuild()">
			<stacksize value="16"/>
			<automaton name="@_"/>
			<referrer name="HANDOFF_SOURCE@_"/>
			<referrer name="_Command_Rebuild@"/>
			<dependency name="E_COMMAND_HASH_MAP"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="HashMap_Add"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandMap"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sHighestID"/>
			<dependency name="_HashMap_Init"/>
			<dependency name="strpack"/>
			<remarks>  Rebuilds the hashmap of command pointers after a master script hands off.  </remarks> 
		</member>
		<member name="M:_Command_Rebuild@" syntax="_Command_Rebuild@()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="@_"/>
			<dependency name="_Command_Rebuild"/>
		</member>
		<member name="M:_GROUP_PREVIOUS_FUNCTION" syntax="_GROUP_PREVIOUS_FUNCTION()">
			<stacksize value="1"/>
			<referrer name="_Group_IncludeAll_1"/>
			<remarks>  Calls all functions to correctly include them in the AMX when required.  Also all variables as it turns out they were a problem too.  </remarks> 
		</member>
		<member name="M:_Group_IncludeAll_1" syntax="_Group_IncludeAll_1()">
			<stacksize value="9"/>
			<dependency name="Command_SetPlayer"/>
			<dependency name="Group_ExclusiveCommand@"/>
			<dependency name="Group_GetCommand@"/>
			<dependency name="Group_GetGlobalCommand@"/>
			<dependency name="Group_GlobalExclusiveCommand@"/>
			<dependency name="Group_SetCommand@"/>
			<dependency name="Group_SetCommandDefault@"/>
			<dependency name="Group_SetCommandNew@"/>
			<dependency name="Group_SetGlobalCommand@"/>
			<dependency name="Group_SetGlobalCommandDefault@"/>
			<dependency name="Group_SetGlobalCommandNew@"/>
			<dependency name="HANDOFF_SOURCE@_Group"/>
			<dependency name="YSI_g_sDefaultMembership"/>
			<dependency name="YSI_g_sElementMembership"/>
			<dependency name="YSI_g_sElementMembership"/>
			<dependency name="YSI_g_sEmpty"/>
			<dependency name="YSI_g_sMaxEncountered"/>
			<dependency name="_GROUP_PREVIOUS_FUNCTION"/>
			<dependency name="_yGA"/>
			<dependency name="_yGACommand"/>
			<dependency name="_yGI"/>
			<dependency name="_yGICommand"/>
			<dependency name="_yGU"/>
			<dependency name="_yGUCommand"/>
			<dependency name="false"/>
			<dependency name="printf"/>
		</member>
		<member name="M:_HashMap_Init" syntax="_HashMap_Init(m[], &amp;target, size1, size2, &amp;t2)">
			<stacksize value="2"/>
			<referrer name="@yH_OnScriptInit@005"/>
			<referrer name="_Command_Rebuild"/>
			<param name="m">
				<paraminfo> [260] </paraminfo>
				Hash map to initialise.
			</param>
			<param name="target">
				<paraminfo> &amp; </paraminfo>
				Address of the hashmap data.
			</param>
			<param name="size1">
				Number of entries.
			</param>
			<param name="size2">
				Total Size of each entry IN BYTES.
			</param>
			<param name="t2">
				<paraminfo> &amp; </paraminfo>
				Address of the name AND data start.
			</param>
			          <remarks>  Finds the location of the hash map linked list data in the passed array data  and uses that to read the data through pointers subsequently.  It doesn't  matter WHERE in the enum the hash map data is, and if its not there you'll  get an error, or at least a warning.  </remarks> 
		</member>
		<member name="M:_HookChain_IncludeStates" syntax="_HookChain_IncludeStates()">
			<stacksize value="1"/>
			<automaton name="_ALS"/>
		</member>
		<member name="M:_Hooks_AddReplacement" syntax="_Hooks_AddReplacement(longName[], shortName[])">
			<stacksize value="5"/>
			<referrer name="@_yHCheckpoint"/>
			<referrer name="@_yHContainer"/>
			<referrer name="@_yHInventory"/>
			<referrer name="@_yHDynamic"/>
			<referrer name="@_yHTextDraw"/>
			<referrer name="@_yHUpdate"/>
			<referrer name="@_yHObject"/>
			<referrer name="@_yHCommand"/>
			<referrer name="@_yHDynamicCP"/>
			<dependency name="Debug_Print0"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_LONG"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MAX"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MIN"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_SHORT"/>
			<dependency name="YSI_g_sReplacePtr"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacementsLongOrder"/>
			<dependency name="YSI_g_sReplacementsShortOrder"/>
			<dependency name="strcat"/>
			<dependency name="strlen"/>
			<param name="longName">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="shortName">
				<paraminfo> [] </paraminfo>
			</param>
			<remarks>  Call the main hook run code, then advance the ALS chain.  </remarks> 
		</member>
		<member name="M:_Master_Get" syntax="_Master_Get(library[], force)">
			<tagname value="bool"/>
			<stacksize value="9"/>
			<referrer name="Master_GetCurrentMaster"/>
			<referrer name="Master_GetCurrentMaster"/>
			<dependency name="YSI_g_sMasterCount"/>
			<dependency name="YSI_g_sMasterData"/>
			<dependency name="_@"/>
			<dependency name="existproperty"/>
			<dependency name="false"/>
			<dependency name="getproperty"/>
			<dependency name="setproperty"/>
			<dependency name="true"/>
			<param name="library">
				<paraminfo> [] </paraminfo>
				The name of the library to try become master for.
			</param>
			<param name="force">
				<paraminfo>bool </paraminfo>
			</param>
			 
		</member>
		<member name="M:_Master_Relinquish" syntax="_Master_Relinquish(library[])">
			<stacksize value="3"/>
			<referrer name="@_"/>
			<referrer name="@a"/>
			<dependency name="YSI_g_sMasterCount"/>
			<dependency name="YSI_g_sMasterData"/>
			<param name="library">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:_Puny_Basic" syntax="_Puny_Basic(num)">
			<stacksize value="1"/>
			<param name="num">
				The single number to encode.
			</param>
			  <remarks>  Convert a single digit to base 36.  </remarks> 
		</member>
		<member name="M:_SSCANF_IncludeStates" syntax="_SSCANF_IncludeStates()">
			<stacksize value="1"/>
			<automaton name="_ALS"/>
			<library>sscanf</library>  <remarks>  Common ALS boilerplate to ensure that all the <c>&lt;_ALS : &gt;</c> states  are known to the compiler.  </remarks> 
		</member>
		<member name="M:_ScriptInit_FixState" syntax="_ScriptInit_FixState()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_script_init_fix_state"/>
		</member>
		<member name="M:_ScriptInit_IncludeStates" syntax="_ScriptInit_IncludeStates()">
			<stacksize value="1"/>
			<automaton name="_ALS"/>
		</member>
		<member name="M:_Timer_A" syntax="_Timer_A(str[], len)">
			<stacksize value="8"/>
			<dependency name="Malloc_SetA"/>
			<dependency name="Timer_GetSingleSlot"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:_Timer_C" syntax="_Timer_C(tt, g)">
			<stacksize value="5"/>
			<dependency name="I@"/>
			<dependency name="Timer_GetSingleSlot"/>
			<dependency name="YSI_gMallocMemory"/>
			<dependency name="YSI_g_sFirstSlot"/>
			<dependency name="YSI_g_sLastSlot"/>
			<param name="tt">
			</param>
			<param name="g">
			</param>
		</member>
		<member name="M:_Timer_D" syntax="_Timer_D(func[], interval, action, who, results[], a[])">
			<stacksize value="7"/>
			<dependency name="Iterator@Player"/>
			<dependency name="KillTimer"/>
			<dependency name="SetTimerEx"/>
			<dependency name="YSI_g_sPlayerTimers"/>
			<dependency name="true"/>
			<param name="func">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="interval">
			</param>
			<param name="action">
			</param>
			<param name="who">
			</param>
			<param name="results">
				<paraminfo> [1000] </paraminfo>
			</param>
			<param name="a">
				<paraminfo> [2] </paraminfo>
			</param>
		</member>
		<member name="M:_Timer_F" syntax="_Timer_F(slot)">
			<stacksize value="5"/>
			<referrer name="_Timer_H"/>
			<dependency name="KillTimer"/>
			<dependency name="Malloc_Free"/>
			<dependency name="YSI_gMallocMemory"/>
			<param name="slot">
			</param>
		</member>
		<member name="M:_Timer_H" syntax="_Timer_H(slot)">
			<stacksize value="4"/>
			<dependency name="_Timer_F"/>
			<param name="slot">
			</param>
		</member>
		<member name="M:_Timer_I" syntax="_Timer_I(func[], interval, action, &amp;result)">
			<stacksize value="5"/>
			<referrer name="@yT_VremeDatum"/>
			<referrer name="@yT_GlobalTimer"/>
			<dependency name="KillTimer"/>
			<dependency name="SetTimer"/>
			<param name="func">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="interval">
			</param>
			<param name="action">
			</param>
			<param name="result">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:_Timer_S" syntax="_Timer_S(str[])">
			<stacksize value="9"/>
			<dependency name="Malloc_SetS"/>
			<dependency name="Timer_GetSingleSlot"/>
			<dependency name="strlen"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:_Y_G@C_1" syntax="_Y_G@C_1()">
			<stacksize value="1"/>
			<referrer name="_yGACommand"/>
		</member>
		<member name="M:_Y_G@C_3" syntax="_Y_G@C_3()">
			<stacksize value="1"/>
			<referrer name="_yGICommand"/>
			<referrer name="_yGUCommand"/>
		</member>
		<member name="M:__CompilerSecondPass" syntax="__CompilerSecondPass()">
			<stacksize value="1"/>
		</member>
		<member name="M:__TU" syntax="__TU(t, iters)">
			<stacksize value="27"/>
			<dependency name="operator/(Float:,Float:)"/>
			<dependency name="__TU"/>
			<dependency name="float"/>
			<dependency name="format"/>
			<param name="t">
				The time in ms.
			</param>
			<param name="iters">
				The number of iterations completed in this time.
			</param>
			    <remarks>  Formats and returns a string representing the time taken for one iteration,  given the time required for many iterations.  This attempts to format the  number using a reasonable fraction of a second.  </remarks> 
		</member>
		<member name="M:_yGACommand" syntax="_yGACommand(&amp;group)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="J@"/>
			<dependency name="YSI_g_sDefaultMembership"/>
			<dependency name="YSI_g_sElementMembership"/>
			<dependency name="YSI_g_sElementMembership"/>
			<dependency name="_Y_G@C_1"/>
			<dependency name="_yGA"/>
			<dependency name="cellbits"/>
			<param name="group">
				<paraminfo> &amp; </paraminfo>
				The group that was just created.
			</param>
			  <remarks>  The given group was just created, loop over all elements and make sure they  are NOT in this group - only the global group has a "default default" of  true.  We don't need to update any players with this as no-one will ever be  in a brand new group.  </remarks> 
		</member>
		<member name="M:_yGICommand" syntax="_yGICommand(&amp;ni, &amp;na, &amp;nu)">
			<stacksize value="8"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="AMX_GetPointerPrefix"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="J@"/>
			<dependency name="YSI_g_cEmptyGroups"/>
			<dependency name="YSI_g_sDefaultMembership"/>
			<dependency name="YSI_g_sEmpty"/>
			<dependency name="_Y_G@C_3"/>
			<dependency name="_yGA"/>
			<dependency name="_yGI"/>
			<dependency name="_yGU"/>
			<dependency name="cellbits"/>
			<param name="ni">
				<paraminfo> &amp; </paraminfo>
				Next init function variable as returned by y_amx.
			</param>
			<param name="na">
				<paraminfo> &amp; </paraminfo>
				Next add function variable as returned by y_amx.
			</param>
			<param name="nu">
				<paraminfo> &amp; </paraminfo>
				Next update function variable as returned by y_amx.
			</param>
			      <remarks>  This function is called when the group system first starts up to initialise  the global group and all the various function pointers.  The way the  "_gchain" macro works means that the fact that "ni" etc are references is  irrelevant; however, it does make the code LOOK much nicer and like  assigning to the variables does have some wider meaning.  If this is called with "ni = -1", it is special code to temporarily set or  restore the defaults for use with the "GROUP_ADD" macro.  So basically, it  is poor design giving two distinct uses to a single function.  </remarks> 
		</member>
		<member name="M:_yGUCommand" syntax="_yGUCommand(&amp;pid, p[], c[])">
			<stacksize value="9"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="Group_FullPlayerUpdate"/>
			<dependency name="J@"/>
			<dependency name="YSI_g_sElementMembership"/>
			<dependency name="YSI_g_sElementMembership"/>
			<dependency name="YSI_g_sMaxEncountered"/>
			<dependency name="_Y_G@C_3"/>
			<dependency name="_yGU"/>
			<param name="pid">
				<paraminfo> &amp; </paraminfo>
				The player who joined or left groups.
			</param>
			<param name="p">
				<paraminfo>Bit [] </paraminfo>
				Their previous groups.
			</param>
			<param name="c">
				<paraminfo>Bit [] </paraminfo>
				Their new groups.
			</param>
			      <remarks>  The player "pid" just joined or left a group (or groups - can do multiple).  Update their visibility accordingly.  This function is ONLY called if there  is a CHANGE - earlier functions confirm that they weren't already in (or  not) this group(s) before the call.  </remarks> 
		</member>
		<member name="M:_y_utils_OnPlayerConnect" syntax="_y_utils_OnPlayerConnect(playerid)">
			<attribute name="public"/>
			<stacksize value="30"/>
			<dependency name="GetPlayerName"/>
			<dependency name="IsPlayerNPC"/>
			<dependency name="SSCANF_Join"/>
			<dependency name="SSCANF_OnPlayerConnect"/>
			<dependency name="SSCANF_gInit"/>
			<param name="playerid">
			</param>
			<library>sscanf</library>  <remarks>  Called when a player connects.  Actually increments an internal count so that  if a script ends and <c>OnPlayerDisconnect</c> is called then <c>sscanf</c>  still knows that the player is really connected.  Also stores their name  internally.  </remarks> 
		</member>
		<member name="M:_y_utils_OnPlayerDisconnect" syntax="_y_utils_OnPlayerDisconnect(playerid, reason)">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="SSCANF_Leave"/>
			<dependency name="SSCANF_OnPlayerDisconnect"/>
			<dependency name="SSCANF_gInit"/>
			<param name="playerid">
			</param>
			<param name="reason">
			</param>
			<library>sscanf</library>  <remarks>  Called when a player disconnects, or when a script is ended.  </remarks> 
		</member>
		<member name="M:argderef" syntax="argderef(n)">
			<stacksize value="1"/>
			<dependency name="argderef"/>
			<param name="n">
			</param>
		</member>
		<member name="M:argref" syntax="argref(n)">
			<stacksize value="1"/>
			<param name="n">
			</param>
		</member>
		<member name="M:bernstein" syntax="bernstein(string[])">
			<stacksize value="28"/>
			<referrer name="bernstein"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmEmitAdd"/>
			<dependency name="AsmEmitAddC"/>
			<dependency name="AsmEmitConstAlt"/>
			<dependency name="AsmEmitJnzRel"/>
			<dependency name="AsmEmitJzerRel"/>
			<dependency name="AsmEmitLoadI"/>
			<dependency name="AsmEmitLrefSPri"/>
			<dependency name="AsmEmitMoveAlt"/>
			<dependency name="AsmEmitMovePri"/>
			<dependency name="AsmEmitPopPri"/>
			<dependency name="AsmEmitProc"/>
			<dependency name="AsmEmitPushPri"/>
			<dependency name="AsmEmitPushS"/>
			<dependency name="AsmEmitRetn"/>
			<dependency name="AsmEmitSmulC"/>
			<dependency name="AsmEmitStack"/>
			<dependency name="AsmEmitXchg"/>
			<dependency name="AsmInitPtr"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				the string to hash.
			</param>
			  <returns>  the bernstein hash of the input string  </returns>  <remarks>  This is a 32bit hash system so is not very secure, however we're only  using this as a string enumerator to uniquely identify strings easilly  and allow for a binary search of strings based on the hash of their name.  crc32, then jenkins were originally used however this is far faster, if a  little collision prone, but we're checking the strings manually anyway.  This doesn't matter as it would be done regardless of hash method, so this  doesn't need to be accounted for.  Speed is all that matters with at   least a bit of non collision (the number of strings we're dealing with,  this should have none-few collisions).  I modified it slightly from the original code pasted by aru, to code  closer to the code <a href="http://www.burtleburtle.net/bob/hash/doobs.html" />  and to work with PAWN (and shaved 0.2s off the time for one call :D).  Uber reduced version (just for fun):  b(s[]){new h=-1,i,j;while((j=s[i++]))h=h*33+j;return h;}  Update: Contrary to what I said above this is also used to identify colour  strings for the updated text system involving file based styling and this  is not checked for collisions as it's unimportant.  But this doesn't affect  the function at all, I just mentioned it here for "interest".  Rewritten in self-generating assembly.  </remarks> 
		</member>
		<member name="M:binstr" syntax="binstr(string[])">
			<stacksize value="3"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				String to try convert to a boolean.
			</param>
			  <returns>  bool: passed boolean.  </returns>  <remarks>  This takes a value in 0110101 (boolean) format and returns it as a  regular value.  </remarks> 
		</member>
		<member name="M:boolstr" syntax="boolstr(string[])">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<dependency name="strcmp"/>
			<dependency name="true"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				String to try convert to a boolean.
			</param>
			  <returns>  bool: passed boolean.  </returns>  <remarks>  This can take a number of ways of representing booleans - 0, false and  nothing there.  Anything not one of those things (false is not case  sensitive) is assumed true.  </remarks> 
		</member>
		<member name="M:calloc" syntax="calloc(size)">
			<tagname value="Alloc"/>
			<stacksize value="6"/>
			<dependency name="Malloc_Allocate"/>
			<dependency name="YSI_gMallocMemory"/>
			<param name="size">
				Size of memory to allocate.
			</param>
			  <returns>  0 on fail or a data handle on sucess.  </returns>  <remarks>  Displays errors in secure mode.  Blanks allocated mmeory.  </remarks> 
		</member>
		<member name="M:ceildiv" syntax="ceildiv(numerator, denominator)">
			<stacksize value="1"/>
			<param name="numerator">
				The top of the division.
			</param>
			<param name="denominator">
				The bottom of the division.
			</param>
			    <returns>  (numerator / denominator) rounded up.  </returns>  <remarks>  Normal integer division ALWAYS rounds down - this always rounds up.  </remarks> 
		</member>
		<member name="M:chrfind" syntax="chrfind(needle, haystack[], start)">
			<stacksize value="3"/>
			<dependency name="strlen"/>
			<param name="needle">
				The character to find.
			</param>
			<param name="haystack">
				<paraminfo> [] </paraminfo>
				The string to find it in.
			</param>
			<param name="start">
				The offset to start from.
			</param>
			      <returns>  Fail - -1, Success - pos  </returns> 
		</member>
		<member name="M:chrfindp" syntax="chrfindp(needle, haystack[], start)">
			<stacksize value="1"/>
			<param name="needle">
				The character to find.
			</param>
			<param name="haystack">
				<paraminfo> [] </paraminfo>
				The string to find it in.
			</param>
			<param name="start">
				The offset to start from.
			</param>
			      <returns>  Fail - -1, Success - pos  </returns>  <remarks>  Like <symbolref name="chrfind" />, but with no upper-bounds check on  <paramref name="start" />.  </remarks> 
		</member>
		<member name="M:copy_1" syntax="copy_1(&amp;dest, source[], start)">
			<stacksize value="1"/>
			<referrer name="GetAmxHeaderNow"/>
			<param name="dest">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
		</member>
		<member name="M:copy_2" syntax="copy_2(&amp;dest, source[], start)">
			<stacksize value="1"/>
			<referrer name="GetAmxHeaderNow"/>
			<param name="dest">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
		</member>
		<member name="M:copy_4" syntax="copy_4(&amp;dest, source[], start)">
			<stacksize value="1"/>
			<referrer name="GetAmxHeaderNow"/>
			<param name="dest">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
		</member>
		<member name="M:deref" syntax="deref(v)">
			<stacksize value="1"/>
			<dependency name="deref"/>
			<param name="v">
			</param>
		</member>
		<member name="M:endofline" syntax="endofline(line[], pos)">
			<stacksize value="3"/>
			<dependency name="cellmin"/>
			<dependency name="strlen"/>
			<param name="line">
				<paraminfo> [] </paraminfo>
				String to check.
			</param>
			<param name="pos">
				Postion to start from.
			</param>
			    <remarks>  Checks if the current point in a line is the end of non-whitespace data.  </remarks> 
		</member>
		<member name="M:enter_public" syntax="enter_public(index, address)">
			<stacksize value="6"/>
			<referrer name="new_pec"/>
			<dependency name="ProfCallInfo"/>
			<dependency name="exit_public"/>
			<dependency name="g_call_depth"/>
			<dependency name="g_call_stack"/>
			<dependency name="g_call_stack"/>
			<dependency name="pci_index"/>
			<dependency name="pci_start_time"/>
			<dependency name="printf"/>
			<dependency name="tickcount"/>
			<param name="index">
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:existproperty" syntax="existproperty(id, name[], value)">
			<attribute name="native"/>
			<referrer name="HookChain_OnScriptInit"/>
			<referrer name="_Master_Get"/>
			<param name="id">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:exit_public" syntax="exit_public()">
			<stacksize value="8"/>
			<referrer name="enter_public"/>
			<dependency name="cellmax"/>
			<dependency name="cellmin"/>
			<dependency name="g_call_depth"/>
			<dependency name="g_call_stack"/>
			<dependency name="g_num_publics"/>
			<dependency name="g_publics"/>
			<dependency name="g_publics"/>
			<dependency name="pci_index"/>
			<dependency name="pci_start_time"/>
			<dependency name="ppi_child_time"/>
			<dependency name="ppi_num_calls"/>
			<dependency name="ppi_total_time"/>
			<dependency name="tickcount"/>
		</member>
		<member name="M:fclose" syntax="fclose(handle)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="DisasmWrite"/>
			<referrer name="ProfilerWriteData"/>
			<referrer name="ftouch"/>
			<referrer name="INI_ParseFile"/>
			<referrer name="INI_WriteBuffer"/>
			<param name="handle">
				<paraminfo>File </paraminfo>
			</param>
		</member>
		<member name="M:fexist" syntax="fexist(pattern[])">
			<attribute name="native"/>
			<referrer name="ftouch"/>
			<referrer name="SSCANF_OnPlayerConnect"/>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:float" syntax="float(value)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator*(Float:,_:)"/>
			<referrer name="operator/(Float:,_:)"/>
			<referrer name="operator/(_:,Float:)"/>
			<referrer name="operator+(Float:,_:)"/>
			<referrer name="operator-(Float:,_:)"/>
			<referrer name="operator-(_:,Float:)"/>
			<referrer name="operator==(Float:,_:)"/>
			<referrer name="operator!=(Float:,_:)"/>
			<referrer name="operator&gt;(Float:,_:)"/>
			<referrer name="operator&gt;(_:,Float:)"/>
			<referrer name="operator&gt;=(Float:,_:)"/>
			<referrer name="operator&gt;=(_:,Float:)"/>
			<referrer name="operator&lt;(Float:,_:)"/>
			<referrer name="operator&lt;(_:,Float:)"/>
			<referrer name="operator&lt;=(Float:,_:)"/>
			<referrer name="operator&lt;=(_:,Float:)"/>
			<referrer name="__TU"/>
			<referrer name="RandomFloat"/>
			<param name="value">
			</param>
		</member>
		<member name="M:floatadd" syntax="floatadd(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator+(Float:,_:)"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:floatcmp" syntax="floatcmp(oper1, oper2)">
			<attribute name="native"/>
			<referrer name="operator==(Float:,Float:)"/>
			<referrer name="operator==(Float:,_:)"/>
			<referrer name="operator!=(Float:,Float:)"/>
			<referrer name="operator!=(Float:,_:)"/>
			<referrer name="operator&gt;(Float:,Float:)"/>
			<referrer name="operator&gt;(Float:,_:)"/>
			<referrer name="operator&gt;(_:,Float:)"/>
			<referrer name="operator&gt;=(Float:,Float:)"/>
			<referrer name="operator&gt;=(Float:,_:)"/>
			<referrer name="operator&gt;=(_:,Float:)"/>
			<referrer name="operator&lt;(Float:,Float:)"/>
			<referrer name="operator&lt;(Float:,_:)"/>
			<referrer name="operator&lt;(_:,Float:)"/>
			<referrer name="operator&lt;=(Float:,Float:)"/>
			<referrer name="operator&lt;=(Float:,_:)"/>
			<referrer name="operator&lt;=(_:,Float:)"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:floatdiv" syntax="floatdiv(dividend, divisor)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator/(Float:,_:)"/>
			<referrer name="operator/(_:,Float:)"/>
			<param name="dividend">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="divisor">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:floatmul" syntax="floatmul(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator*(Float:,_:)"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:floatpower" syntax="floatpower(value, exponent)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="RandomFloat"/>
			<param name="value">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="exponent">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:floatround" syntax="floatround(value, method)">
			<attribute name="native"/>
			<referrer name="RandomFloat"/>
			<param name="value">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="method">
				<paraminfo>floatround_method </paraminfo>
			</param>
		</member>
		<member name="M:floatsub" syntax="floatsub(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator-(Float:,_:)"/>
			<referrer name="operator-(_:,Float:)"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:floordiv" syntax="floordiv(numerator, denominator)">
			<stacksize value="1"/>
			<param name="numerator">
				The top of the division.
			</param>
			<param name="denominator">
				The bottom of the division.
			</param>
			<summary>  floordiv(numerator, denominator);  </summary>      <returns>  (numerator / denominator) rounded down.  </returns>  <remarks>  Normal integer division ALWAYS rounds down - this also always rounds down,  making it a little pointless, but also more explicit in function.  </remarks> 
		</member>
		<member name="M:fopen" syntax="fopen(name[], mode)">
			<tagname value="File"/>
			<attribute name="native"/>
			<referrer name="DisasmWrite"/>
			<referrer name="ProfilerWriteData"/>
			<referrer name="ftouch"/>
			<referrer name="INI_ParseFile"/>
			<referrer name="INI_WriteBuffer"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="mode">
				<paraminfo>filemode </paraminfo>
			</param>
		</member>
		<member name="M:format" syntax="format(output[], len, format[], ...)">
			<attribute name="native"/>
			<referrer name="ProfilerWriteData"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="Debug_PrintArray"/>
			<referrer name="__TU"/>
			<referrer name="va_return"/>
			<referrer name="Bit_Display"/>
			<referrer name="INI_ParseFile"/>
			<referrer name="INI_SetupCallbackName"/>
			<referrer name="INI_WriteInt"/>
			<referrer name="INI_WriteHex"/>
			<referrer name="INI_WriteBin"/>
			<referrer name="INI_WriteFloat"/>
			<referrer name="UserPath"/>
			<referrer name="SendClientMessageEx"/>
			<referrer name="OnPlayerCommandReceived"/>
			<referrer name="@yH_OnPlayerKeyStateChange@016"/>
			<referrer name="VremeDatum"/>
			<referrer name="@_yCdo"/>
			<referrer name="@_yCb"/>
			<referrer name="@_yCme"/>
			<referrer name="@_yCmakestaff"/>
			<referrer name="@_yCstaffon"/>
			<referrer name="@_yCclearchat"/>
			<referrer name="@_yCxgoto"/>
			<referrer name="@_yCdajnovac"/>
			<referrer name="GlobalTimer"/>
			<referrer name="GetPlayer2DZone"/>
			<referrer name="@yH_OnDialogResponse@029"/>
			<param name="output">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:fread" syntax="fread(handle, string[], size, pack)">
			<attribute name="native"/>
			<referrer name="INI_ParseFile"/>
			<referrer name="INI_DoParentTag"/>
			<referrer name="INI_WriteBuffer"/>
			<param name="handle">
				<paraminfo>File </paraminfo>
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="pack">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:free" syntax="free(slot)">
			<stacksize value="1"/>
			<param name="slot">
				<paraminfo>Alloc </paraminfo>
				Slot of memory to free up.
			</param>
			  <remarks>  Displays errors in secure mode.  </remarks> 
		</member>
		<member name="M:freezethaw" syntax="freezethaw(playerid)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<dependency name="TogglePlayerControllable"/>
			<dependency name="ZalediOdlediTimer"/>
			<dependency name="true"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:fremove" syntax="fremove(name[])">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="INI_WriteBuffer"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:fseek" syntax="fseek(handle, position, whence)">
			<attribute name="native"/>
			<referrer name="INI_ParseFile"/>
			<referrer name="INI_DoParentTag"/>
			<referrer name="INI_WriteBuffer"/>
			<param name="handle">
				<paraminfo>File </paraminfo>
			</param>
			<param name="position">
			</param>
			<param name="whence">
				<paraminfo>seek_whence </paraminfo>
			</param>
		</member>
		<member name="M:ftemp" syntax="ftemp()">
			<tagname value="File"/>
			<attribute name="native"/>
			<referrer name="INI_WriteBuffer"/>
		</member>
		<member name="M:ftouch" syntax="ftouch(filename[])">
			<stacksize value="5"/>
			<referrer name="INI_Open"/>
			<dependency name="fclose"/>
			<dependency name="fexist"/>
			<dependency name="fopen"/>
			<dependency name="io_write"/>
			<param name="filename">
				<paraminfo> [] </paraminfo>
				The file to "touch".
			</param>
			<summary>  ftouch(filename);  </summary>    <returns>  0 - File already exists.  1 - File was created.  -1 - File was not created.  </returns>  <remarks>  This "touches" a file in the Unix sense of creating it but not opening or  editing it in any way.  </remarks> 
		</member>
		<member name="M:funcidx" syntax="funcidx(name[])">
			<attribute name="native"/>
			<referrer name="CGen_GetAddr"/>
			<referrer name="GetLocalFunction"/>
			<referrer name="@yH_OnScriptInit@005"/>
			<referrer name="@yH_OnScriptExit@005"/>
			<referrer name="@yH_OnMasterSystemClose@005"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:fwrite" syntax="fwrite(handle, string[])">
			<attribute name="native"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DisasmWriteDataRowChar"/>
			<referrer name="DisasmWriteDataRowHex"/>
			<referrer name="DisasmWriteData"/>
			<referrer name="ProfilerWriteData"/>
			<referrer name="va_fprintf"/>
			<referrer name="INI_DumpTag"/>
			<referrer name="INI_WriteBuffer"/>
			<param name="handle">
				<paraminfo>File </paraminfo>
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:getarg" syntax="getarg(arg, index)">
			<attribute name="native"/>
			<referrer name="AsmEmitInstruction"/>
			<referrer name="CodeScanMatcherPattern_"/>
			<referrer name="I@L"/>
			<referrer name="Distribute_Do"/>
			<referrer name="Distribute_So"/>
			<referrer name="Distribute_To"/>
			<param name="arg">
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:getdate" syntax="getdate(&amp;year, &amp;month, &amp;day)">
			<attribute name="native"/>
			<referrer name="VremeDatum"/>
			<param name="year">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="month">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="day">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:getproperty" syntax="getproperty(id, name[], value, string[])">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="Z@"/>
			<referrer name="S@"/>
			<referrer name="F@"/>
			<referrer name="Master_GetNext"/>
			<referrer name="HookChain_OnScriptInit"/>
			<referrer name="ScriptInit_OnScriptExit"/>
			<referrer name="Master_Reassert"/>
			<referrer name="_Master_Get"/>
			<referrer name="@_"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="@a"/>
			<param name="id">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="value">
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:gettime" syntax="gettime(&amp;hour, &amp;minute, &amp;second)">
			<attribute name="native"/>
			<referrer name="VremeDatum"/>
			<param name="hour">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="minute">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="second">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:heapspace" syntax="heapspace()">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="AMX_OnScriptInit"/>
			<referrer name="Malloc_SolidifyHeap"/>
		</member>
		<member name="M:hexstr" syntax="hexstr(string[])">
			<stacksize value="4"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				String to convert to a number.
			</param>
			  <returns>  value of the passed hex string.  </returns>  <remarks>  Now stops on invalid characters.  </remarks> 
		</member>
		<member name="M:iseven" syntax="iseven(value)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="value">
				Value to check if is even.
			</param>
			 
		</member>
		<member name="M:ishex" syntax="ishex(str[])">
			<stacksize value="3"/>
			<dependency name="cellmin"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to check.
			</param>
			  <returns>  true/false.  </returns> 
		</member>
		<member name="M:isnull" syntax="isnull(str[])">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to check if is null.
			</param>
			 
		</member>
		<member name="M:isnumeric" syntax="isnumeric(str[])">
			<stacksize value="2"/>
			<dependency name="cellmin"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to check
			</param>
			  <remarks>  Checks if a given string is numeric.  </remarks> 
		</member>
		<member name="M:isodd" syntax="isodd(value)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="value">
				Value to check if is odd.
			</param>
			 
		</member>
		<member name="M:ispacked" syntax="ispacked(string[])">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="Puny_EncodeHash"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:iterfunc" syntax="iterfunc(params)">
			<stacksize value="1"/>
			<param name="params">
				The iterator function's parameters.
			</param>
			  <remarks>  Used to declare a special iterator function.  Examples:  <code>  iterfunc stock OnlyZero(cur)                                                    <br />  {                                                                               <br /><indent />  if (cur == -1)                                                              <br /><indent /><indent />  return 0;                                                               <br /><indent />  return -1;                                                                  <br />  }                                                                               <br />  </code>  <code>  iterfunc stock AlsoOnlyZero[cellmin](cur)                                       <br />  {                                                                               <br /><indent />  if (cur == cellmin)                                                         <br /><indent /><indent />  return 0;                                                               <br /><indent />  return cellmin;                                                             <br />  }                                                                               <br />  </code>  <code>  iterfunc stock OneToTen[cellmin](cur)                                           <br />  {                                                                               <br /><indent />  if (cur == cellmin)                                                         <br /><indent /><indent />  return 1;                                                               <br /><indent />  if (cur == 10)                                                              <br /><indent /><indent />  return cellmin;                                                         <br /><indent />  return cur + 1;                                                             <br />  }                                                                               <br />  </code>  <code>  iterfunc stock OneToN(cur, n)                                                   <br />  {                                                                               <br /><indent />  if (n &lt; 1)                                                               <br /><indent /><indent />  return -1;                                                              <br /><indent />  if (cur == -1)                                                              <br /><indent /><indent />  return 1;                                                               <br /><indent />  if (cur == n)                                                               <br /><indent /><indent />  return -1;                                                              <br /><indent />  return cur + 1;                                                             <br />  }                                                                               <br />  </code>  </remarks> 
		</member>
		<member name="M:main" syntax="main()">
			<attribute name="entry"/>
			<stacksize value="3"/>
			<dependency name="Malloc_TrySetup"/>
		</member>
		<member name="M:malloc" syntax="malloc(size)">
			<tagname value="Alloc"/>
			<stacksize value="1"/>
			<param name="size">
				Size of memory to allocate.
			</param>
			  <returns>  0 on fail or a data handle on sucess.  </returns>  <remarks>  Displays errors in secure mode.  </remarks> 
		</member>
		<member name="M:max" syntax="max(value1, value2)">
			<attribute name="native"/>
			<referrer name="YVA2_FoundPush"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_Add"/>
			<param name="value1">
			</param>
			<param name="value2">
			</param>
		</member>
		<member name="M:memcpy" syntax="memcpy(dest[], source[], index, numbytes, maxlength)">
			<attribute name="native"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="StripL"/>
			<referrer name="Strip"/>
			<referrer name="rawMemcpy"/>
			<referrer name="YVA2_DoPush"/>
			<referrer name="Malloc_GetA"/>
			<referrer name="Malloc_SetA"/>
			<referrer name="Malloc_SetVAA"/>
			<referrer name="Callback_Get"/>
			<referrer name="Iter_Init_Internal"/>
			<referrer name="Iter_YieldLoop"/>
			<referrer name="Iter_YieldReturn"/>
			<referrer name="_@_y_distribute_@_"/>
			<referrer name="Distribute_To"/>
			<referrer name="Group_Handoff"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="index">
			</param>
			<param name="numbytes">
			</param>
			<param name="maxlength">
			</param>
		</member>
		<member name="M:memset" syntax="memset(arr[], val, size)">
			<stacksize value="7"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="rawMemset"/>
			<referrer name="Bit_SetAll"/>
			<referrer name="Malloc_TrySetup"/>
			<referrer name="Malloc_Allocate"/>
			<dependency name="rawMemset"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				Array or address to set to a value.
			</param>
			<param name="val">
			</param>
			<param name="size">
			</param>
			  <param name="iValue">What to set the cells to.</param>  <param name="iSize">Number of cells to fill.</param>  <remarks>  Based on code by Slice:  <a href="http://forum.sa-mp.com/showthread.php?p=1606781#post1606781" />  Modified to use binary flags instead of a loop.  "memset" takes an array, the size of the array, and a value to fill it with  and sets the whole array to that value.  "rawmemset" is similar, but takes an AMX data segment address instead and  the size is in bytes, not cells.  However, the size must still be a multiple  of 4.  </remarks> 
		</member>
		<member name="M:mget" syntax="mget(slot, index)">
			<stacksize value="1"/>
			<param name="slot">
				<paraminfo>Alloc </paraminfo>
				The allocation unit to get data from.
			</param>
			<param name="index">
				The location in the unit to get.
			</param>
			    <returns>  The data  </returns>  <remarks>  Shorthand for <symbolref name="Malloc_Get" />.  </remarks> 
		</member>
		<member name="M:mgeta" syntax="mgeta(target[], length, array, index)">
			<stacksize value="1"/>
			<param name="target">
				<paraminfo> [] </paraminfo>
				Target for the string.
			</param>
			<param name="length">
				Length of the target.
			</param>
			<param name="array">
				<paraminfo>Alloc </paraminfo>
				Data unit to put information in.
			</param>
			<param name="index">
				Index in the unit.
			</param>
			        <returns>  The data  </returns>  <remarks>  Displays errors in secure mode.  Gets an array.  Shorthand for <symbolref name="Malloc_GetA" />.  </remarks> 
		</member>
		<member name="M:mgets" syntax="mgets(target[], length, array, index, pack)">
			<stacksize value="1"/>
			<param name="target">
				<paraminfo> [] </paraminfo>
				Target for the string.
			</param>
			<param name="length">
				Length of the target.
			</param>
			<param name="array">
				<paraminfo>Alloc </paraminfo>
				Data unit to put information in.
			</param>
			<param name="index">
				Index in the unit.
			</param>
			<param name="pack">
				<paraminfo>bool </paraminfo>
				Return the string packed?
			</param>
			          <returns>  The data  </returns>  <remarks>  Displays errors in secure mode.  Gets a string.  Shorthand for <symbolref name="Malloc_GetS" />.  </remarks> 
		</member>
		<member name="M:min" syntax="min(value1, value2)">
			<attribute name="native"/>
			<referrer name="DisasmWriteData"/>
			<referrer name="CodeScanAddJumpTarget"/>
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="YHash"/>
			<referrer name="HashMap_RemoveValue"/>
			<referrer name="Distribute_To"/>
			<referrer name="Group_Handoff"/>
			<param name="value1">
			</param>
			<param name="value2">
			</param>
		</member>
		<member name="M:mset" syntax="mset(slot, index, value)">
			<stacksize value="1"/>
			<param name="slot">
				<paraminfo>Alloc </paraminfo>
				The allocation unit to set in.
			</param>
			<param name="index">
				Where in the unit to set.
			</param>
			<param name="value">
				The value to save.
			</param>
			      <remarks>  Shorthand for <symbolref name="Malloc_Set" />.  </remarks> 
		</member>
		<member name="M:mseta" syntax="mseta(array, index, str[], len)">
			<stacksize value="1"/>
			<param name="array">
				<paraminfo>Alloc </paraminfo>
				Data unit to put information in.
			</param>
			<param name="index">
				Index in the unit.
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Array to insert.
			</param>
			<param name="len">
				Length of the array.
			</param>
			        <remarks>  Displays errors in secure mode.  Inserts an array.  Shorthand for <symbolref name="Malloc_SetA" />.  </remarks> 
		</member>
		<member name="M:msets" syntax="msets(array, index, str[], pack)">
			<stacksize value="1"/>
			<param name="array">
				<paraminfo>Alloc </paraminfo>
				Data unit to put information in.
			</param>
			<param name="index">
				Index in the unit.
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to insert
			</param>
			<param name="pack">
				<paraminfo>bool </paraminfo>
				Should the string be packed in?
			</param>
			        <remarks>  Displays errors in secure mode.  Inserts a string.  Shorthand for <symbolref name="Malloc_SetS" />.  </remarks> 
		</member>
		<member name="M:new_pec" syntax="new_pec(index, address, code_start)">
			<stacksize value="13"/>
			<referrer name="ProfilerInit"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_PUSH_C"/>
			<dependency name="ProfEntryCode"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="enter_public"/>
			<dependency name="g_num_pecs"/>
			<dependency name="g_pecs"/>
			<dependency name="g_pecs"/>
			<dependency name="pec_call"/>
			<dependency name="pec_call_enter"/>
			<dependency name="pec_push_8"/>
			<dependency name="pec_push_address"/>
			<dependency name="pec_push_c0"/>
			<dependency name="pec_push_c1"/>
			<dependency name="pec_push_c2"/>
			<dependency name="pec_push_index"/>
			<param name="index">
			</param>
			<param name="address">
			</param>
			<param name="code_start">
			</param>
		</member>
		<member name="M:numargs" syntax="numargs()">
			<attribute name="native"/>
			<referrer name="refabs"/>
			<referrer name="ref"/>
			<referrer name="AsmEmitInstruction"/>
			<referrer name="CodeScanMatcherPattern_"/>
			<referrer name="Inline_OnAsmError"/>
			<referrer name="I@K"/>
			<referrer name="I@L"/>
		</member>
		<member name="M:print" syntax="print(string[])">
			<attribute name="native"/>
			<referrer name="DumpStack"/>
			<referrer name="PrintStackTrace"/>
			<referrer name="ScriptInit_OnScriptInit"/>
			<referrer name="YVers_Callback"/>
			<referrer name="va_print"/>
			<referrer name="Malloc_main"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:printf" syntax="printf(format[], ...)">
			<attribute name="native"/>
			<referrer name="PrintAmxHeader"/>
			<referrer name="enter_public"/>
			<referrer name="ProfilerInit"/>
			<referrer name="DumpStack"/>
			<referrer name="PrintStackTrace"/>
			<referrer name="YVers_Callback"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="Debug_Print0"/>
			<referrer name="_Group_IncludeAll_1"/>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:random" syntax="random(max)">
			<attribute name="native"/>
			<referrer name="Random"/>
			<referrer name="RandomFloat"/>
			<referrer name="Iter_Random_Internal"/>
			<referrer name="Iter_RandomFree_InternalC"/>
			<referrer name="Iter_Func@Random"/>
			<referrer name="@_yCstaffvehicle"/>
			<param name="max">
			</param>
		</member>
		<member name="M:rawMemcpy" syntax="rawMemcpy(dest, src, bytes)">
			<stacksize value="1"/>
			<referrer name="Callback_Get"/>
			<referrer name="Callback_Restore"/>
			<referrer name="HashMap_Add"/>
			<referrer name="HashMap_RemoveValue"/>
			<dependency name="memcpy"/>
			<param name="dest">
				Destination address.
			</param>
			<param name="src">
				Source data.
			</param>
			<param name="bytes">
				Number of bytes to copy.
			</param>
			<summary>  rawMemcpy  </summary>        <remarks>  Like memcpy, but takes addresses instead of arrays.  Also far less secure.  </remarks> 
		</member>
		<member name="M:rawMemset" syntax="rawMemset(iAddress, iValue, iSize)">
			<stacksize value="28"/>
			<referrer name="memset"/>
			<referrer name="rawMemset"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmEmitAnd"/>
			<dependency name="AsmEmitConstAlt"/>
			<dependency name="AsmEmitFill"/>
			<dependency name="AsmEmitLoadPri"/>
			<dependency name="AsmEmitLoadSAlt"/>
			<dependency name="AsmEmitLoadSPri"/>
			<dependency name="AsmEmitProc"/>
			<dependency name="AsmEmitRetn"/>
			<dependency name="AsmEmitShlCPri"/>
			<dependency name="AsmEmitStorPri"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="memset"/>
			<param name="iAddress">
				Array or address to set to a value.
			</param>
			<param name="iValue">
				What to set the cells to.
			</param>
			<param name="iSize">
				Number of cells to fill.
			</param>
			      <remarks>  Based on code by Slice:  <a href="http://forum.sa-mp.com/showthread.php?p=1606781#post1606781" />  Modified to use binary flags instead of a loop.  "memset" takes an array, the size of the array, and a value to fill it with  and sets the whole array to that value.  "rawmemset" is similar, but takes an AMX data segment address instead and  the size is in bytes, not cells.  However, the size must still be a multiple  of 4.  </remarks> 
		</member>
		<member name="M:ref" syntax="ref(...)">
			<stacksize value="2"/>
			<referrer name="AsmRaiseError"/>
			<referrer name="AsmInit"/>
			<referrer name="CodeScanAddMatcher"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<referrer name="GetRemoteFunction"/>
			<referrer name="I@E"/>
			<referrer name="Remote_WriteSpecAndFunc"/>
			<referrer name="HashMap_Add"/>
			<referrer name="HashMap_GetWithHash"/>
			<referrer name="HashMap_RemoveKeyWithHash"/>
			<referrer name="HashMap_RemoveValue"/>
			<dependency name="numargs"/>
			<param name="...">
			</param>
		</member>
		<member name="M:refabs" syntax="refabs(...)">
			<stacksize value="5"/>
			<referrer name="GetAmxAddress"/>
			<dependency name="RelToAbs"/>
			<dependency name="numargs"/>
			<param name="...">
			</param>
		</member>
		<member name="M:returnstringarg" syntax="returnstringarg(idx)">
			<stacksize value="131"/>
			<dependency name="returnstringarg"/>
			<dependency name="strcat"/>
			<param name="idx">
				Index of the string in the parameters.
			</param>
			  <returns>  string  </returns>  <remarks>  Is passed the result of getarg, which will be the address of a string (in  theory) and uses that for DMA to get the string.  </remarks> 
		</member>
		<member name="M:setarg" syntax="setarg(arg, index, value)">
			<attribute name="native"/>
			<referrer name="Iter_Clear_InternalC"/>
			<param name="arg">
			</param>
			<param name="index">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:setproperty" syntax="setproperty(id, name[], value, string[])">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="X@"/>
			<referrer name="Y@"/>
			<referrer name="Z@"/>
			<referrer name="S@"/>
			<referrer name="R@"/>
			<referrer name="HookChain_OnScriptInit"/>
			<referrer name="ScriptInit_OnScriptExit"/>
			<referrer name="Master_Reassert"/>
			<referrer name="_Master_Get"/>
			<referrer name="@_"/>
			<referrer name="@a"/>
			<param name="id">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="value">
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:sscanf" syntax="sscanf(data[], format[], ...)">
			<stacksize value="1"/>
			<param name="data">
				<paraminfo> [] </paraminfo>
				The input string containing the data to parse out.
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
				The format description of what the input data should contain.
			</param>
			<param name="...">
				<paraminfo> {T_WEAPON,Float,_} </paraminfo>
			</param>
			<library>sscanf</library>      <remarks>  The main entry point.  See the readme for vast amounts of information on how  to call this function and all the details on what it does.  This is a macro  that calls <c>SSCANF__</c> and passes the current file and line number as  well for improved error messages.  </remarks> 
		</member>
		<member name="M:sscanf_vehicle" syntax="sscanf_vehicle(string[])">
			<attribute name="public"/>
			<stacksize value="10"/>
			<dependency name="SSCANF_GetSimilarValue"/>
			<dependency name="strval"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				The current word being parsed out of the <c>sscanf</c> input.
			</param>
			<library>sscanf</library>    <remarks>  The default implementation of <c>k&lt;vehicle&gt;</c>.  Finds the closest  vehicle by Levenshtein distance to the input.  </remarks> 
		</member>
		<member name="M:sscanf_weapon" syntax="sscanf_weapon(string[])">
			<attribute name="public"/>
			<stacksize value="10"/>
			<dependency name="SSCANF_GetSimilarValue"/>
			<dependency name="strval"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				The current word being parsed out of the <c>sscanf</c> input.
			</param>
			<library>sscanf</library>    <remarks>  The default implementation of <c>k&lt;weapon&gt;</c>.  Finds the closest  weapon by Levenshtein distance to the input.  </remarks> 
		</member>
		<member name="M:strcat" syntax="strcat(dest[], source[], maxlength)">
			<attribute name="native"/>
			<referrer name="DisasmGetInsnName"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanGetMatchName"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="returnstringarg"/>
			<referrer name="va_getstring"/>
			<referrer name="Malloc_SetVAS"/>
			<referrer name="_@_y_inline_@_"/>
			<referrer name="Hooks_GetPreHooks"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="INI_ParseFile"/>
			<referrer name="INI_SetupCallbackName"/>
			<referrer name="INI_DoParentTag"/>
			<referrer name="INI_Open"/>
			<referrer name="INI_AddToBuffer"/>
			<referrer name="Puny_Decode"/>
			<referrer name="Puny_EncodeHash"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="maxlength">
			</param>
		</member>
		<member name="M:strcmp" syntax="strcmp(string1[], string2[], ignorecase, length)">
			<attribute name="native"/>
			<referrer name="YVers_Callback"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="AMX_GetEntry"/>
			<referrer name="AMX_GetName"/>
			<referrer name="boolstr"/>
			<referrer name="_@_y_inline_@_"/>
			<referrer name="Callback_Get"/>
			<referrer name="Remote_DoSearch"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="INI_ParseFile"/>
			<referrer name="INI_DoParentTag"/>
			<referrer name="INI_GetTag"/>
			<referrer name="INI_AddToBuffer"/>
			<referrer name="INI_WriteBuffer"/>
			<referrer name="HashMap_Add"/>
			<referrer name="HashMap_GetWithHash"/>
			<referrer name="HashMap_RemoveKeyWithHash"/>
			<referrer name="LoadUser_data"/>
			<param name="string1">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="string2">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="ignorecase">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="length">
			</param>
		</member>
		<member name="M:strcpy" syntax="strcpy(dest[], src[], len)">
			<stacksize value="1"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
				Destination string.
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
				Source string.
			</param>
			<param name="len">
				(Implicit) maximum length of the destination.
			</param>
			     
		</member>
		<member name="M:strdel" syntax="strdel(string[], start, end)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="Hooks_IsolateName"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="end">
			</param>
		</member>
		<member name="M:strfind" syntax="strfind(string[], sub[], ignorecase, pos)">
			<attribute name="native"/>
			<referrer name="YVers_Callback"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="AMX_GetEntry"/>
			<referrer name="AMX_GetName"/>
			<referrer name="_@_y_inline_@_"/>
			<referrer name="Callback_Get"/>
			<referrer name="I@E"/>
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="Hooks_IsolateName"/>
			<referrer name="INI_ParseFile"/>
			<referrer name="INI_SetupCallbackName"/>
			<referrer name="INI_DoParentTag"/>
			<referrer name="ZonaIgraca"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="sub">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="ignorecase">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="pos">
			</param>
		</member>
		<member name="M:strins" syntax="strins(string[], substr[], pos, maxlength)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<referrer name="INI_SetupCallbackName"/>
			<referrer name="Puny_Decode"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="substr">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="pos">
			</param>
			<param name="maxlength">
			</param>
		</member>
		<member name="M:strlen" syntax="strlen(string[])">
			<attribute name="native"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="StripNL"/>
			<referrer name="StripL"/>
			<referrer name="Strip"/>
			<referrer name="endofline"/>
			<referrer name="chrfind"/>
			<referrer name="unpack"/>
			<referrer name="va_strlen"/>
			<referrer name="Malloc_NewS"/>
			<referrer name="Malloc_SetS"/>
			<referrer name="Malloc_SetVAS"/>
			<referrer name="Callback_Get"/>
			<referrer name="StoredF_WritePublicCode"/>
			<referrer name="Remote_RawStrpack"/>
			<referrer name="Remote_WriteSpecAndFunc"/>
			<referrer name="YHash"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_Collate"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="INI_IdentifyLineType"/>
			<referrer name="Puny_Decode"/>
			<referrer name="Puny_Encode"/>
			<referrer name="_Timer_S"/>
			<referrer name="udb_hash"/>
			<referrer name="OnDialogResponse"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:strpack" syntax="strpack(dest[], source[], maxlength)">
			<attribute name="native"/>
			<referrer name="Malloc_NewS"/>
			<referrer name="Malloc_GetS"/>
			<referrer name="Malloc_SetS"/>
			<referrer name="_@_y_inline_@_"/>
			<referrer name="Remote_RawStrpack"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="INI_SetTag"/>
			<referrer name="Puny_EncodeHash"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="@yH_OnMasterSystemClose@005"/>
			<referrer name="_Command_Rebuild"/>
			<referrer name="Command_Add"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="maxlength">
			</param>
		</member>
		<member name="M:strunpack" syntax="strunpack(dest[], source[], maxlength)">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="unpack"/>
			<referrer name="S@"/>
			<referrer name="F@"/>
			<referrer name="Malloc_NewS"/>
			<referrer name="Malloc_GetS"/>
			<referrer name="Malloc_SetS"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_Collate"/>
			<referrer name="INI_DeleteTag"/>
			<referrer name="INI_Flush"/>
			<referrer name="INI_WriteBuffer"/>
			<referrer name="Puny_EncodeHash"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="Command_GetName"/>
			<referrer name="Command_GetNext"/>
			<referrer name="_Command_GetDisplay"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="maxlength">
			</param>
		</member>
		<member name="M:strval" syntax="strval(string[])">
			<attribute name="native"/>
			<referrer name="IPToInt"/>
			<referrer name="sscanf_weapon"/>
			<referrer name="sscanf_vehicle"/>
			<referrer name="LoadUser_data"/>
			<referrer name="@yH_OnDialogResponse@029"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:tickcount" syntax="tickcount(&amp;granularity)">
			<attribute name="native"/>
			<referrer name="exit_public"/>
			<referrer name="enter_public"/>
			<param name="granularity">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:tolower" syntax="tolower(c)">
			<attribute name="native"/>
			<referrer name="StrToLower"/>
			<referrer name="Puny_EncodeHash"/>
			<referrer name="@yH_OnScriptInit@005"/>
			<param name="c">
			</param>
		</member>
		<member name="M:toupper" syntax="toupper(c)">
			<attribute name="native"/>
			<referrer name="StrToUpper"/>
			<referrer name="YHash"/>
			<param name="c">
			</param>
		</member>
		<member name="M:u@" syntax="u@(u[])">
			<stacksize value="1"/>
			<param name="u">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:udb_hash" syntax="udb_hash(buf[])">
			<stacksize value="5"/>
			<referrer name="OnDialogResponse"/>
			<dependency name="strlen"/>
			<param name="buf">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:unformat" syntax="unformat(data[], format[], ...)">
			<stacksize value="1"/>
			<param name="data">
				<paraminfo> [] </paraminfo>
				The input string containing the data to parse out.
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
				The format description of what the input data should contain.
			</param>
			<param name="...">
				<paraminfo> {T_WEAPON,Float,_} </paraminfo>
			</param>
			- include <sscanf2> first.  <library>sscanf</library>      <remarks>  An alternative spelling of <c>sscanf</c>, requested by Kalcor because the  original doesn't match the C specification for the format descriptor.  This  is a macro that calls <c>UNFORMAT__</c> and passes the current file and line  number as well for improved error messages.  </remarks> 
		</member>
		<member name="M:unpack" syntax="unpack(str[])">
			<stacksize value="135"/>
			<referrer name="Hooks_IsolateName"/>
			<dependency name="strlen"/>
			<dependency name="strunpack"/>
			<dependency name="unpack"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to unpack
			</param>
			  <returns>  unpacked string  </returns>  <remarks>  Mainly used for debugging.  </remarks> 
		</member>
		<member name="M:va_CreatePlayerTextDraw" syntax="va_CreatePlayerTextDraw(playerid, x, y, fmat[], ...)">
			<tagname value="PlayerText"/>
			<stacksize value="146"/>
			<dependency name="CreatePlayerTextDraw"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="playerid">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_GameTextForAll" syntax="va_GameTextForAll(fmat[], time, style, ...)">
			<stacksize value="143"/>
			<dependency name="GameTextForAll"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="time">
			</param>
			<param name="style">
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_GameTextForPlayer" syntax="va_GameTextForPlayer(playerid, fmat[], time, style, ...)">
			<stacksize value="144"/>
			<dependency name="GameTextForPlayer"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="playerid">
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="time">
			</param>
			<param name="style">
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_SendClientMessage" syntax="va_SendClientMessage(playerid, colour, fmat[], ...)">
			<stacksize value="145"/>
			<dependency name="SendClientMessage"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="playerid">
			</param>
			<param name="colour">
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_SendClientMessageToAll" syntax="va_SendClientMessageToAll(colour, fmat[], ...)">
			<stacksize value="144"/>
			<dependency name="SendClientMessageToAll"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="colour">
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_SendPlayerMessageToAll" syntax="va_SendPlayerMessageToAll(senderid, fmat[], ...)">
			<stacksize value="144"/>
			<dependency name="SendPlayerMessageToAll"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="senderid">
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_SendPlayerMessageToPlayer" syntax="va_SendPlayerMessageToPlayer(playerid, senderid, fmat[], ...)">
			<stacksize value="145"/>
			<dependency name="SendPlayerMessageToPlayer"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="playerid">
			</param>
			<param name="senderid">
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_TextDrawCreate" syntax="va_TextDrawCreate(x, y, fmat[], ...)">
			<tagname value="Text"/>
			<stacksize value="145"/>
			<dependency name="TextDrawCreate"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_format" syntax="va_format(output[], len, format[], ...)">
			<attribute name="native"/>
			<referrer name="SCMF"/>
			<param name="output">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_formatex" syntax="va_formatex(output[], size, fmat[], STATIC_ARGS)">
			<stacksize value="1"/>
			<param name="output">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="STATIC_ARGS">
				<paraminfo>va_ </paraminfo>
			</param>
		</member>
		<member name="M:va_fprintf" syntax="va_fprintf(fhnd, fmat[], ...)">
			<stacksize value="144"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="fwrite"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="fhnd">
				<paraminfo>File </paraminfo>
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_getstring" syntax="va_getstring(dest[], arg, len)">
			<stacksize value="1"/>
			<dependency name="strcat"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="arg">
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:va_print" syntax="va_print(fmat[], ...)">
			<stacksize value="143"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="print"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_return" syntax="va_return(fmat[], ...)">
			<stacksize value="131"/>
			<referrer name="va_CreatePlayerTextDraw"/>
			<referrer name="va_TextDrawCreate"/>
			<referrer name="va_SendClientMessage"/>
			<referrer name="va_SendClientMessageToAll"/>
			<referrer name="va_SendPlayerMessageToPlayer"/>
			<referrer name="va_SendPlayerMessageToAll"/>
			<referrer name="va_GameTextForPlayer"/>
			<referrer name="va_GameTextForAll"/>
			<referrer name="va_print"/>
			<referrer name="va_fprintf"/>
			<dependency name="format"/>
			<dependency name="va_return"/>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
				String format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				Parameters.
			</param>
			    <returns>  Formatted string.  </returns>  <remarks>  Just wraps `format` and returns a string instead.  Has extra code to ensure that it works correct on the old compiler.  </remarks> 
		</member>
		<member name="M:va_strlen" syntax="va_strlen(arg)">
			<stacksize value="1"/>
			<dependency name="strlen"/>
			<param name="arg">
			</param>
		</member>

	</members>
</doc>
